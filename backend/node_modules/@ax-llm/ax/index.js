// ai/base.ts
import { SpanKind } from "@opentelemetry/api";

// dsp/modelinfo.ts
function getModelInfo({
  model,
  modelInfo,
  modelMap = {}
}) {
  const mappedModel = modelMap?.[model] ?? model;
  const exactMatch = modelInfo.find((v) => v.name === model);
  if (exactMatch) return exactMatch;
  const normalizedName = mappedModel.replace(/^(anthropic\.|openai\.)/, "").replace(/-latest$/, "").replace(/-\d{8}$/, "").replace(/-v\d+:\d+$/, "").replace(/@\d{8}$/, "").replace(/-\d{2,}(-[a-zA-Z0-9-]+)?$/, "").replace(/-v\d+@\d{8}$/, "").replace(/-v\d+$/, "");
  const normalizedMatch = modelInfo.find((v) => v.name === normalizedName);
  if (normalizedMatch) return normalizedMatch;
  return {
    name: model,
    currency: "usd",
    promptTokenCostPer1M: 0,
    completionTokenCostPer1M: 0
  };
}

// trace/trace.ts
var axSpanAttributes = {
  // LLM
  LLM_SYSTEM: "gen_ai.system",
  LLM_REQUEST_MODEL: "gen_ai.request.model",
  LLM_REQUEST_MAX_TOKENS: "gen_ai.request.max_tokens",
  LLM_REQUEST_TEMPERATURE: "gen_ai.request.temperature",
  LLM_REQUEST_TOP_K: "gen_ai.request.top_k",
  LLM_REQUEST_FREQUENCY_PENALTY: "gen_ai.request.frequency_penalty",
  LLM_REQUEST_PRESENCE_PENALTY: "gen_ai.request.presence_penalty",
  LLM_REQUEST_STOP_SEQUENCES: "gen_ai.request.stop_sequences",
  LLM_REQUEST_LLM_IS_STREAMING: "gen_ai.request.llm_is_streaming",
  LLM_REQUEST_TOP_P: "gen_ai.request.top_p",
  LLM_USAGE_PROMPT_TOKENS: "gen_ai.usage.prompt_tokens",
  LLM_USAGE_COMPLETION_TOKENS: "gen_ai.usage.completion_tokens",
  // Vector DB
  DB_SYSTEM: "db.system",
  DB_TABLE: "db.table",
  DB_NAMESPACE: "db.namespace",
  DB_ID: "db.id",
  DB_QUERY_TEXT: "db.query.text",
  DB_VECTOR: "db.vector",
  DB_OPERATION_NAME: "db.operation.name",
  DB_VECTOR_QUERY_TOP_K: "db.vector.query.top_k",
  DB_QUERY_EMBEDDINGS: "db.query.embeddings",
  DB_QUERY_RESULT: "db.query.result",
  // Query Embeddings
  DB_QUERY_EMBEDDINGS_VECTOR: "db.query.embeddings.vector",
  // Query Result (canonical format)
  DB_QUERY_RESULT_ID: "db.query.result.id",
  DB_QUERY_RESULT_SCORE: "db.query.result.score",
  DB_QUERY_RESULT_DISTANCE: "db.query.result.distance",
  DB_QUERY_RESULT_METADATA: "db.query.result.metadata",
  DB_QUERY_RESULT_VECTOR: "db.query.result.vector",
  DB_QUERY_RESULT_DOCUMENT: "db.query.result.document"
};
var AxLLMRequestTypeValues = /* @__PURE__ */ ((AxLLMRequestTypeValues2) => {
  AxLLMRequestTypeValues2["COMPLETION"] = "completion";
  AxLLMRequestTypeValues2["CHAT"] = "chat";
  AxLLMRequestTypeValues2["RERANK"] = "rerank";
  AxLLMRequestTypeValues2["UNKNOWN"] = "unknown";
  return AxLLMRequestTypeValues2;
})(AxLLMRequestTypeValues || {});
var AxSpanKindValues = /* @__PURE__ */ ((AxSpanKindValues2) => {
  AxSpanKindValues2["WORKFLOW"] = "workflow";
  AxSpanKindValues2["TASK"] = "task";
  AxSpanKindValues2["AGENT"] = "agent";
  AxSpanKindValues2["TOOL"] = "tool";
  AxSpanKindValues2["UNKNOWN"] = "unknown";
  return AxSpanKindValues2;
})(AxSpanKindValues || {});

// util/apicall.ts
import path from "path";
import {
  TextDecoderStream as TextDecoderStreamNative
} from "stream/web";
import "@opentelemetry/api";

// util/sse.ts
import { TransformStream } from "stream/web";
var SSEParser = class extends TransformStream {
  constructor(dataParser = JSON.parse) {
    super({
      transform: (chunk, controller) => this.handleChunk(chunk, controller),
      flush: (controller) => this.handleFlush(controller)
    });
    this.dataParser = dataParser;
  }
  buffer = "";
  currentEvent = { rawData: "" };
  handleChunk(chunk, controller) {
    this.buffer += chunk;
    this.processBuffer(controller);
  }
  handleFlush(controller) {
    this.processBuffer(controller);
    if (this.currentEvent.rawData) {
      this.emitEvent(controller);
    }
  }
  processBuffer(controller) {
    const lines = this.buffer.split(/\r\n|\r|\n/);
    this.buffer = lines.pop() || "";
    for (const line of lines) {
      if (line.trim() === "") {
        this.emitEvent(controller);
      } else {
        this.parseLine(line);
      }
    }
  }
  parseLine(line) {
    const colonIndex = line.indexOf(":");
    if (colonIndex === -1) {
      this.currentEvent.rawData += this.currentEvent.rawData ? "\n" + line.trim() : line.trim();
      return;
    }
    const field = line.slice(0, colonIndex).trim();
    const value = line.slice(colonIndex + 1).trim();
    switch (field) {
      case "event":
        this.currentEvent.event = value;
        break;
      case "data":
        this.currentEvent.rawData += this.currentEvent.rawData ? "\n" + value : value;
        break;
      case "id":
        this.currentEvent.id = value;
        break;
      case "retry": {
        const retryValue = parseInt(value, 10);
        if (!isNaN(retryValue)) {
          this.currentEvent.retry = retryValue;
        }
        break;
      }
    }
  }
  emitEvent(controller) {
    if (this.currentEvent.rawData) {
      if (this.currentEvent.rawData.trim() === "[DONE]" || this.currentEvent.rawData.trim().startsWith("[")) {
        return;
      } else {
        try {
          const parsedData = this.dataParser(this.currentEvent.rawData);
          controller.enqueue(parsedData);
        } catch (e) {
          console.warn("Failed to parse event data:", e);
          console.log(
            "Raw data that failed to parse:",
            this.currentEvent.rawData
          );
        }
      }
      this.currentEvent = { rawData: "" };
    }
  }
};

// util/stream.ts
import {
  TransformStream as TransformStream2
} from "stream/web";
var TextDecodeTransformer = class {
  decoder;
  constructor() {
    this.decoder = new TextDecoder();
  }
  transform(chunk, controller) {
    if (!(chunk instanceof ArrayBuffer || ArrayBuffer.isView(chunk))) {
      throw new TypeError("Input data must be a BufferSource");
    }
    const text = this.decoder.decode(chunk, { stream: true });
    if (text.length !== 0) {
      controller.enqueue(text);
    }
  }
  flush(controller) {
    const text = this.decoder.decode();
    if (text.length !== 0) {
      controller.enqueue(text);
    }
  }
};
var TextDecoderStreamPolyfill = class extends TransformStream2 {
  constructor() {
    super(new TextDecodeTransformer());
  }
};

// util/apicall.ts
var textDecoderStream = TextDecoderStreamNative ?? TextDecoderStreamPolyfill;
var apiCall = async (api, json) => {
  const baseUrl = new URL(process.env["PROXY"] ?? api.url);
  const apiPath = path.join(baseUrl.pathname, api.name ?? "/", baseUrl.search);
  const apiUrl = new URL(apiPath, baseUrl);
  if (api.span?.isRecording()) {
    api.span.setAttributes({
      "http.request.method": api.put ? "PUT" : "POST",
      "url.full": apiUrl.href
    });
  }
  let res;
  try {
    res = await (api.fetch ?? fetch)(apiUrl, {
      method: api.put ? "PUT" : "POST",
      headers: {
        "Content-Type": "application/json",
        ...api.headers
      },
      body: JSON.stringify(json)
    });
    if (res.status >= 400) {
      const reqBody = JSON.stringify(json, null, 2);
      throw new Error(
        `API Request Error: ${res.status}, ${res.statusText}
:Request Body: ${reqBody}`
      );
    }
    if (!api.stream) {
      const resJson = await res.json();
      return resJson;
    }
    if (!res.body) {
      throw new Error("Response body is null");
    }
    const st = res.body.pipeThrough(new textDecoderStream()).pipeThrough(new SSEParser());
    return st;
  } catch (e) {
    if (api.span?.isRecording()) {
      api.span.recordException(e);
    }
    const reqBody = JSON.stringify(json, null, 2);
    throw new Error(
      `API Response Error: ${apiUrl.href}, ${e}
Request Body: ${reqBody}`
    );
  }
};

// util/log.ts
var ColorLog = class {
  // ANSI escape codes for different colors
  ANSI_WHITE_BRIGHT = "\x1B[97m";
  ANSI_GREEN_BRIGHT = "\x1B[92m";
  ANSI_BLUE_BRIGHT = "\x1B[94m";
  ANSI_YELLOW = "\x1B[93m";
  ANSI_RED = "\x1B[91m";
  ANSI_RESET = "\x1B[0m";
  // Method to wrap text with the specified ANSI color code
  colorize(text, colorCode) {
    return `${colorCode}${text}${this.ANSI_RESET}`;
  }
  // Public methods to colorize text in various colors
  whiteBright(text) {
    return this.colorize(text, this.ANSI_WHITE_BRIGHT);
  }
  greenBright(text) {
    return this.colorize(text, this.ANSI_GREEN_BRIGHT);
  }
  blueBright(text) {
    return this.colorize(text, this.ANSI_BLUE_BRIGHT);
  }
  yellow(text) {
    return this.colorize(text, this.ANSI_YELLOW);
  }
  red(text) {
    return this.colorize(text, this.ANSI_RED);
  }
};

// util/transform.ts
import {
  TransformStream as TransformStream3
} from "stream/web";
var TypeTransformer = class {
  buffer;
  doneCallback;
  transformFn;
  constructor(transformFn, doneCallback) {
    this.transformFn = transformFn;
    this.doneCallback = doneCallback;
    this.buffer = doneCallback ? [] : void 0;
  }
  async transform(obj, controller) {
    const val = this.transformFn(obj);
    if (val) {
      controller.enqueue(val);
      this.buffer?.push(val);
    }
  }
  async flush(controller) {
    await this.doneCallback?.(this.buffer ?? []);
    controller.terminate();
  }
};
var RespTransformStream = class extends TransformStream3 {
  constructor(transformFn, doneCallback) {
    super(new TypeTransformer(transformFn, doneCallback));
  }
};

// ai/base.ts
var colorLog = new ColorLog();
var axBaseAIDefaultConfig = () => structuredClone({
  maxTokens: 2e3,
  temperature: 0,
  topK: 40,
  frequencyPenalty: 0.2
});
var AxBaseAI = class {
  constructor(aiImpl, {
    name,
    apiURL,
    headers,
    modelInfo,
    models,
    options = {},
    supportFor,
    modelMap
  }) {
    this.aiImpl = aiImpl;
    this.name = name;
    this.apiURL = apiURL;
    this.headers = headers;
    this.supportFor = supportFor;
    this.tracer = options.tracer;
    this.modelInfo = modelInfo;
    this.modelMap = modelMap;
    this.models = {
      model: modelMap?.[models.model] ?? models.model,
      embedModel: modelMap?.[models.embedModel ?? ""] ?? models.embedModel
    };
    if (!models.model || typeof models.model !== "string" || models.model === "") {
      throw new Error("No model defined");
    }
    this.setOptions(options);
  }
  debug = false;
  rt;
  fetch;
  tracer;
  modelMap;
  modelInfo;
  modelUsage;
  embedModelUsage;
  models;
  apiURL;
  name;
  headers;
  supportFor;
  // Add private metrics tracking properties
  metrics = {
    latency: {
      chat: {
        mean: 0,
        p95: 0,
        p99: 0,
        samples: []
      },
      embed: {
        mean: 0,
        p95: 0,
        p99: 0,
        samples: []
      }
    },
    errors: {
      chat: {
        count: 0,
        rate: 0,
        total: 0
      },
      embed: {
        count: 0,
        rate: 0,
        total: 0
      }
    }
  };
  setName(name) {
    this.name = name;
  }
  setAPIURL(apiURL) {
    this.apiURL = apiURL;
  }
  setHeaders(headers) {
    this.headers = headers;
  }
  setOptions(options) {
    if (options.debug) {
      this.debug = options.debug;
    }
    if (options.rateLimiter) {
      this.rt = options.rateLimiter;
    }
    if (options.fetch) {
      this.fetch = options.fetch;
    }
    if (options.tracer) {
      this.tracer = options.tracer;
    }
  }
  getModelInfo() {
    const mi = getModelInfo({
      model: this.models.model,
      modelInfo: this.modelInfo,
      modelMap: this.modelMap
    });
    return {
      ...mi,
      provider: this.name
    };
  }
  getEmbedModelInfo() {
    if (!this.models.embedModel) {
      return;
    }
    const mi = getModelInfo({
      model: this.models.embedModel,
      modelInfo: this.modelInfo,
      modelMap: this.modelMap
    });
    return {
      ...mi,
      provider: this.name
    };
  }
  getModelMap() {
    return this.modelMap;
  }
  getName() {
    return this.name;
  }
  getFeatures(model) {
    return typeof this.supportFor === "function" ? this.supportFor(model ?? this.models.model) : this.supportFor;
  }
  // Method to calculate percentiles
  calculatePercentile(samples, percentile) {
    if (samples.length === 0) return 0;
    const sorted = [...samples].sort((a, b) => a - b);
    const index = Math.ceil(percentile / 100 * sorted.length) - 1;
    return sorted[index] ?? 0;
  }
  // Method to update latency metrics
  updateLatencyMetrics(type, duration) {
    const metrics = this.metrics.latency[type];
    metrics.samples.push(duration);
    if (metrics.samples.length > 1e3) {
      metrics.samples.shift();
    }
    metrics.mean = metrics.samples.reduce((a, b) => a + b, 0) / metrics.samples.length;
    metrics.p95 = this.calculatePercentile(metrics.samples, 95);
    metrics.p99 = this.calculatePercentile(metrics.samples, 99);
  }
  // Method to update error metrics
  updateErrorMetrics(type, isError) {
    const metrics = this.metrics.errors[type];
    metrics.total++;
    if (isError) {
      metrics.count++;
    }
    metrics.rate = metrics.count / metrics.total;
  }
  // Public method to get metrics
  getMetrics() {
    return structuredClone(this.metrics);
  }
  async chat(req, options) {
    const startTime = performance.now();
    let isError = false;
    try {
      return this._chat1(req, options);
    } catch (error) {
      isError = true;
      throw error;
    } finally {
      const duration = performance.now() - startTime;
      this.updateLatencyMetrics("chat", duration);
      this.updateErrorMetrics("chat", isError);
    }
  }
  async _chat1(req, options) {
    const model = req.model ? this.modelMap?.[req.model] ?? req.model : this.modelMap?.[this.models.model] ?? this.models.model;
    const modelConfig = {
      ...this.aiImpl.getModelConfig(),
      ...req.modelConfig
    };
    modelConfig.stream = (options?.stream !== void 0 ? options.stream : modelConfig.stream) ?? true;
    const canStream = this.getFeatures(model).streaming;
    if (!canStream) {
      modelConfig.stream = false;
    }
    if (this.tracer) {
      return await this.tracer?.startActiveSpan(
        "Chat Request",
        {
          kind: SpanKind.SERVER,
          attributes: {
            [axSpanAttributes.LLM_SYSTEM]: this.name,
            [axSpanAttributes.LLM_REQUEST_MODEL]: model,
            [axSpanAttributes.LLM_REQUEST_MAX_TOKENS]: modelConfig.maxTokens,
            [axSpanAttributes.LLM_REQUEST_TEMPERATURE]: modelConfig.temperature,
            [axSpanAttributes.LLM_REQUEST_TOP_P]: modelConfig.topP,
            [axSpanAttributes.LLM_REQUEST_TOP_K]: modelConfig.topK,
            [axSpanAttributes.LLM_REQUEST_FREQUENCY_PENALTY]: modelConfig.frequencyPenalty,
            [axSpanAttributes.LLM_REQUEST_PRESENCE_PENALTY]: modelConfig.presencePenalty,
            [axSpanAttributes.LLM_REQUEST_STOP_SEQUENCES]: modelConfig.stopSequences?.join(", "),
            [axSpanAttributes.LLM_REQUEST_LLM_IS_STREAMING]: modelConfig.stream
            // [AxSpanAttributes.LLM_PROMPTS]: _req.chatPrompt
            //   ?.map((v) => v.content)
            //   .join('\n')
          }
        },
        async (span) => {
          const res = await this._chat2(model, modelConfig, req, options, span);
          span.end();
          return res;
        }
      );
    }
    return await this._chat2(model, modelConfig, req, options);
  }
  async _chat2(model, modelConfig, chatReq, options, span) {
    if (!this.aiImpl.createChatReq) {
      throw new Error("generateChatReq not implemented");
    }
    let functions;
    if (chatReq.functions && chatReq.functions.length > 0) {
      functions = chatReq.functions;
    }
    const req = {
      ...chatReq,
      model,
      functions,
      modelConfig
    };
    const fn = async () => {
      const [apiConfig, reqValue] = this.aiImpl.createChatReq(
        req,
        options
      );
      const res2 = await apiCall(
        {
          name: apiConfig.name,
          url: this.apiURL,
          headers: this.buildHeaders(apiConfig.headers),
          stream: modelConfig.stream,
          debug: this.debug,
          fetch: this.fetch,
          span
        },
        reqValue
      );
      return res2;
    };
    if (this.debug) {
      logChatRequest(req);
    }
    const rt = options?.rateLimiter ?? this.rt;
    const rv = rt ? await rt(fn, { modelUsage: this.modelUsage }) : await fn();
    if (modelConfig.stream) {
      if (!this.aiImpl.createChatStreamResp) {
        throw new Error("generateChatResp not implemented");
      }
      const respFn = this.aiImpl.createChatStreamResp;
      const wrappedRespFn = (state) => (resp) => {
        const res2 = respFn(resp, state);
        res2.sessionId = options?.sessionId;
        if (res2.modelUsage) {
          this.modelUsage = res2.modelUsage;
        }
        if (span?.isRecording()) {
          setResponseAttr(res2, span);
        }
        if (this.debug) {
          logResponse(res2);
        }
        return res2;
      };
      const doneCb = async (_values) => {
        if (this.debug) {
          process.stdout.write("\n");
        }
      };
      const st = rv.pipeThrough(
        new RespTransformStream(
          wrappedRespFn({}),
          doneCb
        )
      );
      return st;
    }
    if (!this.aiImpl.createChatResp) {
      throw new Error("generateChatResp not implemented");
    }
    const res = this.aiImpl.createChatResp(rv);
    res.sessionId = options?.sessionId;
    if (res.modelUsage) {
      this.modelUsage = res.modelUsage;
    }
    if (span?.isRecording()) {
      setResponseAttr(res, span);
    }
    if (this.debug) {
      logResponse(res);
    }
    span?.end();
    return res;
  }
  async embed(req, options) {
    const startTime = performance.now();
    let isError = false;
    try {
      return this._embed1(req, options);
    } catch (error) {
      isError = true;
      throw error;
    } finally {
      const duration = performance.now() - startTime;
      this.updateLatencyMetrics("embed", duration);
      this.updateErrorMetrics("embed", isError);
    }
  }
  async _embed1(req, options) {
    const embedModel = req.embedModel ? this.modelMap?.[req.embedModel] ?? req.embedModel : this.modelMap?.[this.models.embedModel ?? ""] ?? this.models.embedModel;
    if (!embedModel) {
      throw new Error("No embed model defined");
    }
    if (this.tracer) {
      await this.tracer?.startActiveSpan(
        "Embed Request",
        {
          kind: SpanKind.SERVER,
          attributes: {
            [axSpanAttributes.LLM_SYSTEM]: this.name,
            [axSpanAttributes.LLM_REQUEST_MODEL]: req.embedModel ?? this.models.embedModel
          }
        },
        async (span) => {
          const res = await this._embed2(embedModel, req, options, span);
          span.end();
          return res;
        }
      );
    }
    return this._embed2(embedModel, req, options);
  }
  async _embed2(embedModel, embedReq, options, span) {
    if (!this.aiImpl.createEmbedReq) {
      throw new Error("generateEmbedReq not implemented");
    }
    if (!this.aiImpl.createEmbedResp) {
      throw new Error("generateEmbedResp not implemented");
    }
    const req = {
      ...embedReq,
      embedModel
    };
    const fn = async () => {
      const [apiConfig, reqValue] = this.aiImpl.createEmbedReq(req);
      const res2 = await apiCall(
        {
          name: apiConfig.name,
          url: this.apiURL,
          headers: this.buildHeaders(apiConfig.headers),
          debug: this.debug,
          fetch: this.fetch,
          span
        },
        reqValue
      );
      return res2;
    };
    const resValue = this.rt ? await this.rt(fn, { embedModelUsage: this.embedModelUsage }) : await fn();
    const res = this.aiImpl.createEmbedResp(resValue);
    res.sessionId = options?.sessionId;
    if (span?.isRecording()) {
      if (res.modelUsage) {
        this.embedModelUsage = res.modelUsage;
        span.setAttributes({
          [axSpanAttributes.LLM_USAGE_COMPLETION_TOKENS]: res.modelUsage.completionTokens ?? 0,
          [axSpanAttributes.LLM_USAGE_PROMPT_TOKENS]: res.modelUsage.promptTokens
        });
      }
    }
    span?.end();
    return res;
  }
  buildHeaders(headers = {}) {
    return { ...headers, ...this.headers };
  }
};
var logChatRequest = (req) => {
  const items = req.chatPrompt?.map((msg) => {
    switch (msg.role) {
      case "system":
        return `${colorLog.blueBright("System:")}
${colorLog.whiteBright(msg.content)}`;
      case "function":
        return `${colorLog.blueBright("\nFunction Result:")}
${colorLog.whiteBright(msg.result)}`;
      case "user": {
        if (typeof msg.content === "string") {
          return `${colorLog.blueBright("\nUser:")}
${colorLog.whiteBright(msg.content)}`;
        }
        const items2 = msg.content.map((v) => {
          switch (v.type) {
            case "text":
              return `(Text) ${colorLog.whiteBright(v.text)}`;
            case "image":
              return `(Image, ${v.mimeType}) ${colorLog.whiteBright(v.image.substring(0, 10))}`;
            default:
              throw new Error("Invalid content type");
          }
        });
        return `${colorLog.blueBright("\nUser:")}
${items2.join("\n")}`;
      }
      case "assistant": {
        if (msg.functionCalls) {
          const fns = msg.functionCalls?.map(({ function: fn }) => {
            const args = typeof fn.params !== "string" ? JSON.stringify(fn.params, null, 2) : fn.params;
            return `${fn.name}(${args})`;
          });
          return `${colorLog.blueBright("\nFunctions:")}
${colorLog.whiteBright(fns.join("\n"))}`;
        }
        return `${colorLog.blueBright("\nAssistant:")}
${colorLog.whiteBright(msg.content ?? "<empty>")}`;
      }
      default:
        throw new Error("Invalid role");
    }
  });
  if (items) {
    console.log("\n==========");
    console.log(items.join("\n"));
  }
};
var logResponse = (resp) => {
  if (!resp.results) {
    return;
  }
  for (const r of resp.results) {
    if (r.content) {
      process.stdout.write(colorLog.greenBright(r.content));
    }
    if (r.functionCalls) {
      for (const [i, f] of r.functionCalls.entries()) {
        if (f.function.name) {
          if (i > 0) {
            process.stdout.write("\n\n");
          }
          process.stdout.write(
            `Function ${i + 1} -> ${colorLog.greenBright(f.function.name)} `
          );
        }
        if (f.function.params) {
          const params = typeof f.function.params === "string" ? f.function.params : JSON.stringify(f.function.params, null, 2);
          process.stdout.write(`${colorLog.greenBright(params)}`);
        }
      }
    }
  }
};
var setResponseAttr = (res, span) => {
  if (res.modelUsage) {
    span.setAttributes({
      [axSpanAttributes.LLM_USAGE_COMPLETION_TOKENS]: res.modelUsage.completionTokens ?? 0,
      [axSpanAttributes.LLM_USAGE_PROMPT_TOKENS]: res.modelUsage.promptTokens
    });
  }
};

// ai/anthropic/types.ts
var AxAIAnthropicModel = /* @__PURE__ */ ((AxAIAnthropicModel2) => {
  AxAIAnthropicModel2["Claude35Sonnet"] = "claude-3-5-sonnet-latest";
  AxAIAnthropicModel2["Claude35Haiku"] = "claude-3-5-haiku-latest";
  AxAIAnthropicModel2["Claude3Opus"] = "claude-3-opus-latest";
  AxAIAnthropicModel2["Claude3Sonnet"] = "claude-3-sonnet-20240229";
  AxAIAnthropicModel2["Claude3Haiku"] = "claude-3-haiku-20240307";
  AxAIAnthropicModel2["Claude21"] = "claude-2.1";
  AxAIAnthropicModel2["ClaudeInstant12"] = "claude-instant-1.2";
  return AxAIAnthropicModel2;
})(AxAIAnthropicModel || {});

// ai/anthropic/info.ts
var axModelInfoAnthropic = [
  // 35
  {
    name: "claude-3-5-sonnet-latest" /* Claude35Sonnet */,
    currency: "usd",
    promptTokenCostPer1M: 3,
    completionTokenCostPer1M: 15
  },
  {
    name: "claude-3-5-haiku-latest" /* Claude35Haiku */,
    currency: "usd",
    promptTokenCostPer1M: 0.8,
    completionTokenCostPer1M: 4
  },
  // 3
  {
    name: "claude-3-opus-latest" /* Claude3Opus */,
    currency: "usd",
    promptTokenCostPer1M: 15,
    completionTokenCostPer1M: 75
  },
  {
    name: "claude-3-sonnet-20240229" /* Claude3Sonnet */,
    currency: "usd",
    promptTokenCostPer1M: 3,
    completionTokenCostPer1M: 15
  },
  {
    name: "claude-3-haiku-20240307" /* Claude3Haiku */,
    currency: "usd",
    promptTokenCostPer1M: 0.25,
    completionTokenCostPer1M: 1.25
  },
  // 21
  {
    name: "claude-2.1" /* Claude21 */,
    currency: "usd",
    promptTokenCostPer1M: 8,
    completionTokenCostPer1M: 25
  },
  {
    name: "claude-instant-1.2" /* ClaudeInstant12 */,
    currency: "usd",
    promptTokenCostPer1M: 0.8,
    completionTokenCostPer1M: 2.24
  }
];

// ai/anthropic/api.ts
var axAIAnthropicDefaultConfig = () => structuredClone({
  model: "claude-3-5-sonnet-latest" /* Claude35Sonnet */,
  ...axBaseAIDefaultConfig()
});
var AxAIAnthropicImpl = class {
  constructor(config) {
    this.config = config;
  }
  getModelConfig() {
    const { config } = this;
    return {
      maxTokens: config.maxTokens,
      temperature: config.temperature,
      topP: config.topP,
      topK: config.topK,
      stream: config.stream,
      stopSequences: config.stopSequences,
      endSequences: config.endSequences,
      presencePenalty: config.presencePenalty,
      frequencyPenalty: config.frequencyPenalty,
      n: config.n
    };
  }
  createChatReq = (req) => {
    const model = req.model;
    const apiConfig = {
      name: "/messages"
    };
    const system = req.chatPrompt.filter((msg) => msg.role === "system").map((msg) => ({
      type: "text",
      text: msg.content,
      ...msg.cache ? { cache: { type: "ephemeral" } } : {}
    }));
    const otherMessages = req.chatPrompt.filter((msg) => msg.role !== "system");
    const messages = createMessages(otherMessages);
    const tools = req.functions?.map(
      (v) => ({
        name: v.name,
        description: v.description,
        input_schema: v.parameters
      })
    );
    const stream = req.modelConfig?.stream ?? this.config.stream;
    const reqValue = {
      model,
      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,
      stop_sequences: req.modelConfig?.stopSequences ?? this.config.stopSequences,
      temperature: req.modelConfig?.temperature ?? this.config.temperature,
      top_p: req.modelConfig?.topP ?? this.config.topP,
      top_k: req.modelConfig?.topK ?? this.config.topK,
      ...tools && tools.length > 0 ? { tools, tool_choice: { type: "auto" } } : {},
      ...stream ? { stream: true } : {},
      ...system ? { system } : {},
      messages
    };
    return [apiConfig, reqValue];
  };
  createChatResp = (resp) => {
    if (resp.type === "error") {
      throw new Error(`Anthropic Chat API Error: ${resp.error.message}`);
    }
    const finishReason = mapFinishReason(resp.stop_reason);
    const results = resp.content.map((msg) => {
      if (msg.type === "tool_use") {
        return {
          id: msg.id,
          functionCalls: [
            {
              id: msg.id,
              type: "function",
              function: {
                name: msg.name,
                params: msg.input
              }
            }
          ],
          finishReason
        };
      }
      return {
        content: msg.type === "text" ? msg.text : "",
        id: resp.id,
        finishReason
      };
    });
    const modelUsage = {
      promptTokens: resp.usage.input_tokens,
      completionTokens: resp.usage.output_tokens,
      totalTokens: resp.usage.input_tokens + resp.usage.output_tokens
    };
    return {
      results,
      modelUsage,
      remoteId: resp.id
    };
  };
  createChatStreamResp = (resp, state) => {
    if (!("type" in resp)) {
      throw new Error("Invalid Anthropic streaming event");
    }
    const sstate = state;
    if (!sstate.indexIdMap) {
      sstate.indexIdMap = {};
    }
    if (resp.type === "error") {
      const { error } = resp;
      throw new Error(error.message);
    }
    if (resp.type === "message_start") {
      const { message } = resp;
      const results = [{ content: "", id: message.id }];
      const modelUsage = {
        promptTokens: message.usage?.input_tokens ?? 0,
        completionTokens: message.usage?.output_tokens ?? 0,
        totalTokens: (message.usage?.input_tokens ?? 0) + (message.usage?.output_tokens ?? 0)
      };
      return {
        results,
        modelUsage
      };
    }
    if (resp.type === "content_block_start") {
      const { content_block: contentBlock } = resp;
      if (contentBlock.type === "text") {
        return {
          results: [{ content: contentBlock.text }]
        };
      }
      if (contentBlock.type === "tool_use") {
        if (typeof contentBlock.id === "string" && typeof resp.index === "number" && !sstate.indexIdMap[resp.index]) {
          sstate.indexIdMap[resp.index] = contentBlock.id;
          const functionCalls = [
            {
              id: contentBlock.id,
              type: "function",
              function: {
                name: contentBlock.name,
                params: ""
              }
            }
          ];
          return {
            results: [{ functionCalls }]
          };
        }
      }
    }
    if (resp.type === "content_block_delta") {
      const { delta } = resp;
      if (delta.type === "text_delta") {
        return {
          results: [{ content: delta.text }]
        };
      }
      if (delta.type === "input_json_delta") {
        const id = sstate.indexIdMap[resp.index];
        if (!id) {
          throw new Error("invalid streaming index no id found: " + resp.index);
        }
        const functionCalls = [
          {
            id,
            type: "function",
            function: {
              name: "",
              params: delta.partial_json
            }
          }
        ];
        return {
          results: [{ functionCalls }]
        };
      }
    }
    if (resp.type === "message_delta") {
      const { delta, usage } = resp;
      return {
        results: [
          {
            content: "",
            finishReason: mapFinishReason(delta.stop_reason)
          }
        ],
        modelUsage: {
          promptTokens: 0,
          completionTokens: usage.output_tokens,
          totalTokens: usage.output_tokens
        }
      };
    }
    return {
      results: [{ content: "" }]
    };
  };
};
var AxAIAnthropic = class extends AxBaseAI {
  constructor({
    apiKey,
    config,
    options,
    modelMap
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("Anthropic API key not set");
    }
    const _config = {
      ...axAIAnthropicDefaultConfig(),
      ...config
    };
    const aiImpl = new AxAIAnthropicImpl(_config);
    super(aiImpl, {
      name: "Anthropic",
      apiURL: "https://api.anthropic.com/v1",
      headers: {
        "anthropic-version": "2023-06-01",
        "anthropic-beta": "prompt-caching-2024-07-31",
        "x-api-key": apiKey
      },
      modelInfo: axModelInfoAnthropic,
      models: { model: _config.model },
      options,
      supportFor: { functions: true, streaming: true },
      modelMap
    });
  }
};
function createMessages(chatPrompt) {
  const items = chatPrompt.map((msg) => {
    switch (msg.role) {
      case "function":
        return {
          role: "user",
          content: [
            {
              type: "tool_result",
              content: msg.result,
              tool_use_id: msg.functionId,
              ...msg.cache ? { cache: { type: "ephemeral" } } : {}
            }
          ]
        };
      case "user": {
        if (typeof msg.content === "string") {
          return {
            role: "user",
            content: msg.content
          };
        }
        const content = msg.content.map((v) => {
          switch (v.type) {
            case "text":
              return {
                type: "text",
                text: v.text,
                ...v.cache ? { cache: { type: "ephemeral" } } : {}
              };
            case "image":
              return {
                type: "image",
                source: {
                  type: "base64",
                  media_type: v.mimeType,
                  data: v.image
                },
                ...v.cache ? { cache: { type: "ephemeral" } } : {}
              };
            default:
              throw new Error("Invalid content type");
          }
        });
        return {
          role: "user",
          content
        };
      }
      case "assistant": {
        let content = "";
        if (typeof msg.content === "string") {
          content = msg.content;
        }
        if (typeof msg.functionCalls !== "undefined") {
          content = msg.functionCalls.map((v) => {
            let input;
            if (typeof v.function.params === "string") {
              input = JSON.parse(v.function.params);
            } else if (typeof v.function.params === "object") {
              input = v.function.params;
            }
            return {
              type: "tool_use",
              id: v.id,
              name: v.function.name,
              input,
              ...msg.cache ? { cache: { type: "ephemeral" } } : {}
            };
          });
        }
        return {
          role: "assistant",
          content
        };
      }
      default:
        throw new Error("Invalid role");
    }
  });
  return mergeAssistantMessages(items);
}
function mergeAssistantMessages(messages) {
  const mergedMessages = [];
  for (const [i, cur] of messages.entries()) {
    if (cur.role !== "assistant") {
      mergedMessages.push(cur);
      continue;
    }
    if (i > 0 && messages.at(i - 1)?.role === "assistant") {
      const lastMessage = mergedMessages.pop();
      mergedMessages.push({
        ...lastMessage ? lastMessage : {},
        ...cur
      });
    } else {
      mergedMessages.push(cur);
    }
  }
  return mergedMessages;
}
function mapFinishReason(stopReason) {
  if (!stopReason) {
    return void 0;
  }
  switch (stopReason) {
    case "stop_sequence":
      return "stop";
      break;
    case "max_tokens":
      return "length";
      break;
    case "tool_use":
      return "function_call";
      break;
    case "end_turn":
      return "stop";
      break;
    default:
      return "stop";
  }
}

// ai/openai/types.ts
var AxAIOpenAIModel = /* @__PURE__ */ ((AxAIOpenAIModel2) => {
  AxAIOpenAIModel2["O1Preview"] = "o1-preview";
  AxAIOpenAIModel2["O1Mini"] = "o1-mini";
  AxAIOpenAIModel2["GPT4"] = "gpt-4";
  AxAIOpenAIModel2["GPT4O"] = "gpt-4o";
  AxAIOpenAIModel2["GPT4OMini"] = "gpt-4o-mini";
  AxAIOpenAIModel2["GPT4ChatGPT4O"] = "chatgpt-4o-latest";
  AxAIOpenAIModel2["GPT4Turbo"] = "gpt-4-turbo";
  AxAIOpenAIModel2["GPT35Turbo"] = "gpt-3.5-turbo";
  AxAIOpenAIModel2["GPT35TurboInstruct"] = "gpt-3.5-turbo-instruct";
  AxAIOpenAIModel2["GPT35TextDavinci002"] = "text-davinci-002";
  AxAIOpenAIModel2["GPT3TextBabbage002"] = "text-babbage-002";
  AxAIOpenAIModel2["GPT3TextAda001"] = "text-ada-001";
  return AxAIOpenAIModel2;
})(AxAIOpenAIModel || {});
var AxAIOpenAIEmbedModel = /* @__PURE__ */ ((AxAIOpenAIEmbedModel2) => {
  AxAIOpenAIEmbedModel2["TextEmbeddingAda002"] = "text-embedding-ada-002";
  AxAIOpenAIEmbedModel2["TextEmbedding3Small"] = "text-embedding-3-small";
  AxAIOpenAIEmbedModel2["TextEmbedding3Large"] = "text-embedding-3-large";
  return AxAIOpenAIEmbedModel2;
})(AxAIOpenAIEmbedModel || {});

// ai/openai/info.ts
var axModelInfoOpenAI = [
  {
    name: "o1-preview" /* O1Preview */,
    currency: "usd",
    promptTokenCostPer1M: 15,
    completionTokenCostPer1M: 60
  },
  {
    name: "o1-mini" /* O1Mini */,
    currency: "usd",
    promptTokenCostPer1M: 3,
    completionTokenCostPer1M: 12
  },
  {
    name: "gpt-4" /* GPT4 */,
    currency: "usd",
    promptTokenCostPer1M: 30,
    completionTokenCostPer1M: 60
  },
  {
    name: "gpt-4o" /* GPT4O */,
    currency: "usd",
    promptTokenCostPer1M: 5,
    completionTokenCostPer1M: 15
  },
  {
    name: "gpt-4o-mini" /* GPT4OMini */,
    currency: "usd",
    promptTokenCostPer1M: 0.15,
    completionTokenCostPer1M: 0.6
  },
  {
    name: "chatgpt-4o-latest" /* GPT4ChatGPT4O */,
    currency: "usd",
    promptTokenCostPer1M: 5,
    completionTokenCostPer1M: 15
  },
  {
    name: "gpt-4-turbo" /* GPT4Turbo */,
    currency: "usd",
    promptTokenCostPer1M: 10,
    completionTokenCostPer1M: 30
  },
  {
    name: "gpt-3.5-turbo" /* GPT35Turbo */,
    currency: "usd",
    promptTokenCostPer1M: 0.5,
    completionTokenCostPer1M: 1.5
  },
  {
    name: "text-embedding-ada-002" /* TextEmbeddingAda002 */,
    currency: "usd",
    promptTokenCostPer1M: 0.1,
    completionTokenCostPer1M: 0.1
  },
  {
    name: "text-embedding-3-small" /* TextEmbedding3Small */,
    currency: "usd",
    promptTokenCostPer1M: 0.02,
    completionTokenCostPer1M: 0.02
  },
  {
    name: "text-embedding-3-large" /* TextEmbedding3Large */,
    currency: "usd",
    promptTokenCostPer1M: 0.13,
    completionTokenCostPer1M: 0.13
  }
];

// ai/openai/api.ts
var axAIOpenAIDefaultConfig = () => structuredClone({
  model: "gpt-4o" /* GPT4O */,
  embedModel: "text-embedding-3-small" /* TextEmbedding3Small */,
  ...axBaseAIDefaultConfig()
});
var AxAIOpenAIImpl = class {
  constructor(config, streamingUsage, dimensions) {
    this.config = config;
    this.streamingUsage = streamingUsage;
    this.dimensions = dimensions;
  }
  getModelConfig() {
    const { config } = this;
    return {
      maxTokens: config.maxTokens,
      temperature: config.temperature,
      presencePenalty: config.presencePenalty,
      frequencyPenalty: config.frequencyPenalty,
      stopSequences: config.stopSequences,
      endSequences: config.endSequences,
      topP: config.topP,
      n: config.n,
      stream: config.stream
    };
  }
  createChatReq(req, _config) {
    const model = req.model;
    if (!req.chatPrompt || req.chatPrompt.length === 0) {
      throw new Error("Chat prompt is empty");
    }
    const apiConfig = {
      name: "/chat/completions"
    };
    const tools = req.functions?.map((v) => ({
      type: "function",
      function: {
        name: v.name,
        description: v.description,
        parameters: v.parameters
      }
    }));
    if (tools && isO1Model(model)) {
      throw new Error("Functions are not supported for O1 models");
    }
    const toolsChoice = !req.functionCall && req.functions && req.functions.length > 0 ? "auto" : req.functionCall;
    const messages = createMessages2(req);
    const frequencyPenalty = req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty;
    const stream = req.modelConfig?.stream ?? this.config.stream;
    if (stream && isO1Model(model)) {
      throw new Error("Streaming is not supported for O1 models");
    }
    const reqValue = {
      model,
      messages,
      response_format: this.config?.responseFormat ? { type: this.config?.responseFormat } : void 0,
      tools,
      tool_choice: toolsChoice,
      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens ?? 500,
      temperature: req.modelConfig?.temperature ?? this.config.temperature,
      top_p: req.modelConfig?.topP ?? this.config.topP ?? 1,
      n: req.modelConfig?.n ?? this.config.n,
      stop: req.modelConfig?.stopSequences ?? this.config.stop,
      presence_penalty: req.modelConfig?.presencePenalty ?? this.config.presencePenalty,
      logit_bias: this.config.logitBias,
      ...frequencyPenalty ? { frequency_penalty: frequencyPenalty } : {},
      ...stream && this.streamingUsage ? { stream: true, stream_options: { include_usage: true } } : {}
    };
    return [apiConfig, reqValue];
  }
  createEmbedReq(req) {
    const model = req.embedModel;
    if (!model) {
      throw new Error("Embed model not set");
    }
    if (!req.texts || req.texts.length === 0) {
      throw new Error("Embed texts is empty");
    }
    const apiConfig = {
      name: "/embeddings"
    };
    const reqValue = {
      model,
      input: req.texts,
      dimensions: this.dimensions
    };
    return [apiConfig, reqValue];
  }
  createChatResp(resp) {
    const { id, usage, choices, error } = resp;
    if (error) {
      throw error;
    }
    const modelUsage = usage ? {
      promptTokens: usage.prompt_tokens,
      completionTokens: usage.completion_tokens,
      totalTokens: usage.total_tokens
    } : void 0;
    const results = choices.map((choice) => {
      const finishReason = mapFinishReason2(choice.finish_reason);
      const functionCalls = choice.message.tool_calls?.map(
        ({ id: id2, function: { arguments: params, name } }) => ({
          id: id2,
          type: "function",
          function: { name, params }
        })
      );
      return {
        id: `${choice.index}`,
        content: choice.message.content,
        functionCalls,
        finishReason
      };
    });
    return {
      modelUsage,
      results,
      remoteId: id
    };
  }
  createChatStreamResp(resp, state) {
    const { id, usage, choices } = resp;
    const modelUsage = usage ? {
      promptTokens: usage.prompt_tokens,
      completionTokens: usage.completion_tokens,
      totalTokens: usage.total_tokens
    } : void 0;
    const sstate = state;
    if (!sstate.indexIdMap) {
      sstate.indexIdMap = {};
    }
    const results = choices.map(
      ({
        delta: { content, role, tool_calls: toolCalls },
        finish_reason: oaiFinishReason
      }) => {
        const finishReason = mapFinishReason2(oaiFinishReason);
        const functionCalls = toolCalls?.map(({ id: _id, index, function: { name, arguments: params } }) => {
          if (typeof _id === "string" && typeof index === "number" && !sstate.indexIdMap[index]) {
            sstate.indexIdMap[index] = _id;
          }
          const id2 = sstate.indexIdMap[index];
          if (!id2) {
            return null;
          }
          return {
            id: id2,
            type: "function",
            function: { name, params }
          };
        }).filter((v) => v !== null);
        return {
          content,
          role,
          functionCalls,
          finishReason,
          id
        };
      }
    );
    return {
      results,
      modelUsage
    };
  }
  createEmbedResp(resp) {
    const { data, usage } = resp;
    const modelUsage = usage ? {
      promptTokens: usage.prompt_tokens,
      completionTokens: usage.completion_tokens,
      totalTokens: usage.total_tokens
    } : void 0;
    return {
      embeddings: data.map((v) => v.embedding),
      modelUsage
    };
  }
};
var mapFinishReason2 = (finishReason) => {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "error";
    case "tool_calls":
      return "function_call";
  }
};
function createMessages2(req) {
  return req.chatPrompt.map((msg) => {
    if (msg.role === "system" && isO1Model(req.model)) {
      msg = {
        role: "user",
        content: msg.content
      };
    }
    switch (msg.role) {
      case "system":
        return { role: "system", content: msg.content };
      case "user":
        if (Array.isArray(msg.content)) {
          return {
            role: "user",
            name: msg.name,
            content: msg.content.map((c) => {
              switch (c.type) {
                case "text":
                  return { type: "text", text: c.text };
                case "image": {
                  const url = `data:${c.mimeType};base64,` + c.image;
                  return {
                    type: "image_url",
                    image_url: { url, details: c.details ?? "auto" }
                  };
                }
                case "audio": {
                  const data = c.data;
                  return {
                    type: "input_audio",
                    input_audio: { data, format: c.format ?? "wav" }
                  };
                }
                default:
                  throw new Error("Invalid content type");
              }
            })
          };
        }
        return { role: "user", content: msg.content, name: msg.name };
      case "assistant":
        return {
          role: "assistant",
          content: msg.content,
          name: msg.name,
          tool_calls: msg.functionCalls?.map((v) => ({
            id: v.id,
            type: "function",
            function: {
              name: v.function.name,
              arguments: typeof v.function.params === "object" ? JSON.stringify(v.function.params) : v.function.params
            }
          }))
        };
      case "function":
        return {
          role: "tool",
          content: msg.result,
          tool_call_id: msg.functionId
        };
      default:
        throw new Error("Invalid role");
    }
  });
}
var AxAIOpenAI = class extends AxBaseAI {
  constructor({
    apiKey,
    config,
    options,
    apiURL,
    modelInfo = axModelInfoOpenAI,
    modelMap
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("OpenAI API key not set");
    }
    const _config = {
      ...axAIOpenAIDefaultConfig(),
      ...config
    };
    const aiImpl = new AxAIOpenAIImpl(
      _config,
      options?.streamingUsage ?? true,
      config?.dimensions
    );
    super(aiImpl, {
      name: "OpenAI",
      apiURL: apiURL ? apiURL : "https://api.openai.com/v1",
      headers: { Authorization: `Bearer ${apiKey}` },
      modelInfo,
      models: {
        model: _config.model,
        embedModel: _config.embedModel
      },
      options,
      supportFor: (model) => {
        return isO1Model(model) ? { functions: false, streaming: false } : { functions: true, streaming: true };
      },
      modelMap
    });
  }
};
var isO1Model = (model) => ["o1-mini" /* O1Mini */, "o1-preview" /* O1Preview */].includes(
  model
);

// ai/azure-openai/api.ts
var axAIAzureOpenAIDefaultConfig = axAIOpenAIDefaultConfig;
var AxAIAzureOpenAI = class extends AxAIOpenAI {
  constructor({
    apiKey,
    resourceName,
    deploymentName,
    version = "api-version=2024-02-15-preview",
    config,
    options,
    modelMap
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("Azure OpenAPI API key not set");
    }
    if (!resourceName || resourceName === "") {
      throw new Error("Azure OpenAPI resource name not set");
    }
    if (!deploymentName || deploymentName === "") {
      throw new Error("Azure OpenAPI deployment id not set");
    }
    const _config = {
      ...axAIAzureOpenAIDefaultConfig(),
      ...config
    };
    super({ apiKey, config: _config, options, modelMap });
    const host = resourceName.includes("://") ? resourceName : `https://${resourceName}.openai.azure.com/`;
    super.setName("Azure OpenAI");
    super.setAPIURL(
      new URL(
        `/openai/deployments/${deploymentName}?api-version=${version}`,
        host
      ).href
    );
    super.setHeaders({ "api-key": apiKey });
  }
};

// ai/cohere/types.ts
var AxAICohereModel = /* @__PURE__ */ ((AxAICohereModel2) => {
  AxAICohereModel2["CommandRPlus"] = "command-r-plus";
  AxAICohereModel2["CommandR"] = "command-r";
  AxAICohereModel2["Command"] = "command";
  AxAICohereModel2["CommandLight"] = "command-light";
  return AxAICohereModel2;
})(AxAICohereModel || {});
var AxAICohereEmbedModel = /* @__PURE__ */ ((AxAICohereEmbedModel2) => {
  AxAICohereEmbedModel2["EmbedEnglishV30"] = "embed-english-v3.0";
  AxAICohereEmbedModel2["EmbedEnglishLightV30"] = "embed-english-light-v3.0";
  AxAICohereEmbedModel2["EmbedMultiLingualV30"] = "embed-multilingual-v3.0";
  AxAICohereEmbedModel2["EmbedMultiLingualLightV30"] = "embed-multilingual-light-v3.0";
  return AxAICohereEmbedModel2;
})(AxAICohereEmbedModel || {});

// ai/cohere/info.ts
var axModelInfoCohere = [
  {
    name: "command-r-plus" /* CommandRPlus */,
    currency: "usd",
    promptTokenCostPer1M: 3,
    completionTokenCostPer1M: 15
  },
  {
    name: "command-r" /* CommandR */,
    currency: "usd",
    promptTokenCostPer1M: 0.5,
    completionTokenCostPer1M: 1.5
  },
  {
    name: "command" /* Command */,
    currency: "usd",
    promptTokenCostPer1M: 0.5,
    completionTokenCostPer1M: 1.5
  },
  {
    name: "command-light" /* CommandLight */,
    currency: "usd",
    promptTokenCostPer1M: 0.3,
    completionTokenCostPer1M: 0.6
  },
  {
    name: "embed-english-light-v3.0" /* EmbedEnglishLightV30 */,
    currency: "usd",
    promptTokenCostPer1M: 0.1,
    completionTokenCostPer1M: 0.1
  },
  {
    name: "embed-english-v3.0" /* EmbedEnglishV30 */,
    currency: "usd",
    promptTokenCostPer1M: 0.1,
    completionTokenCostPer1M: 0.1
  },
  {
    name: "embed-multilingual-v3.0" /* EmbedMultiLingualV30 */,
    currency: "usd",
    promptTokenCostPer1M: 0.1,
    completionTokenCostPer1M: 0.1
  },
  {
    name: "embed-multilingual-light-v3.0" /* EmbedMultiLingualLightV30 */,
    currency: "usd",
    promptTokenCostPer1M: 0.1,
    completionTokenCostPer1M: 0.1
  }
];

// ai/cohere/api.ts
var axAICohereDefaultConfig = () => structuredClone({
  model: "command-r-plus" /* CommandRPlus */,
  embedModel: "embed-english-v3.0" /* EmbedEnglishV30 */,
  ...axBaseAIDefaultConfig()
});
var AxAICohereImpl = class {
  constructor(config) {
    this.config = config;
  }
  getModelConfig() {
    const { config } = this;
    return {
      maxTokens: config.maxTokens,
      temperature: config.temperature,
      topP: config.topP,
      topK: config.topK,
      frequencyPenalty: config.frequencyPenalty,
      presencePenalty: config.presencePenalty,
      endSequences: config.endSequences,
      stopSequences: config.stopSequences,
      stream: config.stream,
      n: config.n
    };
  }
  createChatReq(req, _config) {
    const model = req.model;
    const lastChatMsg = req.chatPrompt.at(-1);
    const restOfChat = req.chatPrompt.slice(0, -1);
    let message;
    if (lastChatMsg && lastChatMsg.role === "user" && typeof lastChatMsg.content === "string") {
      message = lastChatMsg?.content;
    }
    const chatHistory = createHistory(restOfChat);
    const tools = req.functions?.map((v) => {
      const props = {};
      if (v.parameters?.properties) {
        for (const [key, value] of Object.entries(v.parameters.properties)) {
          props[key] = {
            description: value.description,
            type: value.type,
            required: v.parameters.required?.includes(key) ?? false
          };
        }
      }
      return {
        name: v.name,
        description: v.description,
        parameter_definitions: props
      };
    });
    const toolResults = req.chatPrompt.filter((chat) => chat.role === "function").map((chat) => {
      const fn = tools?.find((t) => t.name === chat.functionId);
      if (!fn) {
        throw new Error("Function not found");
      }
      return {
        call: { name: fn.name, parameters: fn.parameter_definitions },
        outputs: [{ result: chat.result ?? "" }]
      };
    });
    const apiConfig = {
      name: "/chat"
    };
    const reqValue = {
      message,
      model,
      tools,
      ...toolResults && !message ? { tool_results: toolResults } : {},
      chat_history: chatHistory,
      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,
      temperature: req.modelConfig?.temperature ?? this.config.temperature,
      k: req.modelConfig?.topK ?? this.config.topK,
      p: req.modelConfig?.topP ?? this.config.topP,
      frequency_penalty: req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty,
      presence_penalty: req.modelConfig?.presencePenalty ?? this.config.presencePenalty,
      end_sequences: this.config.endSequences,
      stop_sequences: req.modelConfig?.stopSequences ?? this.config.stopSequences
    };
    return [apiConfig, reqValue];
  }
  createEmbedReq = (req) => {
    const model = req.embedModel;
    if (!model) {
      throw new Error("Embed model not set");
    }
    if (!req.texts || req.texts.length === 0) {
      throw new Error("Embed texts is empty");
    }
    const apiConfig = {
      name: "/embed"
    };
    const reqValue = {
      model,
      texts: req.texts ?? [],
      input_type: "classification",
      truncate: ""
    };
    return [apiConfig, reqValue];
  };
  createChatResp = (resp) => {
    const modelUsage = resp.meta.billed_units ? {
      promptTokens: resp.meta.billed_units.input_tokens,
      completionTokens: resp.meta.billed_units.output_tokens,
      totalTokens: resp.meta.billed_units.input_tokens + resp.meta.billed_units.output_tokens
    } : void 0;
    let finishReason;
    if ("finish_reason" in resp) {
      switch (resp.finish_reason) {
        case "COMPLETE":
          finishReason = "stop";
          break;
        case "MAX_TOKENS":
          finishReason = "length";
          break;
        case "ERROR":
          throw new Error("Finish reason: ERROR");
        case "ERROR_TOXIC":
          throw new Error("Finish reason: CONTENT_FILTER");
        default:
          finishReason = "stop";
          break;
      }
    }
    let functionCalls;
    if ("tool_calls" in resp) {
      functionCalls = resp.tool_calls?.map(
        (v) => {
          return {
            id: v.name,
            type: "function",
            function: { name: v.name, params: v.parameters }
          };
        }
      );
    }
    const results = [
      {
        id: resp.generation_id,
        content: resp.text,
        functionCalls,
        finishReason
      }
    ];
    return {
      results,
      modelUsage,
      remoteId: resp.response_id
    };
  };
  createChatStreamResp = (resp, state) => {
    const ss = state;
    if (resp.event_type === "stream-start") {
      ss.generation_id = resp.generation_id;
    }
    const { results } = this.createChatResp(resp);
    const result = results[0];
    if (!result) {
      throw new Error("No result");
    }
    result.id = ss.generation_id ?? "";
    return { results };
  };
  createEmbedResp(resp) {
    return {
      remoteId: resp.id,
      embeddings: resp.embeddings
    };
  }
};
var AxAICohere = class extends AxBaseAI {
  constructor({
    apiKey,
    config,
    options,
    modelMap
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("Cohere API key not set");
    }
    const _config = {
      ...axAICohereDefaultConfig(),
      ...config
    };
    const aiImpl = new AxAICohereImpl(_config);
    super(aiImpl, {
      name: "Cohere",
      apiURL: "https://api.cohere.ai/v1",
      headers: { Authorization: `Bearer ${apiKey}` },
      modelInfo: axModelInfoCohere,
      models: { model: _config.model },
      supportFor: { functions: true, streaming: true },
      options,
      modelMap
    });
  }
};
function createHistory(chatPrompt) {
  return chatPrompt.map((chat) => {
    let message = "";
    if (chat.role === "system" || chat.role === "assistant" || chat.role === "user") {
      if (typeof chat.content === "string") {
        message = chat.content;
      } else {
        throw new Error("Multi-modal content not supported");
      }
    }
    switch (chat.role) {
      case "user":
        return { role: "USER", message };
      case "system":
        return { role: "SYSTEM", message };
      case "assistant": {
        const toolCalls = createToolCall(chat.functionCalls);
        return {
          role: "CHATBOT",
          message,
          tool_calls: toolCalls
        };
      }
      case "function": {
        const functionCalls = chatPrompt.map((v) => {
          if (v.role === "assistant") {
            return v.functionCalls?.find((f) => f.id === chat.functionId);
          }
          return void 0;
        }).filter((v) => v !== void 0);
        const call = createToolCall(functionCalls)?.at(0);
        if (!call) {
          throw new Error("Function call not found");
        }
        const outputs = [{ result: chat.result }];
        return {
          role: "TOOL",
          tool_results: [
            {
              call,
              outputs
            }
          ]
        };
      }
      default:
        throw new Error("Unknown role");
    }
  });
}
function createToolCall(functionCalls) {
  return functionCalls?.map((v) => {
    const parameters = typeof v.function.params === "string" ? JSON.parse(v.function.params) : v.function.params;
    return { name: v.function.name, parameters };
  });
}

// ai/deepseek/types.ts
var AxAIDeepSeekModel = /* @__PURE__ */ ((AxAIDeepSeekModel2) => {
  AxAIDeepSeekModel2["DeepSeekChat"] = "deepseek-chat";
  AxAIDeepSeekModel2["DeepSeekCoder"] = "deepseek-coder";
  return AxAIDeepSeekModel2;
})(AxAIDeepSeekModel || {});

// ai/deepseek/info.ts
var axModelInfoDeepSeek = [
  {
    name: "deepseek-chat" /* DeepSeekChat */,
    currency: "USD",
    promptTokenCostPer1M: 0.14,
    completionTokenCostPer1M: 0.28
  },
  {
    name: "deepseek-coder" /* DeepSeekCoder */,
    currency: "USD",
    promptTokenCostPer1M: 0.14,
    completionTokenCostPer1M: 0.28
  }
];

// ai/deepseek/api.ts
var axAIDeepSeekDefaultConfig = () => structuredClone({
  model: "deepseek-chat" /* DeepSeekChat */,
  ...axBaseAIDefaultConfig()
});
var AxAIDeepSeek = class extends AxAIOpenAI {
  constructor({
    apiKey,
    config,
    options,
    modelMap
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("DeepSeek API key not set");
    }
    const _config = {
      ...axAIDeepSeekDefaultConfig(),
      ...config
    };
    super({
      apiKey,
      config: _config,
      options,
      apiURL: "https://api.deepseek.com",
      modelInfo: axModelInfoDeepSeek,
      modelMap
    });
    super.setName("DeepSeek");
  }
};

// ai/google-gemini/types.ts
var AxAIGoogleGeminiModel = /* @__PURE__ */ ((AxAIGoogleGeminiModel2) => {
  AxAIGoogleGeminiModel2["Gemini1Pro"] = "gemini-1.0-pro";
  AxAIGoogleGeminiModel2["Gemini15Flash"] = "gemini-1.5-flash";
  AxAIGoogleGeminiModel2["Gemini15Flash8B"] = "gemini-1.5-flash-8b";
  AxAIGoogleGeminiModel2["Gemini15Pro"] = "gemini-1.5-pro";
  AxAIGoogleGeminiModel2["Gemma2"] = "gemma-2-27b-it";
  AxAIGoogleGeminiModel2["AQA"] = "aqa";
  return AxAIGoogleGeminiModel2;
})(AxAIGoogleGeminiModel || {});
var AxAIGoogleGeminiEmbedModel = /* @__PURE__ */ ((AxAIGoogleGeminiEmbedModel2) => {
  AxAIGoogleGeminiEmbedModel2["TextEmbedding004"] = "text-embedding-004";
  return AxAIGoogleGeminiEmbedModel2;
})(AxAIGoogleGeminiEmbedModel || {});
var AxAIGoogleGeminiSafetyCategory = /* @__PURE__ */ ((AxAIGoogleGeminiSafetyCategory2) => {
  AxAIGoogleGeminiSafetyCategory2["HarmCategoryHarassment"] = "HARM_CATEGORY_HARASSMENT";
  AxAIGoogleGeminiSafetyCategory2["HarmCategoryHateSpeech"] = "HARM_CATEGORY_HATE_SPEECH";
  AxAIGoogleGeminiSafetyCategory2["HarmCategorySexuallyExplicit"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
  AxAIGoogleGeminiSafetyCategory2["HarmCategoryDangerousContent"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
  return AxAIGoogleGeminiSafetyCategory2;
})(AxAIGoogleGeminiSafetyCategory || {});
var AxAIGoogleGeminiSafetyThreshold = /* @__PURE__ */ ((AxAIGoogleGeminiSafetyThreshold2) => {
  AxAIGoogleGeminiSafetyThreshold2["BlockNone"] = "BLOCK_NONE";
  AxAIGoogleGeminiSafetyThreshold2["BlockOnlyHigh"] = "BLOCK_ONLY_HIGH";
  AxAIGoogleGeminiSafetyThreshold2["BlockMediumAndAbove"] = "BLOCK_MEDIUM_AND_ABOVE";
  AxAIGoogleGeminiSafetyThreshold2["BlockLowAndAbove"] = "BLOCK_LOW_AND_ABOVE";
  AxAIGoogleGeminiSafetyThreshold2["BlockDefault"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
  return AxAIGoogleGeminiSafetyThreshold2;
})(AxAIGoogleGeminiSafetyThreshold || {});

// ai/google-gemini/info.ts
var axModelInfoGoogleGemini = [
  {
    name: "gemini-1.5-flash" /* Gemini15Flash */,
    currency: "usd",
    characterIsToken: true,
    promptTokenCostPer1M: 0.075,
    completionTokenCostPer1M: 0.3
  },
  {
    name: "gemini-1.5-flash-8b" /* Gemini15Flash8B */,
    currency: "usd",
    characterIsToken: true,
    promptTokenCostPer1M: 0.0375,
    completionTokenCostPer1M: 0.15
  },
  {
    name: "gemini-1.5-pro" /* Gemini15Pro */,
    currency: "usd",
    characterIsToken: true,
    promptTokenCostPer1M: 1.25,
    completionTokenCostPer1M: 5
  },
  {
    name: "gemini-1.0-pro" /* Gemini1Pro */,
    currency: "usd",
    characterIsToken: true,
    promptTokenCostPer1M: 0.5,
    completionTokenCostPer1M: 1.5
  }
];

// ai/google-gemini/api.ts
var safetySettings = [
  {
    category: "HARM_CATEGORY_HARASSMENT" /* HarmCategoryHarassment */,
    threshold: "BLOCK_NONE" /* BlockNone */
  },
  {
    category: "HARM_CATEGORY_HATE_SPEECH" /* HarmCategoryHateSpeech */,
    threshold: "BLOCK_NONE" /* BlockNone */
  },
  {
    category: "HARM_CATEGORY_SEXUALLY_EXPLICIT" /* HarmCategorySexuallyExplicit */,
    threshold: "BLOCK_NONE" /* BlockNone */
  },
  {
    category: "HARM_CATEGORY_DANGEROUS_CONTENT" /* HarmCategoryDangerousContent */,
    threshold: "BLOCK_NONE" /* BlockNone */
  }
];
var axAIGoogleGeminiDefaultConfig = () => structuredClone({
  model: "gemini-1.5-pro" /* Gemini15Pro */,
  embedModel: "text-embedding-004" /* TextEmbedding004 */,
  safetySettings,
  ...axBaseAIDefaultConfig()
});
var AxAIGoogleGeminiImpl = class {
  constructor(config, apiKey, isVertex, options) {
    this.config = config;
    this.apiKey = apiKey;
    this.isVertex = isVertex;
    this.options = options;
  }
  getModelConfig() {
    const { config } = this;
    return {
      maxTokens: config.maxTokens,
      temperature: config.temperature,
      topP: config.topP,
      topK: config.topK,
      presencePenalty: config.presencePenalty,
      frequencyPenalty: config.frequencyPenalty,
      stopSequences: config.stopSequences,
      endSequences: config.endSequences,
      stream: config.stream,
      n: config.n
    };
  }
  createChatReq = (req) => {
    const model = req.model;
    const stream = req.modelConfig?.stream ?? this.config.stream;
    if (!req.chatPrompt || req.chatPrompt.length === 0) {
      throw new Error("Chat prompt is empty");
    }
    const apiConfig = {
      name: stream ? `/models/${model}:streamGenerateContent?alt=sse` : `/models/${model}:createContent`
    };
    if (this.isVertex === false) {
      const pf = stream ? "&" : "?";
      apiConfig.name += `${pf}key=${this.apiKey}`;
    }
    const systemPrompts = req.chatPrompt.filter((p) => p.role === "system").map((p) => p.content);
    const systemInstruction = systemPrompts.length > 0 ? {
      role: "user",
      parts: [{ text: systemPrompts.join(" ") }]
    } : void 0;
    const contents = req.chatPrompt.filter((p) => p.role !== "system").map((msg, i) => {
      switch (msg.role) {
        case "user": {
          const parts = Array.isArray(msg.content) ? msg.content.map((c, i2) => {
            switch (c.type) {
              case "text":
                return { text: c.text };
              case "image":
                return {
                  inlineData: { mimeType: c.mimeType, data: c.image }
                };
              default:
                throw new Error(
                  `Chat prompt content type not supported (index: ${i2})`
                );
            }
          }) : [{ text: msg.content }];
          return {
            role: "user",
            parts
          };
        }
        case "assistant": {
          let parts = [];
          if (msg.functionCalls) {
            parts = msg.functionCalls.map((f) => {
              const args = typeof f.function.params === "string" ? JSON.parse(f.function.params) : f.function.params;
              return {
                functionCall: {
                  name: f.function.name,
                  args
                }
              };
            });
            if (!parts) {
              throw new Error("Function call is empty");
            }
            return {
              role: "model",
              parts
            };
          }
          if (!msg.content) {
            throw new Error("Assistant content is empty");
          }
          parts = [{ text: msg.content }];
          return {
            role: "model",
            parts
          };
        }
        case "function": {
          if (!("functionId" in msg)) {
            throw new Error(`Chat prompt functionId is empty (index: ${i})`);
          }
          const parts = [
            {
              functionResponse: {
                name: msg.functionId,
                response: { result: msg.result }
              }
            }
          ];
          return {
            role: "function",
            parts
          };
        }
        default:
          throw new Error("Invalid role");
      }
    });
    let tools = [];
    if (req.functions && req.functions.length > 0) {
      tools.push({ function_declarations: req.functions });
    }
    if (this.options?.codeExecution) {
      tools.push({ code_execution: {} });
    }
    if (this.options?.googleSearchRetrieval) {
      tools.push({
        google_search_retrieval: {
          dynamic_retrieval_config: this.options.googleSearchRetrieval
        }
      });
    }
    if (tools.length === 0) {
      tools = void 0;
    }
    let toolConfig;
    if (req.functionCall) {
      if (req.functionCall === "none") {
        toolConfig = { function_calling_config: { mode: "NONE" } };
      } else if (req.functionCall === "auto") {
        toolConfig = { function_calling_config: { mode: "AUTO" } };
      } else if (req.functionCall === "required") {
        toolConfig = {
          function_calling_config: { mode: "ANY" }
        };
      } else {
        const allowedFunctionNames = req.functionCall.function?.name ? {
          allowedFunctionNames: [req.functionCall.function.name]
        } : {};
        toolConfig = {
          function_calling_config: { mode: "ANY" },
          ...allowedFunctionNames
        };
      }
    } else if (tools && tools.length > 0) {
      toolConfig = { function_calling_config: { mode: "AUTO" } };
    }
    const generationConfig = {
      maxOutputTokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,
      temperature: req.modelConfig?.temperature ?? this.config.temperature,
      topP: req.modelConfig?.topP ?? this.config.topP,
      topK: req.modelConfig?.topK ?? this.config.topK,
      candidateCount: 1,
      stopSequences: req.modelConfig?.stopSequences ?? this.config.stopSequences
    };
    const safetySettings2 = this.config.safetySettings;
    const reqValue = {
      contents,
      tools,
      toolConfig,
      systemInstruction,
      generationConfig,
      safetySettings: safetySettings2
    };
    return [apiConfig, reqValue];
  };
  createEmbedReq = (req) => {
    const model = req.embedModel;
    if (!model) {
      throw new Error("Embed model not set");
    }
    if (!req.texts || req.texts.length === 0) {
      throw new Error("Embed texts is empty");
    }
    const apiConfig = {
      name: `/models/${model}:batchEmbedContents?key=${this.apiKey}`
    };
    const reqValue = {
      requests: req.texts.map((text) => ({
        model: "models/" + model,
        content: { parts: [{ text }] }
      }))
    };
    return [apiConfig, reqValue];
  };
  createChatResp = (resp) => {
    const results = resp.candidates?.map(
      (candidate) => {
        const result = {};
        switch (candidate.finishReason) {
          case "MAX_TOKENS":
            result.finishReason = "length";
            break;
          case "STOP":
            result.finishReason = "stop";
            break;
          case "SAFETY":
            throw new Error("Finish reason: SAFETY");
          case "RECITATION":
            throw new Error("Finish reason: RECITATION");
          case "MALFORMED_FUNCTION_CALL":
            throw new Error("Finish reason: MALFORMED_FUNCTION_CALL");
        }
        if (!candidate.content || !candidate.content.parts) {
          return result;
        }
        for (const part of candidate.content.parts) {
          if ("text" in part) {
            result.content = part.text;
            continue;
          }
          if ("functionCall" in part) {
            result.functionCalls = [
              {
                id: part.functionCall.name,
                type: "function",
                function: {
                  name: part.functionCall.name,
                  params: part.functionCall.args
                }
              }
            ];
          }
        }
        return result;
      }
    );
    let modelUsage;
    if (resp.usageMetadata) {
      modelUsage = {
        totalTokens: resp.usageMetadata.totalTokenCount,
        promptTokens: resp.usageMetadata.promptTokenCount,
        completionTokens: resp.usageMetadata.candidatesTokenCount
      };
    }
    return {
      results,
      modelUsage
    };
  };
  createChatStreamResp = (resp) => {
    return this.createChatResp(resp);
  };
  createEmbedResp = (resp) => {
    const embeddings = resp.embeddings.map((embedding) => embedding.values);
    return {
      embeddings
    };
  };
};
var AxAIGoogleGemini = class extends AxBaseAI {
  constructor({
    apiKey,
    projectId,
    region,
    config,
    options,
    modelMap
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("GoogleGemini AI API key not set");
    }
    const isVertex = projectId !== void 0 && region !== void 0;
    let apiURL;
    let headers;
    if (isVertex) {
      apiURL = `https://${region}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${region}/publishers/google/`;
      headers = { Authorization: `Bearer ${apiKey}` };
    } else {
      apiURL = "https://generativelanguage.googleapis.com/v1beta";
      headers = {};
    }
    const _config = {
      ...axAIGoogleGeminiDefaultConfig(),
      ...config
    };
    const aiImpl = new AxAIGoogleGeminiImpl(_config, apiKey, isVertex, options);
    super(aiImpl, {
      name: "GoogleGeminiAI",
      apiURL,
      headers,
      modelInfo: axModelInfoGoogleGemini,
      models: {
        model: _config.model,
        embedModel: _config.embedModel
      },
      options,
      supportFor: { functions: true, streaming: true },
      modelMap
    });
  }
};

// util/rate-limit.ts
var colorLog2 = new ColorLog();
var AxRateLimiterTokenUsage = class {
  options;
  maxTokens;
  refillRate;
  currentTokens;
  lastRefillTime;
  constructor(maxTokens, refillRate, options) {
    this.maxTokens = maxTokens;
    this.refillRate = refillRate;
    this.currentTokens = maxTokens;
    this.lastRefillTime = Date.now();
    this.options = options;
  }
  refillTokens() {
    const now = Date.now();
    const timeElapsed = (now - this.lastRefillTime) / 1e3;
    const tokensToAdd = timeElapsed * this.refillRate;
    this.currentTokens = Math.min(
      this.maxTokens,
      this.currentTokens + tokensToAdd
    );
    this.lastRefillTime = now;
  }
  async waitUntilTokensAvailable(tokens) {
    this.refillTokens();
    if (this.currentTokens >= tokens) {
      this.currentTokens -= tokens;
      return;
    }
    if (this.options?.debug) {
      console.log(
        colorLog2.red(
          `Rate limiter: Waiting for ${tokens - this.currentTokens} tokens`
        )
      );
    }
    await new Promise((resolve) => setTimeout(resolve, 100));
    return this.waitUntilTokensAvailable(tokens);
  }
  async acquire(tokens) {
    await this.waitUntilTokensAvailable(tokens);
  }
};

// ai/groq/types.ts
var AxAIGroqModel = /* @__PURE__ */ ((AxAIGroqModel2) => {
  AxAIGroqModel2["Llama3_8B"] = "llama3-8b-8192";
  AxAIGroqModel2["Llama3_70B"] = "llama3-70b-8192";
  AxAIGroqModel2["Mixtral_8x7B"] = "mixtral-8x7b-32768";
  AxAIGroqModel2["Gemma_7B"] = "gemma-7b-it";
  return AxAIGroqModel2;
})(AxAIGroqModel || {});

// ai/groq/info.ts
var axModelInfoGroq = [
  {
    name: "gemma-7b-it" /* Gemma_7B */,
    currency: "usd",
    characterIsToken: true,
    promptTokenCostPer1M: 0.2,
    completionTokenCostPer1M: 0.2
  },
  {
    name: "llama3-70b-8192" /* Llama3_70B */,
    currency: "usd",
    characterIsToken: true,
    promptTokenCostPer1M: 0.59,
    completionTokenCostPer1M: 0.79
  },
  {
    name: "llama3-8b-8192" /* Llama3_8B */,
    currency: "usd",
    characterIsToken: true,
    promptTokenCostPer1M: 0.05,
    completionTokenCostPer1M: 0.08
  },
  {
    name: "mixtral-8x7b-32768" /* Mixtral_8x7B */,
    currency: "usd",
    characterIsToken: true,
    promptTokenCostPer1M: 0.24,
    completionTokenCostPer1M: 0.24
  }
];

// ai/groq/api.ts
var axAIGroqDefaultConfig = () => structuredClone({
  model: "llama3-70b-8192" /* Llama3_70B */,
  ...axBaseAIDefaultConfig()
});
var AxAIGroq = class extends AxAIOpenAI {
  constructor({
    apiKey,
    config,
    options,
    modelMap
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("Groq API key not set");
    }
    const _config = {
      ...axAIGroqDefaultConfig(),
      ...config
    };
    const _options = {
      ...options,
      streamingUsage: false
    };
    super({
      apiKey,
      config: _config,
      options: _options,
      modelInfo: axModelInfoGroq,
      apiURL: "https://api.groq.com/openai/v1",
      modelMap
    });
    super.setName("Groq");
    this.setOptions(_options);
  }
  setOptions = (options) => {
    const rateLimiter = this.newRateLimiter(options);
    super.setOptions({ ...options, rateLimiter });
  };
  newRateLimiter = (options) => {
    if (options?.rateLimiter) {
      return options.rateLimiter;
    }
    const tokensPerMin = options?.tokensPerMinute ?? 4800;
    const rt = new AxRateLimiterTokenUsage(tokensPerMin, tokensPerMin / 60, {
      debug: options?.debug
    });
    const rtFunc = async (func, info) => {
      const totalTokens = info.modelUsage?.totalTokens || 0;
      await rt.acquire(totalTokens);
      return await func();
    };
    return rtFunc;
  };
};

// ai/huggingface/info.ts
var axModelInfoHuggingFace = [];

// ai/huggingface/types.ts
var AxAIHuggingFaceModel = /* @__PURE__ */ ((AxAIHuggingFaceModel2) => {
  AxAIHuggingFaceModel2["MetaLlama270BChatHF"] = "meta-llama/Llama-2-70b-chat-hf";
  return AxAIHuggingFaceModel2;
})(AxAIHuggingFaceModel || {});

// ai/huggingface/api.ts
var axAIHuggingFaceDefaultConfig = () => structuredClone({
  model: "meta-llama/Llama-2-70b-chat-hf" /* MetaLlama270BChatHF */,
  ...axBaseAIDefaultConfig()
});
var AxAIHuggingFaceImpl = class {
  constructor(config) {
    this.config = config;
  }
  getModelConfig() {
    const { config } = this;
    return {
      maxTokens: config.maxTokens,
      temperature: config.temperature,
      topP: config.topP,
      topK: config.topK,
      n: config.n,
      presencePenalty: config.presencePenalty
    };
  }
  createChatReq = (req, _config) => {
    const model = req.model;
    const functionsList = req.functions ? `Functions:
${JSON.stringify(req.functions, null, 2)}
` : "";
    const prompt = req.chatPrompt?.map((msg) => {
      switch (msg.role) {
        case "user":
          return `User: ${msg.content}`;
        case "system":
          return `System: ${msg.content}`;
        case "function":
          return `Function Result: ${msg.result}`;
        case "assistant": {
          const fc = msg.functionCalls?.map((fc2) => {
            const args = typeof fc2.function.params === "string" ? fc2.function.params : JSON.stringify(fc2.function.params);
            return `${fc2.function.name}(${args})`;
          }).join("\n");
          if (fc) {
            return `Assistant: ${msg.content}
 Functions:
${fc}`;
          }
          return `Assistant: ${msg.content}`;
        }
        default:
          throw new Error(`Unknown role`);
      }
    }).join("\n");
    const inputs = `${functionsList} ${prompt}`.trim();
    const apiConfig = {
      name: "/models"
    };
    const reqValue = {
      model,
      inputs,
      parameters: {
        max_new_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,
        repetition_penalty: req.modelConfig?.presencePenalty ?? this.config.presencePenalty,
        temperature: req.modelConfig?.temperature ?? this.config.temperature,
        top_p: req.modelConfig?.topP ?? this.config.topP,
        top_k: req.modelConfig?.topK ?? this.config.topK,
        return_full_text: this.config.returnFullText,
        num_return_sequences: this.config.n,
        do_sample: this.config.doSample,
        max_time: this.config.maxTime
      },
      options: {
        use_cache: this.config.useCache,
        wait_for_model: this.config.waitForModel
      }
    };
    return [apiConfig, reqValue];
  };
  createChatResp = (resp) => {
    return {
      results: [
        {
          content: resp.generated_text
        }
      ]
    };
  };
};
var AxAIHuggingFace = class extends AxBaseAI {
  constructor({
    apiKey,
    config,
    options,
    modelMap
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("HuggingFace API key not set");
    }
    const _config = {
      ...axAIHuggingFaceDefaultConfig(),
      ...config
    };
    const aiImpl = new AxAIHuggingFaceImpl(_config);
    super(aiImpl, {
      name: "HuggingFace",
      apiURL: "https://api-inference.huggingface.co",
      headers: { Authorization: `Bearer ${apiKey}` },
      modelInfo: axModelInfoHuggingFace,
      models: { model: _config.model },
      options,
      supportFor: { functions: false, streaming: false },
      modelMap
    });
  }
};

// ai/mistral/types.ts
var AxAIMistralModel = /* @__PURE__ */ ((AxAIMistralModel2) => {
  AxAIMistralModel2["Mistral7B"] = "open-mistral-7b";
  AxAIMistralModel2["Mistral8x7B"] = "open-mixtral-8x7b";
  AxAIMistralModel2["MistralSmall"] = "mistral-small-latest";
  AxAIMistralModel2["MistralNemo"] = "mistral-nemo-latest";
  AxAIMistralModel2["MistralLarge"] = "mistral-large-latest";
  AxAIMistralModel2["Codestral"] = "codestral-latest";
  AxAIMistralModel2["OpenCodestralMamba"] = "open-codestral-mamba";
  AxAIMistralModel2["OpenMistralNemo"] = "open-mistral-nemo-latest";
  return AxAIMistralModel2;
})(AxAIMistralModel || {});
var AxAIMistralEmbedModels = /* @__PURE__ */ ((AxAIMistralEmbedModels3) => {
  AxAIMistralEmbedModels3["MistralEmbed"] = "mistral-embed";
  return AxAIMistralEmbedModels3;
})(AxAIMistralEmbedModels || {});

// ai/mistral/info.ts
var axModelInfoMistral = [
  {
    name: "open-mistral-7b" /* Mistral7B */,
    currency: "USD",
    promptTokenCostPer1M: 0.25,
    completionTokenCostPer1M: 0.25
  },
  {
    name: "open-mixtral-8x7b" /* Mistral8x7B */,
    currency: "USD",
    promptTokenCostPer1M: 0.7,
    completionTokenCostPer1M: 0.7
  },
  {
    name: "mistral-nemo-latest" /* MistralNemo */,
    currency: "USD",
    promptTokenCostPer1M: 0.15,
    completionTokenCostPer1M: 0.15
  },
  {
    name: "mistral-small-latest" /* MistralSmall */,
    currency: "USD",
    promptTokenCostPer1M: 0.2,
    completionTokenCostPer1M: 0.6
  },
  {
    name: "mistral-large-latest" /* MistralLarge */,
    currency: "USD",
    promptTokenCostPer1M: 2,
    completionTokenCostPer1M: 6
  },
  {
    name: "codestral-latest" /* Codestral */,
    currency: "USD",
    promptTokenCostPer1M: 0.2,
    completionTokenCostPer1M: 0.6
  },
  {
    name: "open-codestral-mamba" /* OpenCodestralMamba */,
    currency: "USD",
    promptTokenCostPer1M: 0.25,
    completionTokenCostPer1M: 0.25
  },
  {
    name: "open-mistral-nemo-latest" /* OpenMistralNemo */,
    currency: "USD",
    promptTokenCostPer1M: 0.3,
    completionTokenCostPer1M: 0.3
  }
];

// ai/mistral/api.ts
var axAIMistralDefaultConfig = () => structuredClone({
  model: "mistral-small-latest" /* MistralSmall */,
  ...axBaseAIDefaultConfig()
});
var AxAIMistral = class extends AxAIOpenAI {
  constructor({
    apiKey,
    config,
    options,
    modelMap
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("Mistral API key not set");
    }
    const _config = {
      ...axAIMistralDefaultConfig(),
      ...config
    };
    super({
      apiKey,
      config: _config,
      options,
      apiURL: "https://api.mistral.ai/v1",
      modelInfo: axModelInfoMistral,
      modelMap
    });
    super.setName("Mistral");
  }
};

// ai/ollama/api.ts
var axAIOllamaDefaultConfig = () => structuredClone({
  ...axBaseAIDefaultConfig(),
  model: "nous-hermes2",
  embedModel: "all-minilm"
});
var AxAIOllama = class extends AxAIOpenAI {
  constructor({
    apiKey = "not-set",
    url = "http://localhost:11434/v1",
    config,
    options,
    modelMap
  }) {
    const _config = {
      ...axAIOllamaDefaultConfig(),
      ...config
    };
    super({
      apiKey,
      options,
      config: _config,
      apiURL: url,
      modelMap
    });
    super.setName("Ollama");
  }
};

// ai/reka/types.ts
var AxAIRekaModel = /* @__PURE__ */ ((AxAIRekaModel2) => {
  AxAIRekaModel2["RekaCore"] = "reka-core";
  AxAIRekaModel2["RekaFlash"] = "reka-flash";
  AxAIRekaModel2["RekaEdge"] = "reka-edge";
  return AxAIRekaModel2;
})(AxAIRekaModel || {});

// ai/reka/info.ts
var axModelInfoReka = [
  {
    name: "reka-core" /* RekaCore */,
    currency: "usd",
    promptTokenCostPer1M: 3,
    completionTokenCostPer1M: 15
  },
  {
    name: "reka-flash" /* RekaFlash */,
    currency: "usd",
    promptTokenCostPer1M: 0.8,
    completionTokenCostPer1M: 2
  },
  {
    name: "reka-edge" /* RekaEdge */,
    currency: "usd",
    promptTokenCostPer1M: 0.4,
    completionTokenCostPer1M: 1
  }
];

// ai/reka/api.ts
var axAIRekaDefaultConfig = () => structuredClone({
  model: "reka-core" /* RekaCore */,
  ...axBaseAIDefaultConfig()
});
var AxAIRekaImpl = class {
  constructor(config) {
    this.config = config;
  }
  getModelConfig() {
    const { config } = this;
    return {
      maxTokens: config.maxTokens,
      temperature: config.temperature,
      presencePenalty: config.presencePenalty,
      frequencyPenalty: config.frequencyPenalty,
      stopSequences: config.stopSequences,
      topP: config.topP,
      n: config.n,
      stream: config.stream
    };
  }
  createChatReq = (req, _config) => {
    const model = req.model;
    if (!req.chatPrompt || req.chatPrompt.length === 0) {
      throw new Error("Chat prompt is empty");
    }
    const apiConfig = {
      name: "/chat/completions"
    };
    const messages = createMessages3(req);
    const frequencyPenalty = req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty;
    const stream = req.modelConfig?.stream ?? this.config.stream;
    const reqValue = {
      model,
      messages,
      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens ?? 500,
      temperature: req.modelConfig?.temperature ?? this.config.temperature,
      top_k: req.modelConfig?.n ?? this.config.n,
      top_p: req.modelConfig?.topP ?? this.config.topP ?? 1,
      stop: req.modelConfig?.stopSequences ?? this.config.stop,
      presence_penalty: req.modelConfig?.presencePenalty ?? this.config.presencePenalty,
      ...frequencyPenalty ? { frequency_penalty: frequencyPenalty } : {},
      ...stream ? { stream: true } : {}
    };
    return [apiConfig, reqValue];
  };
  createChatResp = (resp) => {
    const { id, usage, responses } = resp;
    const modelUsage = usage ? {
      promptTokens: usage.input_tokens,
      completionTokens: usage.output_tokens,
      totalTokens: usage.input_tokens + usage.output_tokens
    } : void 0;
    const results = responses.map((res) => {
      const finishReason = mapFinishReason3(res.finish_reason);
      let content;
      if (typeof res.message.content === "string") {
        content = res.message.content;
      } else {
        content = res.message.content.text;
      }
      return {
        id: `${id}`,
        content,
        finishReason
      };
    });
    return {
      modelUsage,
      results,
      remoteId: id
    };
  };
  createChatStreamResp = (resp) => {
    const { id, usage, responses } = resp;
    const modelUsage = usage ? {
      promptTokens: usage.input_tokens,
      completionTokens: usage.output_tokens,
      totalTokens: usage.input_tokens + usage.output_tokens
    } : void 0;
    const results = responses.map((res) => {
      const finishReason = mapFinishReason3(res.finish_reason);
      let content;
      if (typeof res.chunk.content === "string") {
        content = res.chunk.content;
      } else {
        content = res.chunk.content.text;
      }
      return {
        id: `${id}`,
        content,
        finishReason
      };
    });
    return {
      results,
      modelUsage
    };
  };
};
var mapFinishReason3 = (finishReason) => {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "context":
      return "length";
    case "length":
      return "length";
  }
};
function createMessages3(req) {
  return req.chatPrompt.map((msg) => {
    switch (msg.role) {
      case "system":
        return { role: "user", content: msg.content };
      case "user":
        if (Array.isArray(msg.content)) {
          return {
            role: "user",
            content: msg.content.map((c) => {
              switch (c.type) {
                case "text":
                  return { type: "text", text: c.text };
                case "image": {
                  throw new Error("Image type not supported");
                }
                default:
                  throw new Error("Invalid content type");
              }
            })
          };
        }
        return { role: "user", content: msg.content };
      case "assistant":
        if (Array.isArray(msg.content)) {
          return {
            role: "assistant",
            content: msg.content.map((c) => {
              switch (c.type) {
                case "text":
                  return { type: "text", text: c.text };
                case "image": {
                  throw new Error("Image type not supported");
                }
                default:
                  throw new Error("Invalid content type");
              }
            })
          };
        }
        if (!msg.content) {
          throw new Error("Assistant content is empty");
        }
        return { role: "user", content: msg.content };
      default:
        throw new Error("Invalid role");
    }
  });
}
var AxAIReka = class extends AxBaseAI {
  constructor({
    apiKey,
    config,
    options,
    apiURL,
    modelInfo = axModelInfoReka,
    modelMap
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("Reka API key not set");
    }
    const _config = {
      ...axAIRekaDefaultConfig(),
      ...config
    };
    const aiImpl = new AxAIRekaImpl(_config);
    super(aiImpl, {
      name: "Reka",
      apiURL: apiURL ? apiURL : "https://api.reka.ai/v1/chat",
      headers: { "X-Api-Key": apiKey },
      modelInfo,
      models: {
        model: _config.model
      },
      options,
      supportFor: { functions: true, streaming: true },
      modelMap
    });
  }
};

// ai/together/info.ts
var axModelInfoTogether = [];

// ai/together/api.ts
var axAITogetherDefaultConfig = () => structuredClone({
  // cspell:disable-next-line
  model: "mistralai/Mixtral-8x7B-Instruct-v0.1",
  ...axBaseAIDefaultConfig()
});
var AxAITogether = class extends AxAIOpenAI {
  constructor({
    apiKey,
    config,
    options,
    modelMap
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("Together API key not set");
    }
    const _config = {
      ...axAITogetherDefaultConfig(),
      ...config
    };
    super({
      apiKey,
      config: _config,
      options,
      apiURL: "https://api.together.xyz/v1",
      modelInfo: axModelInfoTogether,
      modelMap
    });
    super.setName("Together");
  }
};

// ai/wrap.ts
var AxAI = class {
  ai;
  constructor(options) {
    switch (options.name) {
      case "openai":
        this.ai = new AxAIOpenAI(options);
        break;
      case "azure-openai":
        this.ai = new AxAIAzureOpenAI(options);
        break;
      case "huggingface":
        this.ai = new AxAIHuggingFace(options);
        break;
      case "groq":
        this.ai = new AxAIGroq(options);
        break;
      case "together":
        this.ai = new AxAITogether(options);
        break;
      case "cohere":
        this.ai = new AxAICohere(options);
        break;
      case "google-gemini":
        this.ai = new AxAIGoogleGemini(options);
        break;
      case "anthropic":
        this.ai = new AxAIAnthropic(options);
        break;
      case "mistral":
        this.ai = new AxAIMistral(options);
        break;
      case "deepseek":
        this.ai = new AxAIDeepSeek(options);
        break;
      case "ollama":
        this.ai = new AxAIOllama(options);
        break;
      case "reka":
        this.ai = new AxAIReka(options);
        break;
      default:
        throw new Error(`Unknown AI`);
    }
  }
  getName() {
    return this.ai.getName();
  }
  getModelInfo() {
    return this.ai.getModelInfo();
  }
  getEmbedModelInfo() {
    return this.ai.getEmbedModelInfo();
  }
  getFeatures(model) {
    return this.ai.getFeatures(model);
  }
  getModelMap() {
    return this.ai.getModelMap();
  }
  getMetrics() {
    return this.ai.getMetrics();
  }
  async chat(req, options) {
    return await this.ai.chat(req, options);
  }
  async embed(req, options) {
    return await this.ai.embed(req, options);
  }
  setOptions(options) {
    this.ai.setOptions(options);
  }
};

// prompts/agent.ts
import { SpanKind as SpanKind3 } from "@opentelemetry/api";

// dsp/generate.ts
import { ReadableStream } from "stream/web";
import { SpanKind as SpanKind2 } from "@opentelemetry/api";

// ai/util.ts
function mergeFunctionCalls(functionCalls, functionCallDeltas) {
  for (const _fc of functionCallDeltas) {
    const fc = functionCalls.find((fc2) => fc2.id === _fc.id);
    if (fc) {
      if (typeof _fc.function.name == "string" && _fc.function.name.length > 0) {
        fc.function.name += _fc.function.name;
      }
      if (typeof _fc.function.params == "string" && _fc.function.params.length > 0) {
        fc.function.params += _fc.function.params;
      }
      if (typeof _fc.function.params == "object") {
        fc.function.params = _fc.function.params;
      }
    } else {
      functionCalls.push(_fc);
    }
  }
}

// mem/memory.ts
var AxMemory = class {
  data = [];
  sdata = /* @__PURE__ */ new Map();
  limit;
  constructor(limit = 50) {
    if (limit <= 0) {
      throw Error("argument 'limit' must be greater than 0");
    }
    this.limit = limit;
  }
  add(value, sessionId) {
    const d = this.get(sessionId);
    let n = 0;
    if (Array.isArray(value)) {
      n = d.push(...structuredClone(value));
    } else {
      n = d.push({
        ...structuredClone(value)
      });
    }
    if (d.length > this.limit) {
      d.splice(0, this.limit + n - this.limit);
    }
  }
  addResult({ content, name, functionCalls }, sessionId) {
    if (!content && (!functionCalls || functionCalls.length === 0)) {
      return;
    }
    this.add({ content, name, role: "assistant", functionCalls }, sessionId);
  }
  updateResult({ content, name, functionCalls }, sessionId) {
    const items = this.get(sessionId);
    const lastItem = items.at(-1);
    if (!lastItem || lastItem.role !== "assistant") {
      this.addResult({ content, name, functionCalls }, sessionId);
      return;
    }
    if ("content" in lastItem && content) {
      lastItem.content = content;
    }
    if ("name" in lastItem && name) {
      lastItem.name = name;
    }
    if ("functionCalls" in lastItem && functionCalls) {
      lastItem.functionCalls = functionCalls;
    }
  }
  history(sessionId) {
    return this.get(sessionId);
  }
  getLast(sessionId) {
    const d = this.get(sessionId);
    return d.at(-1);
  }
  reset(sessionId) {
    if (!sessionId) {
      this.data = [];
    } else {
      this.sdata.set(sessionId, []);
    }
  }
  get(sessionId) {
    if (!sessionId) {
      return this.data;
    }
    if (!this.sdata.has(sessionId)) {
      this.sdata.set(sessionId, []);
    }
    return this.sdata.get(sessionId) || [];
  }
};

// dsp/asserts.ts
var AxAssertionError = class extends Error {
  values;
  optional;
  constructor({
    message,
    values,
    optional
  }) {
    super(message);
    this.values = values;
    this.optional = optional;
    this.name = this.constructor.name;
    this.stack = new Error().stack;
  }
  getValue = () => this.values;
  getOptional = () => this.optional;
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getFixingInstructions = (_sig) => {
    const extraFields = [];
    extraFields.push({
      name: "instructions",
      title: "Instructions",
      description: this.message
    });
    return extraFields;
  };
};
var assertAssertions = (asserts, values) => {
  for (const assert of asserts) {
    const { fn, message, optional } = assert;
    try {
      const res = fn(values);
      if (res === void 0) {
        continue;
      }
      if (!res && message) {
        throw new AxAssertionError({ message, values, optional });
      }
    } catch (e) {
      const message2 = e.message;
      throw new AxAssertionError({ message: message2, values, optional });
    }
  }
};
var assertStreamingAssertions = (asserts, values, xstate, content, final) => {
  if (!xstate.currField || xstate.s === -1 || !asserts || asserts.length === 0) {
    return;
  }
  const fieldAsserts = asserts.filter(
    (a) => a.fieldName === xstate.currField?.name
  );
  if (fieldAsserts.length === 0) {
    return;
  }
  const currValue = content.substring(xstate.s);
  for (const assert of fieldAsserts) {
    const { message, optional, fn } = assert;
    try {
      const res = fn(currValue, final);
      if (res === void 0) {
        continue;
      }
      if (!res && message) {
        throw new AxAssertionError({ message, values, optional });
      }
    } catch (e) {
      const message2 = e.message;
      throw new AxAssertionError({ message: message2, values, optional });
    }
  }
};
var assertRequiredFields = (sig, values) => {
  const fields = sig.getOutputFields();
  const missingFields = fields.filter(
    (f) => !f.isOptional && !(f.name in values)
  );
  if (missingFields.length > 0) {
    throw new AxAssertionError({
      message: `Output must include: ${missingFields.map((f) => `\`${f.title}:\``).join(", ")}`,
      values
    });
  }
};

// dsp/extract.ts
import JSON5 from "json5";

// dsp/datetime.ts
import moment from "moment-timezone";

// dsp/program.ts
import "@opentelemetry/api";

// dsp/registry.ts
var AxInstanceRegistry = class {
  reg;
  // To track keys for iteration
  constructor() {
    this.reg = /* @__PURE__ */ new Set();
  }
  register(instance) {
    this.reg.add(instance);
  }
  *[Symbol.iterator]() {
    for (const key of this.reg) {
      yield key;
    }
  }
};

// dsp/sig.ts
import { createHash } from "crypto";

// dsp/parser.ts
var SignatureParser = class {
  input;
  position;
  constructor(input) {
    this.input = input;
    this.position = 0;
  }
  parse() {
    this.skipWhitespace();
    const optionalDesc = this.parseParsedString();
    this.skipWhitespace();
    const inputs = this.parseInputParsedFieldList();
    this.skipWhitespace();
    this.expect("->");
    this.skipWhitespace();
    const outputs = this.parseOutputParsedFieldList();
    return {
      desc: optionalDesc?.trim(),
      inputs,
      outputs
    };
  }
  parseInputParsedFieldList() {
    const fields = [];
    fields.push(this.parseInputParsedField());
    while (this.match(",")) {
      this.skipWhitespace();
      fields.push(this.parseInputParsedField());
    }
    return fields;
  }
  parseOutputParsedFieldList() {
    const fields = [];
    fields.push(this.parseOutputParsedField());
    while (this.match(",")) {
      this.skipWhitespace();
      fields.push(this.parseOutputParsedField());
    }
    return fields;
  }
  parseInputParsedField() {
    this.skipWhitespace();
    const name = this.parseParsedIdentifier();
    const isOptional = this.match("?");
    let type;
    if (this.match(":")) {
      this.skipWhitespace();
      const typeName = this.parseTypeNotClass();
      const isArray = this.match("[]");
      type = { name: typeName, isArray };
    }
    this.skipWhitespace();
    const desc = this.parseParsedString();
    return {
      name,
      desc: desc?.trim(),
      type,
      isOptional
    };
  }
  parseOutputParsedField() {
    this.skipWhitespace();
    const name = this.parseParsedIdentifier();
    const isOptional = this.match("?");
    this.skipWhitespace();
    if (this.match(":")) {
      this.skipWhitespace();
      if (this.match("class")) {
        const isArray = this.match("[]");
        this.skipWhitespace();
        const desc = this.parseParsedString();
        if (!desc) {
          throw new Error(
            "Expected description containing class names after type 'class'"
          );
        }
        const classNames = desc.split(",").map((s) => s.trim());
        return {
          name,
          type: { name: "class", isArray, classes: classNames },
          isOptional
        };
      } else {
        const typeName = this.parseTypeNotClass();
        const isArray = this.match("[]");
        this.skipWhitespace();
        const desc = this.parseParsedString();
        return {
          name,
          desc: desc?.trim(),
          type: { name: typeName, isArray },
          isOptional
        };
      }
    } else {
      this.skipWhitespace();
      const desc = this.parseParsedString();
      return {
        name,
        desc: desc?.trim(),
        type: void 0,
        isOptional
      };
    }
  }
  parseTypeNotClass() {
    const types = [
      "string",
      "number",
      "boolean",
      "json",
      "image",
      "audio",
      "datetime",
      "date"
    ];
    for (const type of types) {
      if (this.match(type)) {
        return type;
      }
    }
    throw new Error(`Expected one of ${types.join(", ")}`);
  }
  parseParsedIdentifier() {
    const match = /^[a-zA-Z_][a-zA-Z_0-9]*/.exec(
      this.input.slice(this.position)
    );
    if (match) {
      this.position += match[0].length;
      return match[0];
    }
    throw new Error("Expected identifier");
  }
  parseParsedString() {
    if (this.match("'")) {
      const endQuote = this.input.indexOf("'", this.position);
      if (endQuote === -1) throw new Error("Unterminated string");
      const content = this.input.slice(this.position, endQuote);
      this.position = endQuote + 1;
      return content;
    } else if (this.match('"')) {
      const endQuote = this.input.indexOf('"', this.position);
      if (endQuote === -1) throw new Error("Unterminated string");
      const content = this.input.slice(this.position, endQuote);
      this.position = endQuote + 1;
      return content;
    }
    return void 0;
  }
  skipWhitespace() {
    const match = /^[ \t\r\n]+/.exec(this.input.slice(this.position));
    if (match) {
      this.position += match[0].length;
    }
  }
  match(str) {
    if (this.input.startsWith(str, this.position)) {
      this.position += str.length;
      return true;
    }
    return false;
  }
  expect(str) {
    if (!this.match(str)) {
      throw new Error(`Expected "${str}"`);
    }
  }
};
function parseSignature(input) {
  const parser = new SignatureParser(input);
  return parser.parse();
}

// dsp/sig.ts
var AxSignature = class _AxSignature {
  description;
  inputFields;
  outputFields;
  sigHash;
  sigString;
  constructor(signature) {
    if (!signature) {
      this.inputFields = [];
      this.outputFields = [];
      this.sigHash = "";
      this.sigString = "";
      return;
    }
    if (typeof signature === "string") {
      let sig;
      try {
        sig = parseSignature(signature);
      } catch (e) {
        throw new Error(
          `Invalid Signature: ${e.message} (${signature})`
        );
      }
      this.description = sig.desc;
      this.inputFields = sig.inputs.map((v) => this.parseParsedField(v));
      this.outputFields = sig.outputs.map((v) => this.parseParsedField(v));
      [this.sigHash, this.sigString] = this.updateHash();
    } else if (signature instanceof _AxSignature) {
      this.description = signature.getDescription();
      this.inputFields = structuredClone(
        signature.getInputFields()
      );
      this.outputFields = structuredClone(
        signature.getOutputFields()
      );
      this.sigHash = signature.hash();
      this.sigString = signature.toString();
    } else {
      throw new Error("invalid signature argument: " + signature);
    }
  }
  parseParsedField = (field) => {
    if (!field.name || field.name.length === 0) {
      throw new Error("Field name is required.");
    }
    const title = this.toTitle(field.name);
    return {
      name: field.name,
      title,
      description: "desc" in field ? field.desc : void 0,
      isOptional: field.isOptional,
      type: field.type ?? { name: "string", isArray: false }
    };
  };
  parseField = (field) => {
    const title = !field.title || field.title.length === 0 ? this.toTitle(field.name) : field.title;
    if (field.type && (!field.type.name || field.type.name.length === 0)) {
      throw new Error("Field type name is required: " + field.name);
    }
    return { ...field, title };
  };
  setDescription = (desc) => {
    this.description = desc;
    this.updateHash();
  };
  addInputField = (field) => {
    this.inputFields.push(this.parseField(field));
    this.updateHash();
  };
  addOutputField = (field) => {
    this.outputFields.push(this.parseField(field));
    this.updateHash();
  };
  setInputFields = (fields) => {
    this.inputFields = fields.map((v) => this.parseField(v));
    this.updateHash();
  };
  setOutputFields = (fields) => {
    this.outputFields = fields.map((v) => this.parseField(v));
    this.updateHash();
  };
  getInputFields = () => this.inputFields;
  getOutputFields = () => this.outputFields;
  getDescription = () => this.description;
  toTitle = (name) => {
    let result = name.replaceAll("_", " ");
    result = result.replace(/([A-Z]|[0-9]+)/g, " $1").trim();
    return result.charAt(0).toUpperCase() + result.slice(1);
  };
  toJSONSchema = () => {
    const properties = {};
    const required = [];
    for (const f of this.inputFields) {
      const type = f.type ? f.type.name : "string";
      if (f.type?.isArray) {
        properties[f.name] = {
          description: f.description,
          type: "array",
          items: {
            type,
            description: f.description
          }
        };
      } else {
        properties[f.name] = {
          description: f.description,
          type
        };
      }
      if (!f.isOptional) {
        required.push(f.name);
      }
    }
    const schema = {
      type: "object",
      properties,
      required
    };
    return schema;
  };
  updateHash = () => {
    this.getInputFields().forEach((field) => {
      validateField(field);
    });
    this.getOutputFields().forEach((field) => {
      validateField(field);
      if (field.type?.name === "image") {
        throw new Error("Image type is not supported in output fields.");
      }
    });
    this.sigHash = createHash("sha256").update(this.description ?? "").update(JSON.stringify(this.inputFields)).update(JSON.stringify(this.outputFields)).digest("hex");
    this.sigString = renderSignature(
      this.description,
      this.inputFields,
      this.outputFields
    );
    return [this.sigHash, this.sigString];
  };
  hash = () => this.sigHash;
  toString = () => this.sigString;
};
function renderField(field) {
  let result = field.name;
  if (field.isOptional) {
    result += "?";
  }
  if (field.type) {
    result += ":" + field.type.name;
    if (field.type.isArray) {
      result += "[]";
    }
  }
  if (field.description) {
    result += ` "${field.description}"`;
  }
  return result;
}
function renderSignature(description, inputFields, outputFields) {
  const descriptionPart = description ? `"${description}"` : "";
  const inputFieldsRendered = inputFields.map(renderField).join(", ");
  const outputFieldsRendered = outputFields.map(renderField).join(", ");
  return `${descriptionPart} ${inputFieldsRendered} -> ${outputFieldsRendered}`;
}
function isValidCase(inputString) {
  const camelCaseRegex = /^[a-z][a-zA-Z0-9]*$/;
  const snakeCaseRegex = /^[a-z]+(_[a-z0-9]+)*$/;
  return camelCaseRegex.test(inputString) || snakeCaseRegex.test(inputString);
}
function validateField(field) {
  if (!field.name || field.name.length === 0) {
    throw new Error("Field name cannot be blank");
  }
  if (!isValidCase(field.name)) {
    throw new Error(
      `Invalid field name '${field.name}', it must be camel case or snake case: `
    );
  }
  if ([
    "text",
    "object",
    "image",
    "string",
    "number",
    "boolean",
    "json",
    "array",
    "datetime",
    "date",
    "time",
    "type",
    "class"
  ].includes(field.name)) {
    throw new Error(
      `Invalid field name '${field.name}', please make it more descriptive (eg. companyDescription)`
    );
  }
}

// dsp/util.ts
var colorLog3 = new ColorLog();
var updateProgressBar = (current, total, success, elapsedTime, progressBarWidth = 20, msg) => {
  const percentage = (current / total * 100).toFixed(1);
  const filledBarLength = Math.round(progressBarWidth * current / total);
  const emptyBarLength = progressBarWidth - filledBarLength;
  const filledBar = colorLog3.blueBright("\u2588".repeat(filledBarLength));
  const emptyBar = " ".repeat(emptyBarLength);
  const itemsPerSecond = elapsedTime > 0 ? (current / elapsedTime).toFixed(2) : "0.00";
  process.stdout.write(
    `\r${msg}: ${current} / ${total} (${colorLog3.yellow(percentage)}%): 100%|${filledBar}${emptyBar}| Success: ${success}/${total} [${colorLog3.red(elapsedTime.toFixed(2))}, ${itemsPerSecond}it/s]`
  );
};
var validateValue = (field, value) => {
  const ft = field.type ?? { name: "string", isArray: false };
  const validateSingleValue = (expectedType, val) => {
    switch (expectedType) {
      case "string":
        return typeof val === "string";
      case "number":
        return typeof val === "number";
      case "boolean":
        return typeof val === "boolean";
      case "date":
        return val instanceof Date || typeof val === "string";
      case "datetime":
        return val instanceof Date || typeof val === "string";
      default:
        return false;
    }
  };
  const validImage = (val) => {
    if (!val || typeof val !== "object" || !("mimeType" in val) || !("data" in val)) {
      return false;
    }
    return true;
  };
  if (field.type?.name === "image") {
    let msg;
    if (Array.isArray(value)) {
      for (const item of value) {
        if (!validImage(item)) {
          msg = "object ({ mimeType: string; data: string })";
          break;
        }
      }
    } else if (!validImage(value)) {
      msg = "object ({ mimeType: string; data: string })";
    }
    if (msg) {
      throw new Error(
        `Validation failed: Expected '${field.name}' to be a ${msg} instead got '${value}'`
      );
    }
    return;
  }
  const validAudio = (val) => {
    if (!val || typeof val !== "object" || !("data" in val)) {
      return false;
    }
    return true;
  };
  if (field.type?.name === "audio") {
    let msg;
    if (Array.isArray(value)) {
      for (const item of value) {
        if (!validAudio(item)) {
          msg = "object ({ data: string; format?: string })";
          break;
        }
      }
    } else if (!validAudio(value)) {
      msg = "object ({ data: string; format?: string })";
    }
    if (msg) {
      throw new Error(
        `Validation failed: Expected '${field.name}' to be a ${msg} instead got '${value}'`
      );
    }
    return;
  }
  let isValid = true;
  if (ft.isArray) {
    if (!Array.isArray(value)) {
      isValid = false;
    } else {
      for (const item of value) {
        if (!validateSingleValue(ft.name, item)) {
          isValid = false;
          break;
        }
      }
    }
  } else {
    isValid = validateSingleValue(ft.name, value);
  }
  if (!isValid) {
    throw new Error(
      `Validation failed: Expected '${field.name}' to be a ${field.type?.isArray ? "an array of " : ""}${ft.name} instead got '${typeof value}' (${value})`
    );
  }
};
function mergeProgramUsage(usages) {
  const usageMap = {};
  usages.forEach((usage) => {
    const key = `${usage.ai}:${usage.model}`;
    if (!usageMap[key]) {
      usageMap[key] = { ...usage };
      return;
    }
    usageMap[key].promptTokens += usage.promptTokens;
    usageMap[key].completionTokens += usage.completionTokens;
    usageMap[key].totalTokens += usage.totalTokens;
  });
  return Object.values(usageMap);
}
var parseMarkdownList = (input) => {
  if (!input.trim()) {
    return [];
  }
  const listBullets = /* @__PURE__ */ new Set(["-", "*", "+"]);
  const numberedListRegex = /^\d+[\s]*[.)\]]\s*/;
  const lines = input.split("\n");
  const list = [];
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine[0] && listBullets.has(trimmedLine[0])) {
      list.push(trimmedLine.slice(1).trim());
    } else if (numberedListRegex.test(trimmedLine)) {
      list.push(trimmedLine.replace(numberedListRegex, "").trim());
    } else if (list.length === 0) {
      continue;
    } else {
      throw new Error("Could not parse markdown list: mixed content detected");
    }
  }
  if (list.length === 0) {
    throw new Error("Could not parse markdown list: no valid list items found");
  }
  return list;
};

// dsp/program.ts
var AxProgramWithSignature = class {
  signature;
  sigHash;
  examples;
  demos;
  trace;
  usage = [];
  key;
  children;
  constructor(signature, options) {
    this.signature = new AxSignature(signature);
    this.sigHash = this.signature?.hash();
    this.children = new AxInstanceRegistry();
    this.key = { id: this.constructor.name };
    if (options?.description) {
      this.signature.setDescription(options.description);
    }
  }
  getSignature() {
    return this.signature;
  }
  register(prog) {
    if (this.key) {
      prog.setParentId(this.key.id);
    }
    this.children.register(prog);
  }
  async forward(_ai, _values, _options) {
    throw new Error("forward() not implemented");
  }
  setId(id) {
    this.key = { id, custom: true };
    for (const child of this.children) {
      child.setParentId(id);
    }
  }
  setParentId(parentId) {
    if (!this.key.custom) {
      this.key.id = [parentId, this.key.id].join("/");
    }
  }
  setExamples(examples) {
    this._setExamples(examples);
    if (!("programId" in examples)) {
      return;
    }
    for (const child of this.children) {
      child.setExamples(examples);
    }
  }
  _setExamples(examples) {
    let traces = [];
    if ("programId" in examples && examples.programId === this.key.id) {
      traces = examples.traces;
    }
    if (Array.isArray(examples)) {
      traces = examples;
    }
    if (traces) {
      const sig = this.signature;
      const fields = [...sig.getInputFields(), ...sig.getOutputFields()];
      this.examples = traces.map((e) => {
        const res = {};
        for (const f of fields) {
          const value = e[f.name];
          if (value) {
            validateValue(f, value);
            res[f.name] = value;
          }
        }
        return res;
      });
    }
  }
  getTraces() {
    let traces = [];
    if (this.trace) {
      traces.push({ trace: this.trace, programId: this.key.id });
    }
    for (const child of this.children) {
      const _traces = child.getTraces();
      traces = [...traces, ..._traces];
    }
    return traces;
  }
  getUsage() {
    let usage = [...this.usage ?? []];
    for (const child of this.children) {
      const cu = child.getUsage();
      usage = [...usage, ...cu];
    }
    return mergeProgramUsage(usage);
  }
  resetUsage() {
    this.usage = [];
    for (const child of this.children) {
      child.resetUsage();
    }
  }
  setDemos(demos) {
    this.demos = demos.filter((v) => v.programId === this.key.id).map((v) => v.traces).flat();
    for (const child of this.children) {
      child.setDemos(demos);
    }
  }
};
var AxProgram = class {
  trace;
  usage = [];
  key;
  children;
  constructor() {
    this.children = new AxInstanceRegistry();
    this.key = { id: this.constructor.name };
  }
  register(prog) {
    if (this.key) {
      prog.setParentId(this.key.id);
    }
    this.children.register(prog);
  }
  async forward(_ai, _values, _options) {
    throw new Error("forward() not implemented");
  }
  setId(id) {
    this.key = { id, custom: true };
    for (const child of this.children) {
      child.setParentId(id);
    }
  }
  setParentId(parentId) {
    if (!this.key.custom) {
      this.key.id = [parentId, this.key.id].join("/");
    }
  }
  setExamples(examples) {
    if (!("programId" in examples)) {
      return;
    }
    for (const child of this.children) {
      child.setExamples(examples);
    }
  }
  getTraces() {
    let traces = [];
    if (this.trace) {
      traces.push({ trace: this.trace, programId: this.key.id });
    }
    for (const child of this.children) {
      const _traces = child.getTraces();
      traces = [...traces, ..._traces];
    }
    return traces;
  }
  getUsage() {
    let usage = [...this.usage ?? []];
    for (const child of this.children) {
      const cu = child.getUsage();
      usage = [...usage, ...cu];
    }
    return mergeProgramUsage(usage);
  }
  resetUsage() {
    this.usage = [];
    for (const child of this.children) {
      child.resetUsage();
    }
  }
  setDemos(demos) {
    for (const child of this.children) {
      child.setDemos(demos);
    }
  }
};

// dsp/prompt.ts
var formattingRules = `
When providing responses:
1. Only output the exact requested content - no additional text, commentary, explanations, or clarifications
2. Each key's value must strictly adhere to the formatting rules specified in the reference documentation 
3. Follow all formatting conventions precisely as defined
4. Do not add any extra content beyond what is explicitly requested
5. Match the exact structure and format specifications for each field
6. No preamble, postscript, or supplementary information
7. Pure output only - conforming exactly to the documented requirements`;
var AxPromptTemplate = class {
  sig;
  fieldTemplates;
  task;
  constructor(sig, functions, fieldTemplates) {
    this.sig = sig;
    this.fieldTemplates = fieldTemplates;
    const inArgs = this.renderDescFields(this.sig.getInputFields());
    const outArgs = this.renderDescFields(this.sig.getOutputFields());
    const task = [
      `You will be provided with the following fields: ${inArgs}. Your task is to generate two new fields: ${outArgs}.`
    ];
    const funcs = functions?.map(
      (f) => "toFunction" in f ? f.toFunction() : f
    );
    const funcList = funcs?.map(
      (fn) => `- \`${fn.name}\`: ${capitalizeFirstLetter(fn.description)}`
    ).join("\n");
    if (funcList && funcList.length > 0) {
      task.push(`## Available Functions
${funcList}`);
      task.push(
        `Complete the task, using the functions defined earlier in this prompt, as needed. The output field values may be generated by applying these functions if appropriate for the task.`
      );
    }
    const inputFields = this.renderFields(this.sig.getInputFields());
    task.push(`## Input Fields
${inputFields}`);
    const outputFields = this.renderFields(this.sig.getOutputFields());
    task.push(`## Output Fields
${outputFields}`);
    task.push(
      "Output must be in plain text, with each `key: value` pair on a new line. The format of each `value` should strictly adhere to the formatting instructions for its corresponding `key`, as defined earlier in this prompt."
    );
    task.push(formattingRules);
    const desc = this.sig.getDescription();
    if (desc) {
      task.push(
        `## TASK DESCRIPTION
${capitalizeFirstLetter(desc.endsWith(".") ? desc : desc + ".")}`
      );
    }
    this.task = {
      type: "text",
      text: task.join("\n\n")
    };
  }
  render = (values, {
    examples,
    demos
  }) => {
    const renderedExamples = examples ? [
      { type: "text", text: "## Examples:\n" },
      ...this.renderExamples(examples)
    ] : [];
    const renderedDemos = demos ? this.renderDemos(demos) : [];
    const completion = this.renderInputFields(values);
    const allTextExamples = renderedExamples.every((v) => v.type === "text");
    const allTextDemos = renderedDemos.every((v) => v.type === "text");
    const examplesInSystemPrompt = allTextExamples && allTextDemos;
    let systemContent = this.task.text;
    if (examplesInSystemPrompt) {
      const combinedItems = [
        { type: "text", text: systemContent + "\n\n" },
        ...renderedExamples,
        ...renderedDemos
      ];
      combinedItems.reduce(combineConsecutiveStrings(""), []);
      if (combinedItems && combinedItems[0]) {
        systemContent = combinedItems[0].text;
      }
    }
    const systemPrompt = {
      role: "system",
      content: systemContent
    };
    const promptList = examplesInSystemPrompt ? completion : [...renderedExamples, ...renderedDemos, ...completion];
    const prompt = promptList.filter((v) => v !== void 0);
    const userContent = prompt.every((v) => v.type === "text") ? prompt.map((v) => v.text).join("\n") : prompt.reduce(combineConsecutiveStrings("\n"), []);
    const userPrompt = {
      role: "user",
      content: userContent
    };
    return [systemPrompt, userPrompt];
  };
  renderExtraFields = (extraFields) => {
    const prompt = [];
    if (extraFields && extraFields.length > 0) {
      extraFields.forEach((field) => {
        const fn = this.fieldTemplates?.[field.name] ?? this.defaultRenderInField;
        prompt.push(...fn(field, field.description));
      });
    }
    if (prompt.every((v) => v.type === "text")) {
      return prompt.map((v) => v.text).join("\n\n");
    }
    return prompt.reduce(combineConsecutiveStrings("\n"), []);
  };
  renderExamples = (data) => {
    const list = [];
    for (const [index, item] of data.entries()) {
      const renderedInputItem = this.sig.getInputFields().map((field) => this.renderInField(field, item, true)).filter((v) => v !== void 0).flat();
      const renderedOutputItem = this.sig.getOutputFields().map((field) => this.renderInField(field, item, true)).filter((v) => v !== void 0).flat();
      if (renderedOutputItem.length === 0) {
        throw new Error(
          `Output fields are required in examples: index: ${index}, data: ${JSON.stringify(item)}`
        );
      }
      const renderedItem = [...renderedInputItem, ...renderedOutputItem];
      renderedItem.forEach((v) => {
        if ("text" in v) {
          v.text = v.text + "\n";
        }
        if ("image" in v) {
          v.image = v.image;
        }
        list.push(v);
      });
    }
    return list;
  };
  renderDemos = (data) => {
    const list = [];
    const fields = [...this.sig.getInputFields(), ...this.sig.getOutputFields()];
    for (const item of data) {
      const renderedItem = fields.map((field) => this.renderInField(field, item, true)).filter((v) => v !== void 0).flat();
      renderedItem.slice(0, -1).forEach((v) => {
        if ("text" in v) {
          v.text = v.text + "\n";
        }
        if ("image" in v) {
          v.image = v.image;
        }
        list.push(v);
      });
    }
    return list;
  };
  renderInputFields = (values) => {
    const renderedItems = this.sig.getInputFields().map((field) => this.renderInField(field, values)).filter((v) => v !== void 0).flat();
    renderedItems.filter((v) => v.type === "text").forEach((v) => {
      v.text = v.text + "\n";
    });
    return renderedItems;
  };
  renderInField = (field, values, skipMissing) => {
    const value = values[field.name];
    if (skipMissing && !value) {
      return;
    }
    if (isEmptyValue(field, value)) {
      return;
    }
    if (field.type) {
      validateValue(field, value);
    }
    const processedValue = processValue(field, value);
    const textFieldFn = this.fieldTemplates?.[field.name] ?? this.defaultRenderInField;
    return textFieldFn(field, processedValue);
  };
  defaultRenderInField = (field, value) => {
    if (field.type?.name === "image") {
      const validateImage = (value2) => {
        if (!value2) {
          throw new Error("Image field value is required.");
        }
        if (typeof value2 !== "object") {
          throw new Error("Image field value must be an object.");
        }
        if (!("mimeType" in value2)) {
          throw new Error("Image field must have mimeType");
        }
        if (!("data" in value2)) {
          throw new Error("Image field must have data");
        }
        return value2;
      };
      let result = [
        { type: "text", text: `${field.title}: ` }
      ];
      if (field.type.isArray) {
        if (!Array.isArray(value)) {
          throw new Error("Image field value must be an array.");
        }
        result = result.concat(
          value.map((v) => {
            v = validateImage(v);
            return {
              type: "image",
              mimeType: v.mimeType,
              image: v.data
            };
          })
        );
      } else {
        const v = validateImage(value);
        result.push({
          type: "image",
          mimeType: v.mimeType,
          image: v.data
        });
      }
      return result;
    }
    if (field.type?.name === "audio") {
      const validateAudio = (value2) => {
        if (!value2) {
          throw new Error("Audio field value is required.");
        }
        if (typeof value2 !== "object") {
          throw new Error("Audio field value must be an object.");
        }
        if (!("data" in value2)) {
          throw new Error("Audio field must have data");
        }
        return value2;
      };
      let result = [
        { type: "text", text: `${field.title}: ` }
      ];
      if (field.type.isArray) {
        if (!Array.isArray(value)) {
          throw new Error("Image field value must be an array.");
        }
        result = result.concat(
          value.map((v) => {
            v = validateAudio(v);
            return {
              type: "audio",
              format: v.format ?? "wav",
              data: v.data
            };
          })
        );
      } else {
        const v = validateAudio(value);
        result.push({
          type: "audio",
          format: v.format ?? "wav",
          data: v.data
        });
      }
      return result;
    }
    const text = [field.title, ": "];
    if (Array.isArray(value)) {
      text.push("\n");
      text.push(value.map((v) => `- ${v}`).join("\n"));
    } else {
      text.push(value);
    }
    return [{ type: "text", text: text.join("") }];
  };
  renderDescFields = (list) => list.map((v) => `\`${v.title}\``).join(", ");
  renderFields = (fields) => {
    const rows = fields.map((field) => {
      const name = field.title;
      const type = field.type?.name ? toFieldType(field.type) : "string";
      const required = field.isOptional ? "optional" : "required";
      const description = field.description ? `: ${capitalizeFirstLetter(field.description)}` : "";
      return `- \`${name}\` (${type}, ${required})${description}`.trim();
    });
    return rows.join("\n");
  };
};
var processValue = (field, value) => {
  if (field.type?.name === "date" && value instanceof Date) {
    const v = value.toISOString();
    return v.slice(0, v.indexOf("T"));
  }
  if (field.type?.name === "datetime" && value instanceof Date) {
    return formatDateWithTimezone(value);
  }
  if (field.type?.name === "image" && typeof value === "object") {
    return value;
  }
  if (field.type?.name === "audio" && typeof value === "object") {
    return value;
  }
  if (typeof value === "string") {
    return value;
  }
  if (Array.isArray(value)) {
    return value;
  }
  return JSON.stringify(value);
};
var toFieldType = (type) => {
  const baseType = (() => {
    switch (type?.name) {
      case "string":
        return "string";
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "date":
        return 'date ("YYYY-MM-DD" format)';
      case "datetime":
        return 'date time ("YYYY-MM-DD HH:mm Timezone" format)';
      case "json":
        return "JSON object";
      case "class":
        return `classification class (allowed classes: ${type.classes?.join(", ")})`;
      default:
        return "string";
    }
  })();
  return type?.isArray ? `json array of ${baseType} items` : baseType;
};
function combineConsecutiveStrings(separator) {
  return (acc, current) => {
    if (current.type === "text") {
      const previous = acc.length > 0 ? acc[acc.length - 1] : null;
      if (previous && previous.type === "text") {
        previous.text += separator + current.text;
      } else {
        acc.push(current);
      }
    } else {
      acc.push(current);
    }
    return acc;
  };
}
var isEmptyValue = (field, value) => {
  if (typeof value === "boolean") {
    return false;
  }
  if (!value || (Array.isArray(value) || typeof value === "string") && value.length === 0) {
    if (field.isOptional) {
      return true;
    }
    throw new Error(`Value for input field '${field.name}' is required.`);
  }
  return false;
};
function capitalizeFirstLetter(str) {
  if (str.length === 0) {
    return "";
  }
  return `${str.charAt(0).toUpperCase()}${str.slice(1)}`;
}

// dsp/validate.ts
var AxValidationError = class extends Error {
  field;
  value;
  constructor({
    message,
    field,
    value
  }) {
    super(message);
    this.field = field;
    this.value = value;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
  getField = () => this.field;
  getValue = () => this.value;
  getFixingInstructions = () => {
    const f = this.field;
    const extraFields = [
      {
        name: `invalidField`,
        title: `Invalid Field`,
        description: `Ensure the field \`${f.title}\` is of type \`${toFieldType(f.type)}\``
      }
    ];
    return extraFields;
  };
};

// dsp/datetime.ts
function parseLLMFriendlyDate(field, dateStr) {
  try {
    return _parseLLMFriendlyDate(dateStr);
  } catch (err) {
    const message = err.message;
    throw new AxValidationError({ field, message, value: dateStr });
  }
}
function _parseLLMFriendlyDate(dateStr) {
  if (!moment(dateStr, "YYYY-MM-DD", true).isValid()) {
    throw new Error(
      'Invalid date format. Please provide the date in "YYYY-MM-DD" format.'
    );
  }
  const date = moment.utc(dateStr, "YYYY-MM-DD").startOf("day");
  return date.toDate();
}
function parseLLMFriendlyDateTime(field, dateStr) {
  try {
    return _parseLLMFriendlyDateTime(dateStr);
  } catch (err) {
    const message = err.message;
    throw new AxValidationError({ field, message, value: dateStr });
  }
}
function _parseLLMFriendlyDateTime(dateTimeStr) {
  const dateTimeRegex = /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}(?::\d{2})?) (.+)$/;
  const match = dateTimeStr.match(dateTimeRegex);
  if (!match) {
    throw new Error(
      'Invalid date and time format. Please provide the date and time in "YYYY-MM-DD HH:mm" or "YYYY-MM-DD HH:mm:ss" format, followed by the timezone.'
    );
  }
  const [, dateTime, timeZone] = match;
  if (!dateTime || !timeZone) {
    throw new Error(
      'Invalid date and time format. Please provide the date and time in "YYYY-MM-DD HH:mm" or "YYYY-MM-DD HH:mm:ss" format, followed by the timezone.'
    );
  }
  const zone = moment.tz.zone(timeZone);
  if (!zone) {
    throw new Error(
      `Unrecognized time zone ${timeZone}. Please provide a valid time zone name, abbreviation, or offset. For example, "America/New_York", or "EST".`
    );
  }
  const date = moment.tz(
    dateTime,
    ["YYYY-MM-DD HH:mm", "YYYY-MM-DD HH:mm:ss"],
    zone.name
  );
  if (!date.isValid()) {
    throw new Error(
      "Invalid date and time values. Please ensure all components are correct."
    );
  }
  return date.utc().toDate();
}
var formatDateWithTimezone = (date) => {
  const momentDate = moment(date).utc();
  return momentDate.format(`YYYY-MM-DD HH:mm:ss UTC`);
};

// dsp/extract.ts
var extractValues = (sig, values, content) => {
  const xstate = { s: -1 };
  streamingExtractValues(sig, values, xstate, content);
  streamingExtractFinalValue(values, xstate, content);
};
var streamingExtractValues = (sig, values, state, content) => {
  const fields = sig.getOutputFields();
  for (const field of fields) {
    if (field.name in values) {
      continue;
    }
    const prefix = field.title + ":";
    const e = content.indexOf(prefix, state.s + 1);
    if (e === -1) {
      continue;
    }
    if (state.currField) {
      const val = content.substring(state.s, e).trim().replace(/---+$/, "").trim();
      values[state.currField.name] = validateAndParseFieldValue(
        state.currField,
        val
      );
    }
    state.s = e + prefix.length;
    state.currField = field;
  }
};
var streamingExtractFinalValue = (values, state, content) => {
  if (!state.currField) {
    return;
  }
  const val = content.substring(state.s).trim().replace(/---+$/, "").trim();
  values[state.currField.name] = validateAndParseFieldValue(
    state.currField,
    val
  );
};
var convertValueToType = (field, val) => {
  switch (field.type?.name) {
    case "string":
      return val;
    case "number": {
      const v = Number(val);
      if (Number.isNaN(v)) {
        throw new Error("Invalid number");
      }
      return v;
    }
    case "boolean": {
      const v = val.toLowerCase();
      if (v === "true") {
        return true;
      } else if (v === "false") {
        return false;
      } else {
        throw new Error("Invalid boolean");
      }
    }
    case "date":
      return parseLLMFriendlyDate(field, val);
    case "datetime":
      return parseLLMFriendlyDateTime(field, val);
    case "class":
      if (field.type.classes && !field.type.classes.includes(val)) {
        throw new Error(
          `Invalid class '${val}', expected one of the following: ${field.type.classes.join(", ")}`
        );
      }
      return val;
    default:
      return val;
  }
};
var expectedTypeError = (field, err, value = "") => {
  const exp = field.type?.isArray ? `array of ${field.type.name}` : field.type?.name;
  const message = `Error '${err.message}', expected '${exp}' got '${value}'`;
  return new AxValidationError({ message, field, value });
};
function validateAndParseFieldValue(field, fieldValue) {
  const fv = fieldValue?.toLocaleLowerCase();
  if (!fieldValue || !fv || fv === "" || fv === "null" || fv === "undefined") {
    if (field.isOptional) {
      return;
    }
    throw expectedTypeError(field, new Error("Empty value"), fieldValue);
  }
  let value = fieldValue;
  if (field.type?.name === "json") {
    try {
      const text = extractBlock(fieldValue);
      value = JSON5.parse(text);
      return value;
    } catch (e) {
      throw expectedTypeError(field, e, fieldValue);
    }
  }
  if (field.type?.isArray) {
    try {
      try {
        value = JSON5.parse(fieldValue);
      } catch {
        value = parseMarkdownList(fieldValue);
      }
      if (!Array.isArray(value)) {
        throw new Error("Expected an array");
      }
    } catch (e) {
      throw expectedTypeError(field, e, fieldValue);
    }
  }
  if (Array.isArray(value)) {
    for (const [index, item] of value.entries()) {
      try {
        value[index] = convertValueToType(field, item);
      } catch (e) {
        throw expectedTypeError(field, e, item);
      }
    }
  } else {
    try {
      value = convertValueToType(field, fieldValue);
    } catch (e) {
      throw expectedTypeError(field, e, fieldValue);
    }
  }
  return value;
}
var extractBlock = (input) => {
  const jsonBlockPattern = /```([A-Za-z]+)?\s*([\s\S]*?)\s*```/g;
  const match = jsonBlockPattern.exec(input);
  if (!match) {
    return input;
  }
  if (match.length === 3) {
    return match[2];
  }
  if (match.length === 2) {
    return match[1];
  }
  return input;
};

// dsp/functions.ts
import JSON52 from "json5";

// dsp/jsonschema.ts
var validateJSONSchema = (schema) => {
  const errors = [];
  const validateSchemaObject = (schema2, path2 = "") => {
    const validTypes = [
      "array",
      "integer",
      "number",
      "string",
      "boolean",
      "null",
      "object"
    ];
    if (!validTypes.includes(schema2.type)) {
      errors.push(`Invalid type '${schema2.type}' at ${path2 || "root"}`);
      return;
    }
    if (schema2.type === "object" && schema2.properties) {
      if (typeof schema2.properties !== "object" || Array.isArray(schema2.properties)) {
        errors.push(`Invalid properties object at ${path2 || "root"}`);
      } else {
        for (const key in schema2.properties) {
          const value = schema2.properties[key];
          if (typeof value !== "object") {
            errors.push(`Invalid schema object at ${path2}${key}`);
            continue;
          }
          validateSchemaObject(value, `${path2}${key}.`);
        }
      }
      if (schema2.required && !Array.isArray(schema2.required)) {
        errors.push(`'required' should be an array at ${path2 || "root"}`);
      }
    }
    if (schema2.type === "array" && schema2.items) {
      if (typeof schema2.items !== "object") {
        errors.push(`Invalid items schema at ${path2 || "root"}`);
      } else {
        validateSchemaObject(schema2.items, `${path2}items.`);
      }
    }
  };
  validateSchemaObject(schema);
  if (errors.length > 0) {
    throw new Error(errors.join("; "));
  }
};

// dsp/functions.ts
var AxFunctionProcessor = class {
  funcList = [];
  constructor(funcList) {
    this.funcList = funcList;
  }
  executeFunction = async (fnSpec, func, options) => {
    let args;
    if (typeof func.args === "string" && func.args.length > 0) {
      args = JSON52.parse(func.args);
    } else {
      args = func.args;
    }
    const opt = options ? {
      sessionId: options.sessionId,
      traceId: options.traceId,
      ai: options.ai
    } : void 0;
    if (!fnSpec.parameters) {
      const res2 = fnSpec.func.length === 1 ? await fnSpec.func(opt) : await fnSpec.func();
      return {
        id: func.id,
        result: JSON.stringify(res2, null, 2)
      };
    }
    const res = fnSpec.func.length === 2 ? await fnSpec.func(args, opt) : await fnSpec.func(args);
    return {
      id: func.id,
      result: JSON.stringify(res, null, 2)
    };
  };
  execute = async (func, options) => {
    const fnSpec = this.funcList.find(
      (v) => v.name.localeCompare(func.name) === 0
    );
    if (!fnSpec) {
      throw new Error(`Function not found: ` + func.name);
    }
    if (!fnSpec.func) {
      throw new Error("No handler for function: " + func.name);
    }
    return await this.executeFunction(fnSpec, func, options);
  };
};
var parseFunctions = (newFuncs, existingFuncs) => {
  if (newFuncs.length === 0) {
    return [...existingFuncs ?? []];
  }
  const functions = newFuncs.map((f) => {
    if ("toFunction" in f) {
      return f.toFunction();
    }
    return f;
  });
  for (const fn of functions.filter((v) => v.parameters)) {
    validateJSONSchema(fn.parameters);
  }
  return [...existingFuncs ?? [], ...functions];
};
var processFunctions = async (ai, functionList, functionCalls, mem, sessionId, traceId) => {
  const funcProc = new AxFunctionProcessor(functionList);
  const functionsExecuted = /* @__PURE__ */ new Set();
  const promises = functionCalls.map(
    (func) => funcProc?.execute(func, { sessionId, traceId, ai }).then((fres) => {
      functionsExecuted.add(func.name.toLowerCase());
      if (fres?.id) {
        return {
          role: "function",
          result: fres.result ?? "",
          functionId: fres.id
        };
      }
      return null;
    })
  );
  const results = await Promise.all(promises);
  results.forEach((result) => {
    if (result) {
      mem.add(result, sessionId);
    }
  });
  return functionsExecuted;
};
function parseFunctionCalls(ai, functionCalls, values, model) {
  if (!functionCalls || functionCalls.length === 0) {
    return;
  }
  if (!ai.getFeatures(model).functions) {
    throw new Error("Functions are not supported by the AI service");
  }
  const funcs = functionCalls.map((f) => ({
    id: f.id,
    name: f.function.name,
    args: f.function.params
  }));
  return funcs;
}

// dsp/generate.ts
var AxGen = class extends AxProgramWithSignature {
  promptTemplate;
  asserts;
  streamingAsserts;
  options;
  functions;
  functionsExecuted = /* @__PURE__ */ new Set();
  constructor(signature, options) {
    super(signature, { description: options?.description });
    this.options = options;
    this.promptTemplate = new (options?.promptTemplate ?? AxPromptTemplate)(
      this.signature,
      options?.functions
    );
    this.asserts = this.options?.asserts ?? [];
    this.streamingAsserts = this.options?.streamingAsserts ?? [];
    this.usage = [];
    if (options?.functions) {
      this.functions = parseFunctions(options.functions);
    }
  }
  addAssert = (fn, message, optional) => {
    this.asserts.push({ fn, message, optional });
  };
  addStreamingAssert = (fieldName, fn, message, optional) => {
    this.streamingAsserts.push({ fieldName, fn, message, optional });
  };
  async forwardSendRequest({
    ai,
    mem,
    options
  }) {
    const {
      sessionId,
      traceId,
      modelConfig,
      model,
      rateLimiter,
      stream,
      functions,
      functionCall: _functionCall
    } = options ?? {};
    const chatPrompt = mem?.history(sessionId) ?? [];
    if (chatPrompt.length === 0) {
      throw new Error("No chat prompt found");
    }
    const functionCall = _functionCall ?? this.options?.functionCall;
    const res = await ai.chat(
      {
        chatPrompt,
        functions,
        functionCall,
        modelConfig,
        model
      },
      {
        sessionId,
        traceId,
        rateLimiter,
        stream
      }
    );
    return res;
  }
  async forwardCore({
    ai,
    mem,
    options
  }) {
    const { sessionId, traceId, model, functions } = options ?? {};
    const usageInfo = {
      ai: ai.getName(),
      model: ai.getModelInfo().name
    };
    const res = await this.forwardSendRequest({
      ai,
      mem,
      options
    });
    if (res instanceof ReadableStream) {
      return await this.processSteamingResponse({
        ai,
        model,
        res,
        usageInfo,
        mem,
        traceId,
        sessionId,
        functions
      });
    }
    return await this.processResponse({
      ai,
      model,
      res,
      usageInfo,
      mem,
      traceId,
      sessionId,
      functions
    });
  }
  async processSteamingResponse({
    ai,
    model,
    res,
    usageInfo,
    mem,
    sessionId,
    traceId,
    functions
  }) {
    const functionCalls = [];
    const values = {};
    const xstate = { s: -1 };
    let content = "";
    for await (const v of res) {
      for (const result of v.results ?? []) {
        if (v.modelUsage) {
          this.usage.push({ ...usageInfo, ...v.modelUsage });
        }
        if (result.content) {
          content += result.content;
          mem.updateResult({ name: result.name, content }, sessionId);
          assertStreamingAssertions(
            this.streamingAsserts,
            values,
            xstate,
            content,
            false
          );
          streamingExtractValues(this.signature, values, xstate, content);
          assertAssertions(this.asserts, values);
        }
        if (result.functionCalls) {
          mergeFunctionCalls(functionCalls, result.functionCalls);
          mem.updateResult(
            { name: result.name, content, functionCalls },
            sessionId
          );
        }
        if (result.finishReason === "length") {
          throw new Error("Max tokens reached before completion");
        }
      }
    }
    const funcs = parseFunctionCalls(ai, functionCalls, values, model);
    if (funcs) {
      if (!functions) {
        throw new Error("Functions are not defined");
      }
      const fx = await processFunctions(
        ai,
        functions,
        funcs,
        mem,
        sessionId,
        traceId
      );
      this.functionsExecuted = /* @__PURE__ */ new Set([...this.functionsExecuted, ...fx]);
    }
    streamingExtractFinalValue(values, xstate, content);
    assertStreamingAssertions(
      this.streamingAsserts,
      values,
      xstate,
      content,
      true
    );
    assertAssertions(this.asserts, values);
    return { ...values };
  }
  async processResponse({
    ai,
    res,
    usageInfo,
    mem,
    sessionId,
    traceId,
    functions
  }) {
    const values = {};
    for (const result of res.results ?? []) {
      if (res.modelUsage) {
        this.usage.push({ ...usageInfo, ...res.modelUsage });
      }
      mem.addResult(result, sessionId);
      if (result.content) {
        extractValues(this.signature, values, result.content);
        assertAssertions(this.asserts, values);
      }
      if (result.functionCalls) {
        const funcs = parseFunctionCalls(ai, result.functionCalls, values);
        if (funcs) {
          if (!functions) {
            throw new Error("Functions are not defined");
          }
          const fx = await processFunctions(
            ai,
            functions,
            funcs,
            mem,
            sessionId,
            traceId
          );
          this.functionsExecuted = /* @__PURE__ */ new Set([...this.functionsExecuted, ...fx]);
        }
      }
      if (result.finishReason === "length") {
        throw new Error("Max tokens reached before completion");
      }
    }
    return { ...values };
  }
  async _forward(ai, values, options, span) {
    const stopFunction = (options?.stopFunction ?? this.options?.stopFunction)?.toLowerCase();
    const maxRetries = options?.maxRetries ?? this.options?.maxRetries ?? 15;
    const maxSteps = options?.maxSteps ?? this.options?.maxSteps ?? 10;
    const mem = options?.mem ?? this.options?.mem ?? new AxMemory();
    let err;
    if (options?.functions && options?.functions.length > 0) {
      const promptTemplate = this.options?.promptTemplate ?? AxPromptTemplate;
      this.promptTemplate = new promptTemplate(
        this.signature,
        options.functions
      );
    }
    const prompt = this.promptTemplate.render(values, {
      examples: this.examples,
      demos: this.demos
    });
    mem.add(prompt, options?.sessionId);
    multiStepLoop: for (let n = 0; n < maxSteps; n++) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const output = await this.forwardCore({
            options,
            ai,
            mem
          });
          const lastMemItem = mem.getLast(options?.sessionId);
          const stopFunctionExecuted = stopFunction && this.functionsExecuted.has(stopFunction);
          if (lastMemItem?.role === "function") {
            if (!stopFunction || !stopFunctionExecuted) {
              continue multiStepLoop;
            }
          }
          if (!stopFunctionExecuted) {
            assertRequiredFields(this.signature, output);
          }
          this.trace = { ...values, ...output };
          return output;
        } catch (e) {
          let extraFields;
          span?.recordException(e);
          if (e instanceof AxValidationError) {
            extraFields = e.getFixingInstructions();
            err = e;
          } else if (e instanceof AxAssertionError) {
            const e1 = e;
            extraFields = e1.getFixingInstructions(this.signature);
            err = e;
          } else {
            throw e;
          }
          if (extraFields) {
            const content = this.promptTemplate.renderExtraFields(extraFields);
            mem.add({ role: "user", content }, options?.sessionId);
            if (options?.debug) {
              console.log("Error Correction:", content);
            }
          }
        }
      }
      if (err instanceof AxAssertionError && err.getOptional()) {
        return err.getValue();
      }
      throw new Error(`Unable to fix validation error: ${err?.message}`);
    }
    throw new Error(`Max steps reached: ${maxSteps}`);
  }
  async forward(ai, values, options) {
    const tracer = this.options?.tracer ?? options?.tracer;
    let functions = this.functions;
    if (options?.functions) {
      functions = parseFunctions(options.functions, this.functions);
    }
    if (!tracer) {
      return await this._forward(ai, values, {
        ...options,
        functions
      });
    }
    const funcNames = functions?.map((f) => f.name).join(",");
    const attributes = {
      ["generate.signature"]: this.signature.toString(),
      ["generate.functions"]: funcNames ?? ""
    };
    return await tracer.startActiveSpan(
      "Generate",
      {
        kind: SpanKind2.SERVER,
        attributes
      },
      async (span) => {
        const res = this._forward(ai, values, options, span);
        span.end();
        return res;
      }
    );
  }
};

// prompts/agent.ts
var AxAgent = class {
  ai;
  signature;
  program;
  agents;
  name;
  description;
  subAgentList;
  func;
  constructor({
    ai,
    name,
    description,
    signature,
    agents,
    functions
  }, options) {
    this.ai = ai;
    this.agents = agents;
    this.signature = new AxSignature(signature);
    this.signature.setDescription(description);
    const funcs = [
      ...functions ?? [],
      ...agents?.map((a) => a.getFunction()) ?? []
    ];
    const opt = { ...options, functions: funcs };
    this.program = new AxGen(this.signature, opt);
    if (!name || name.length < 5) {
      throw new Error(
        `Agent name must be at least 10 characters (more descriptive): ${name}`
      );
    }
    if (!description || description.length < 20) {
      throw new Error(
        `Agent description must be at least 20 characters (explain in detail what the agent does): ${description}`
      );
    }
    this.name = name;
    this.description = description;
    this.subAgentList = agents?.map((a) => a.getFunction().name).join(", ");
    this.func = {
      name: toCamelCase(this.name),
      description: this.description,
      parameters: this.signature.toJSONSchema(),
      func: () => this.forward
    };
    for (const agent of agents ?? []) {
      this.program.register(agent);
    }
  }
  setExamples(examples) {
    this.program.setExamples(examples);
  }
  setId(id) {
    this.program.setId(id);
  }
  setParentId(parentId) {
    this.program.setParentId(parentId);
  }
  getTraces() {
    return this.program.getTraces();
  }
  setDemos(demos) {
    this.program.setDemos(demos);
  }
  getUsage() {
    return this.program.getUsage();
  }
  resetUsage() {
    this.program.resetUsage();
  }
  getFunction() {
    const boundFunc = this.forward.bind(this);
    const wrappedFunc = (values, options) => {
      const ai = this.ai ?? options?.ai;
      if (!ai) {
        throw new Error("AI service is required to run the agent");
      }
      return boundFunc(ai, values, options);
    };
    return {
      ...this.func,
      func: wrappedFunc
    };
  }
  async forward(ai, values, options) {
    const _ai = this.ai ?? ai;
    const funcs = [
      ...options?.functions ?? [],
      ...this.agents?.map((a) => a.getFunction()) ?? []
    ];
    const opt = options;
    if (funcs.length > 0) {
      const opt2 = { ...options, functions: funcs };
      this.program = new AxGen(this.signature, opt2);
    }
    if (!options?.tracer) {
      return await this.program.forward(_ai, values, opt);
    }
    const attributes = {
      ["agent.name"]: this.name,
      ["agent.description"]: this.description,
      ["agent.subAgents"]: this.subAgentList ?? "none"
    };
    return await options?.tracer.startActiveSpan(
      "Agent",
      {
        kind: SpanKind3.SERVER,
        attributes
      },
      async (span) => {
        const res = await this.program.forward(_ai, values, opt);
        span.end();
        return res;
      }
    );
  }
};
function toCamelCase(inputString) {
  const words = inputString.split(/[^a-zA-Z0-9]/);
  const camelCaseString = words.map((word, index) => {
    const lowerWord = word.toLowerCase();
    if (index > 0 && lowerWord && lowerWord[0]) {
      return lowerWord[0].toUpperCase() + lowerWord.slice(1);
    }
    return lowerWord;
  }).join("");
  return camelCaseString;
}

// docs/tika.ts
import { createReadStream } from "node:fs";
var AxApacheTika = class {
  tikaUrl;
  fetch;
  constructor(args) {
    const _args = args ?? { url: "http://localhost:9998/" };
    this.tikaUrl = new URL("/tika", _args.url);
    this.fetch = _args.fetch;
  }
  async _convert(file, options) {
    const fileData = typeof file === "string" ? createReadStream(file) : file.stream();
    if (!fileData) {
      throw new Error("Failed to read file data");
    }
    const acceptValue = options?.format === "html" ? "text/html" : "text/plain";
    try {
      const res = await (this.fetch ?? fetch)(this.tikaUrl, {
        body: fileData,
        headers: { Accept: acceptValue },
        duplex: "half",
        method: "PUT"
      });
      if (!res.ok) {
        throw new Error(`Failed to upload file: ${res.statusText}`);
      }
      const text = await res.text();
      return text;
    } catch (error) {
      throw new Error(`Error converting file: ${error}`);
    }
  }
  async convert(files, options) {
    const results = [];
    const bs = options?.batchSize ?? 10;
    for (let i = 0; i < files.length; i += bs) {
      const batch = files.slice(i, i + bs);
      const uploadPromises = batch.map(
        (files2) => this._convert(files2, { format: options?.format })
      );
      const batchResults = await Promise.all(uploadPromises);
      results.push(...batchResults);
    }
    return results;
  }
};

// ai/balance.ts
var axCostComparator = (a, b) => {
  const aInfo = a.getModelInfo();
  const bInfo = b.getModelInfo();
  const aTotalCost = (aInfo.promptTokenCostPer1M || Infinity) + (aInfo.completionTokenCostPer1M || Infinity);
  const bTotalCost = (bInfo.promptTokenCostPer1M || Infinity) + (bInfo.completionTokenCostPer1M || Infinity);
  return aTotalCost - bTotalCost;
};
var AxBalancer = class {
  services;
  currentServiceIndex = 0;
  currentService;
  constructor(services, options) {
    if (services.length === 0) {
      throw new Error("No AI services provided.");
    }
    this.services = [...services].sort(options?.comparator ?? axCostComparator);
    const cs = this.services[this.currentServiceIndex];
    if (cs === void 0) {
      throw new Error("Error initializing the AI services.");
    }
    this.currentService = cs;
  }
  getModelMap() {
    throw new Error("Method not implemented.");
  }
  getNextService() {
    const cs = this.services[++this.currentServiceIndex];
    if (cs === void 0) {
      return false;
    }
    this.currentService = cs;
    return true;
  }
  reset() {
    this.currentServiceIndex = 0;
    const cs = this.services[this.currentServiceIndex];
    if (cs === void 0) {
      throw new Error("No AI services provided.");
    }
    this.currentService = cs;
  }
  getName() {
    return this.currentService.getName();
  }
  getModelInfo() {
    return this.currentService.getModelInfo();
  }
  getEmbedModelInfo() {
    return this.currentService.getEmbedModelInfo();
  }
  getFeatures(model) {
    return this.currentService.getFeatures(model);
  }
  getMetrics() {
    return this.currentService.getMetrics();
  }
  async chat(req, options) {
    this.reset();
    while (true) {
      try {
        return await this.currentService.chat(req, options);
      } catch (e) {
        if (!this.getNextService()) {
          throw e;
        }
      }
    }
  }
  async embed(req, options) {
    this.reset();
    while (true) {
      try {
        return await this.currentService.embed(req, options);
      } catch (e) {
        if (!this.getNextService()) {
          throw e;
        }
      }
    }
  }
  setOptions(options) {
    this.currentService.setOptions(options);
  }
};

// dsp/optimize.ts
var AxBootstrapFewShot = class {
  ai;
  program;
  examples;
  maxRounds;
  maxDemos;
  maxExamples;
  traces = [];
  constructor({
    ai,
    program,
    examples = [],
    options
  }) {
    if (examples.length == 0) {
      throw new Error("No examples found");
    }
    this.maxRounds = options?.maxRounds ?? 3;
    this.maxDemos = options?.maxDemos ?? 4;
    this.maxExamples = options?.maxExamples ?? 16;
    this.ai = ai;
    this.program = program;
    this.examples = examples;
  }
  async compileRound(roundIndex, metricFn, options) {
    const st = (/* @__PURE__ */ new Date()).getTime();
    const maxDemos = options?.maxDemos ?? this.maxDemos;
    const aiOpt = { modelConfig: { temperature: 0.7 } };
    const examples = randomSample(this.examples, this.maxExamples);
    for (let i = 0; i < examples.length; i++) {
      if (i > 0) {
        aiOpt.modelConfig.temperature = 0.7 + 1e-3 * i;
      }
      const ex = examples[i];
      if (!ex) {
        throw new Error("Invalid example");
      }
      const exList = [...examples.slice(0, i), ...examples.slice(i + 1)];
      this.program.setExamples(exList);
      const res = await this.program.forward(this.ai, ex, aiOpt);
      const success = metricFn({ prediction: res, example: ex });
      if (success) {
        this.traces = [...this.traces, ...this.program.getTraces()];
      }
      const current = i + examples.length * roundIndex;
      const total = examples.length * this.maxRounds;
      const et = (/* @__PURE__ */ new Date()).getTime() - st;
      updateProgressBar(
        current,
        total,
        this.traces.length,
        et,
        30,
        "Tuning Prompt"
      );
      if (this.traces.length > maxDemos) {
        return;
      }
    }
  }
  async compile(metricFn, options) {
    const maxRounds = options?.maxRounds ?? this.maxRounds;
    this.traces = [];
    for (let i = 0; i < maxRounds; i++) {
      await this.compileRound(i, metricFn, options);
    }
    if (this.traces.length === 0) {
      throw new Error(
        "No demonstrations found. Either provider more examples or improve the existing ones."
      );
    }
    const demos = groupTracesByKeys(this.traces);
    return demos;
  }
};
function groupTracesByKeys(programTraces) {
  const groupedTraces = /* @__PURE__ */ new Map();
  for (const programTrace of programTraces) {
    if (groupedTraces.has(programTrace.programId)) {
      groupedTraces.get(programTrace.programId).push(programTrace.trace);
    } else {
      groupedTraces.set(programTrace.programId, [programTrace.trace]);
    }
  }
  const programDemosArray = [];
  groupedTraces.forEach((traces, programId) => {
    programDemosArray.push({ traces, programId });
  });
  return programDemosArray;
}
var randomSample = (array, n) => {
  const clonedArray = [...array];
  for (let i = clonedArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const caI = clonedArray[i];
    const caJ = clonedArray[j];
    if (!caI || !caJ) {
      throw new Error("Invalid array elements");
    }
    ;
    [clonedArray[i], clonedArray[j]] = [caJ, caI];
  }
  return clonedArray.slice(0, n);
};

// db/base.ts
import { SpanKind as SpanKind4 } from "@opentelemetry/api";
var AxDBBase = class {
  name;
  fetch;
  tracer;
  _upsert;
  _batchUpsert;
  _query;
  constructor({
    name,
    fetch: fetch2,
    tracer
  }) {
    this.name = name;
    this.fetch = fetch2;
    this.tracer = tracer;
  }
  async upsert(req, update) {
    if (!this._upsert) {
      throw new Error("upsert() not implemented");
    }
    if (!this.tracer) {
      return await this._upsert(req, update);
    }
    return await this.tracer?.startActiveSpan(
      "DB Upsert Request",
      {
        kind: SpanKind4.SERVER,
        attributes: {
          [axSpanAttributes.DB_SYSTEM]: this.name,
          [axSpanAttributes.DB_OPERATION_NAME]: "upsert",
          [axSpanAttributes.DB_TABLE]: req.table,
          [axSpanAttributes.DB_NAMESPACE]: req.namespace,
          [axSpanAttributes.DB_OPERATION_NAME]: update ? "update" : "insert"
        }
      },
      async (span) => {
        const res = await this._upsert(req, update, { span });
        span.end();
        return res;
      }
    );
  }
  async batchUpsert(req, update) {
    if (!this._batchUpsert) {
      throw new Error("batchUpsert() not implemented");
    }
    if (req.length == 0) {
      throw new Error("Batch request is empty");
    }
    if (!req[0]) {
      throw new Error("Batch request is invalid first element is undefined");
    }
    if (!this.tracer) {
      return await this._batchUpsert(req, update);
    }
    return await this.tracer?.startActiveSpan(
      "DB Batch Upsert Request",
      {
        kind: SpanKind4.SERVER,
        attributes: {
          [axSpanAttributes.DB_SYSTEM]: this.name,
          [axSpanAttributes.DB_OPERATION_NAME]: "upsert",
          [axSpanAttributes.DB_TABLE]: req[0].table,
          [axSpanAttributes.DB_NAMESPACE]: req[0].namespace,
          [axSpanAttributes.DB_OPERATION_NAME]: update ? "update" : "insert"
        }
      },
      async (span) => {
        const res = await this._batchUpsert(req, update, { span });
        span.end();
        return res;
      }
    );
  }
  async query(req) {
    if (!this._query) {
      throw new Error("query() not implemented");
    }
    if (!this.tracer) {
      return await this._query(req);
    }
    return await this.tracer?.startActiveSpan(
      "DB Query Request",
      {
        kind: SpanKind4.SERVER,
        attributes: {
          [axSpanAttributes.DB_SYSTEM]: this.name,
          [axSpanAttributes.DB_OPERATION_NAME]: "upsert",
          [axSpanAttributes.DB_TABLE]: req.table,
          [axSpanAttributes.DB_NAMESPACE]: req.namespace,
          [axSpanAttributes.DB_OPERATION_NAME]: "query"
        }
      },
      async (span) => {
        const res = await this._query(req, { span });
        span.end();
        return res;
      }
    );
  }
};

// db/cloudflare.ts
var baseURL = "https://api.cloudflare.com/client/v4/accounts/";
var AxDBCloudflare = class extends AxDBBase {
  apiKey;
  accountId;
  constructor({
    apiKey,
    accountId,
    fetch: fetch2,
    tracer
  }) {
    if (!apiKey || !accountId) {
      throw new Error("Cloudflare credentials not set");
    }
    super({ name: "Cloudflare", fetch: fetch2, tracer });
    this.apiKey = apiKey;
    this.accountId = accountId;
  }
  _upsert = async (req, _update, options) => {
    const res = await apiCall(
      {
        url: new URL(
          `${this.accountId}/vectorize/indexes/${req.table}/upsert`,
          baseURL
        ),
        headers: {
          "X-Auth-Key": this.apiKey
        },
        fetch: this.fetch,
        span: options?.span
      },
      {
        id: req.id,
        values: req.values,
        namespace: req.namespace,
        metadata: req.metadata
      }
    );
    if (res.errors) {
      throw new Error(
        `Cloudflare upsert failed: ${res.errors.map(({ message }) => message).join(", ")}`
      );
    }
    return {
      ids: res.result.ids
    };
  };
  batchUpsert = async (batchReq, update, options) => {
    if (update) {
      throw new Error("Weaviate does not support batch update");
    }
    if (batchReq.length < 1) {
      throw new Error("Batch request is empty");
    }
    if (!batchReq[0] || !batchReq[0].table) {
      throw new Error("Table name is empty");
    }
    const table2 = batchReq[0].table;
    const res = await apiCall(
      {
        url: new URL(
          `${this.accountId}/vectorize/indexes/${table2}/upsert`,
          baseURL
        ),
        headers: {
          "X-Auth-Key": this.apiKey
        },
        fetch: this.fetch,
        span: options?.span
      },
      batchReq.map((req) => ({
        id: req.id,
        values: req.values,
        namespace: req.namespace,
        metadata: req.metadata
      }))
    );
    if (res.errors) {
      throw new Error(
        `Cloudflare batch upsert failed: ${res.errors.map(({ message }) => message).join(", ")}`
      );
    }
    return {
      ids: res.result.ids
    };
  };
  query = async (req, options) => {
    const res = await apiCall(
      {
        url: new URL(
          `${this.accountId}/vectorize/indexes/${req.table}/query`,
          baseURL
        ),
        headers: {
          "X-Auth-Key": this.apiKey
        },
        fetch: this.fetch,
        span: options?.span
      },
      {
        vector: req.values,
        topK: req.limit || 10,
        returnValues: true
      }
    );
    if (res.errors) {
      throw new Error(
        `Cloudflare query failed: ${res.errors.map(({ message }) => message).join(", ")}`
      );
    }
    const matches = res.result.matches.map(
      ({ id, score, values, metadata }) => ({
        id,
        score,
        values,
        metadata
      })
    );
    return { matches };
  };
};

// db/memory.ts
var AxDBMemory = class extends AxDBBase {
  state;
  constructor({ tracer } = {}) {
    super({ name: "Memory", tracer });
    this.state = {};
  }
  _upsert = async (req, _update, _options) => {
    if (!this.state[req.table]) {
      this.state[req.table] = {
        [req.id]: req
      };
    } else {
      const obj = this.state[req.table];
      if (!obj) {
        throw new Error("Table not found: " + req.table);
      }
      obj[req.id] = req;
    }
    return { ids: [req.id] };
  };
  _batchUpsert = async (batchReq, update, _options) => {
    const ids = [];
    for (const req of batchReq) {
      const res = await this.upsert(req, update);
      ids.push(...res.ids);
    }
    return { ids };
  };
  _query = async (req, _options) => {
    const table2 = this.state[req.table];
    if (!table2) {
      return { matches: [] };
    }
    const matches = [];
    Object.entries(table2).forEach(([id, data]) => {
      if (req.values && data.values) {
        const score = distance(req.values, data.values);
        matches.push({ id, score, metadata: data.metadata });
      }
    });
    matches.sort((a, b) => a.score - b.score);
    if (req.limit) {
      matches.length = req.limit;
    }
    return { matches };
  };
  getDB = () => {
    return structuredClone(this.state);
  };
  setDB = (state) => {
    this.state = structuredClone(state);
  };
  clearDB = () => {
    this.state = {};
  };
};
var distance = (a, b) => {
  if (a.length !== b.length) {
    throw new Error("Vectors must be of the same length.");
  }
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;
  let zeroVectorA = true;
  let zeroVectorB = true;
  const vectorA = new Float64Array(a);
  const vectorB = new Float64Array(b);
  for (let i = 0; i < vectorA.length; i++) {
    dotProduct += vectorA[i] * vectorB[i];
    normA += vectorA[i] * vectorA[i];
    normB += vectorB[i] * vectorB[i];
    if (vectorA[i] !== 0) zeroVectorA = false;
    if (vectorB[i] !== 0) zeroVectorB = false;
  }
  if (zeroVectorA || zeroVectorB) {
    return 1;
  }
  const sqrtNormA = Math.sqrt(normA);
  const sqrtNormB = Math.sqrt(normB);
  const similarity = dotProduct / (sqrtNormA * sqrtNormB);
  return 1 - similarity;
};

// db/pinecone.ts
var createPineconeQueryRequest = (req) => {
  const pineconeQueryRequest = {
    namespace: req.namespace,
    topK: req.limit || 10,
    filter: {},
    includeValues: true,
    includeMetadata: true,
    vector: req.values ?? [],
    id: req.id
  };
  return pineconeQueryRequest;
};
var AxDBPinecone = class extends AxDBBase {
  apiKey;
  apiURL;
  constructor({
    apiKey,
    host,
    fetch: fetch2,
    tracer
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("Pinecone API key not set");
    }
    super({ name: "Pinecone", fetch: fetch2, tracer });
    this.apiKey = apiKey;
    this.apiURL = host;
  }
  _upsert = async (req, update, options) => {
    await this._batchUpsert([req], update, options);
    return { ids: [req.id] };
  };
  _batchUpsert = async (batchReq, _update, options) => {
    if (batchReq.length === 0) {
      throw new Error("Batch request is empty");
    }
    await apiCall(
      {
        url: this.apiURL,
        headers: { Authorization: `Bearer ${this.apiKey}` },
        name: "/vectors/upsert",
        fetch: this.fetch,
        span: options?.span
      },
      batchReq.map(({ id, values = [], metadata }) => ({
        id,
        values,
        metadata
      }))
    );
    return { ids: batchReq.map(({ id }) => id) };
  };
  query = async (req, options) => {
    if (req.text) {
      throw new Error("Pinecone does not support text");
    }
    const res = await apiCall(
      {
        url: this.apiURL,
        headers: { Authorization: `Bearer ${this.apiKey}` },
        name: "/query",
        fetch: this.fetch,
        span: options?.span
      },
      createPineconeQueryRequest(req)
    );
    const matches = res.matches.map(({ id, score, values, metadata }) => ({
      id,
      score,
      metadata,
      values
    }));
    return { matches };
  };
};

// db/weaviate.ts
var AxDBWeaviate = class extends AxDBBase {
  apiKey;
  apiURL;
  constructor({
    apiKey,
    host,
    fetch: fetch2,
    tracer
  }) {
    if (!apiKey || apiKey === "") {
      throw new Error("Weaviate API key not set");
    }
    super({ name: "Weaviate", fetch: fetch2, tracer });
    this.apiKey = apiKey;
    this.apiURL = host;
  }
  _upsert = async (req, update, options) => {
    const res = await apiCall(
      {
        url: this.apiURL,
        headers: { Authorization: `Bearer ${this.apiKey}` },
        name: `/v1/objects/${req.table}/${req.id}`,
        put: update ? true : false,
        fetch: this.fetch,
        span: options?.span
      },
      {
        id: req.id,
        class: req.table,
        tenant: req.namespace,
        vector: req.values,
        properties: req.metadata ?? {}
      }
    );
    if (res?.result?.errors) {
      throw new Error(
        `Weaviate upsert failed: ${res.result.errors.error.map(({ message }) => message).join(", ")}`
      );
    }
    return {
      ids: [res.id]
    };
  };
  _batchUpsert = async (batchReq, update, options) => {
    if (update) {
      throw new Error("Weaviate does not support batch update");
    }
    if (batchReq.length === 0) {
      throw new Error("Batch request is empty");
    }
    const objects = batchReq.map((req) => ({
      id: req.id,
      class: req.table,
      tenant: req.namespace,
      vector: req.values,
      properties: req.metadata ?? {}
    }));
    const res = await apiCall(
      {
        url: this.apiURL,
        headers: { Authorization: `Bearer ${this.apiKey}` },
        name: "/v1/batch/objects",
        fetch: this.fetch,
        span: options?.span
      },
      { objects }
    );
    if (res?.some(({ result }) => result?.errors)) {
      throw new Error(
        `Weaviate batch upsert failed: ${res.map(
          ({ result }) => result?.errors?.error.map(({ message }) => message).join(", ")
        ).join(", ")}`
      );
    }
    return {
      ids: res.map(({ id }) => id)
    };
  };
  _query = async (req, options) => {
    let filter = "";
    if (req.columns && req.columns.length === 0) {
      throw new Error("Weaviate requires at least one column");
    }
    if (req.values) {
      filter = `nearVector: {
            vector: [${req.values.join(",")}],
        }`;
    } else if (req.text) {
      filter = `nearText: {
            concepts: ['${req.text}'],
        }`;
    } else {
      throw new Error("Weaviate requires either text or values");
    }
    const res = await apiCall(
      {
        url: this.apiURL,
        headers: { Authorization: `Bearer ${this.apiKey}` },
        name: "/v1/graphql",
        fetch: this.fetch,
        span: options?.span
      },
      {
        query: `{
          Get {
            ${req.table} (
              limit: ${req.limit || 10},
              ${filter}
            ) {
                ${req.columns?.join("\n")}
            }
          }
        }`
      }
    );
    if (res.errors) {
      throw new Error(
        `Weaviate query failed: ${res.errors.map(({ message }) => message).join(", ")}`
      );
    }
    const resMatches = res.data.Get[req.table];
    if (!resMatches) {
      return { matches: [] };
    }
    const matches = resMatches.map((match) => {
      return {
        id: match["id"],
        score: 1,
        metadata: match
      };
    });
    return { matches };
  };
};

// db/wrap.ts
var AxDB = class {
  db;
  constructor(args) {
    switch (args.name) {
      case "weaviate":
        this.db = new AxDBWeaviate(args);
        break;
      case "pinecone":
        this.db = new AxDBPinecone(args);
        break;
      case "cloudflare":
        this.db = new AxDBCloudflare(args);
        break;
      case "memory":
        this.db = new AxDBMemory(args);
        break;
      default:
        throw new Error(`Unknown DB`);
    }
  }
  async upsert(req, update) {
    return await this.db.upsert(req, update);
  }
  async batchUpsert(batchReq, update) {
    return await this.db.batchUpsert(batchReq, update);
  }
  async query(req) {
    return await this.db.query(req);
  }
};

// docs/manager.ts
var table = "_internal";
var AxDBManager = class {
  ai;
  db;
  chunker;
  rewriter;
  reranker;
  constructor({ ai, db, config }) {
    this.ai = ai;
    this.db = db;
    this.chunker = config?.chunker ?? this.defaultChunker;
    this.reranker = config?.reranker;
    this.rewriter = config?.rewriter;
  }
  defaultChunker = (text) => {
    return text.split(/\n\n+/);
  };
  insert = async (text, options) => {
    try {
      const chunkerInput = Array.isArray(text) ? text.join("\n\n") : text;
      const initialChunks = this.chunker(chunkerInput).filter(
        (chunk) => chunk.length > 0
      );
      const maxWordsPerChunk = options?.maxWordsPerChunk;
      const minWordsPerChunk = options?.minWordsPerChunk;
      const chunks = processChunks({
        initialChunks,
        minWordsPerChunk,
        maxWordsPerChunk
      });
      const bs = options?.batchSize ?? 10;
      for (let i = 0; i < chunks.length; i += bs) {
        const batch = chunks.slice(i, i + bs);
        const ret = await this.ai.embed({ texts: batch });
        const embeddings = ret.embeddings.map((embedding, index) => ({
          id: `chunk_${Date.now() + index}`,
          // Unique ID for each chunk, adjusted by index
          table,
          values: embedding,
          metadata: { text: batch[index] ?? "" }
        })).filter(
          (v) => v.metadata?.["text"] && v.metadata?.["text"].length > 0
        );
        await this.db.batchUpsert(embeddings);
      }
    } catch (error) {
      throw new Error(`Error processing text: ${error}`);
    }
  };
  query = async (query, { topPercent } = {}) => {
    const texts = Array.isArray(query) ? query : [query];
    if (typeof texts[0] === "string" && this.rewriter) {
      for (const [i, text] of texts.entries()) {
        const { rewrittenQuery } = await this.rewriter.forward(this.ai, {
          query: text
        });
        texts[i] = rewrittenQuery;
      }
    }
    let queries;
    if (typeof texts[0] === "string") {
      const embedResults = await this.ai.embed({ texts });
      queries = embedResults.embeddings.map(
        (values) => this.db.query({ table, values })
      );
    } else {
      queries = texts.map((values) => this.db.query({ table, values }));
    }
    const queryResults = await Promise.all(queries);
    const res = [];
    for (const { matches } of queryResults) {
      const m = matches.filter((v) => v.metadata?.["text"] && v.metadata?.["text"].length > 0).map(({ score, metadata }) => ({
        score,
        text: metadata?.["text"] ?? ""
      }));
      const tp = topPercent && topPercent > 1 ? topPercent / 100 : topPercent;
      const resultItems = tp ? getTopInPercent(m, tp) : m;
      if (this.reranker) {
        const { rankedItems } = await this.reranker.forward(this.ai, {
          query: texts[0],
          items: resultItems.map((item) => item.text)
        });
        const items = rankedItems.map((item) => resultItems.find((r) => r.text === item)).filter((v) => v !== void 0);
        res.push(items);
      } else {
        res.push(resultItems);
      }
    }
    return res;
  };
};
var processChunks = ({
  initialChunks,
  maxWordsPerChunk = 350,
  minWordsPerChunk = 250
}) => {
  const chunks = [];
  let currentChunk = "";
  let currentWordCount = 0;
  initialChunks.forEach((chunk) => {
    const words = chunk.split(/\s+/);
    const wordCount = words.length;
    if (currentWordCount + wordCount <= maxWordsPerChunk) {
      currentChunk += chunk + "\n\n";
      currentWordCount += wordCount;
    } else if (currentWordCount > 0 && currentWordCount + wordCount <= maxWordsPerChunk * 1.5) {
      currentChunk += chunk + "\n\n";
      currentWordCount += wordCount;
    } else {
      if (currentWordCount > minWordsPerChunk) {
        chunks.push(currentChunk.trim());
        currentChunk = "";
        currentWordCount = 0;
      }
      if (wordCount > maxWordsPerChunk) {
        const remainingWords = words;
        while (remainingWords.length > maxWordsPerChunk * 1.5) {
          const slice = remainingWords.splice(0, maxWordsPerChunk);
          chunks.push(slice.join(" "));
        }
        if (remainingWords.length > 0) {
          currentChunk += remainingWords.join(" ") + "\n\n";
          currentWordCount += remainingWords.length;
        }
      } else {
        currentChunk = chunk + "\n\n";
        currentWordCount = wordCount;
      }
    }
  });
  if (currentWordCount > minWordsPerChunk || chunks.length === 0) {
    chunks.push(currentChunk.trim());
  }
  return chunks;
};
var getTopInPercent = (entries, percent = 0.1) => {
  const sortedEntries = [...entries].sort((a, b) => a.score - b.score);
  const topTenPercentCount = Math.ceil(sortedEntries.length * percent);
  return sortedEntries.slice(0, topTenPercentCount);
};

// funcs/docker.ts
var AxDockerSession = class {
  apiUrl;
  containerId = null;
  constructor(apiUrl = "http://localhost:2375") {
    this.apiUrl = apiUrl;
  }
  async pullImage(imageName) {
    const response = await this.fetchDockerAPI(
      `/images/create?fromImage=${encodeURIComponent(imageName)}`,
      {
        method: "POST"
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to pull image: ${response.statusText}`);
    }
    await response.text();
  }
  async createContainer({
    imageName,
    volumes = [],
    doNotPullImage,
    tag
  }) {
    const binds = volumes.map((v) => `${v.hostPath}:${v.containerPath}`);
    if (!doNotPullImage) {
      await this.pullImage(imageName);
    }
    const containerConfig = {
      Image: imageName,
      Tty: true,
      OpenStdin: false,
      AttachStdin: false,
      AttachStdout: false,
      AttachStderr: false,
      HostConfig: { Binds: binds },
      Labels: {}
    };
    if (tag) {
      containerConfig.Labels["com.example.tag"] = tag;
    }
    const response = await this.fetchDockerAPI(`/containers/create`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(containerConfig)
    });
    if (!response.ok) {
      throw new Error(`Failed to create container: ${response.statusText}`);
    }
    const data = await response.json();
    this.containerId = data.Id;
    return data;
  }
  async findOrCreateContainer({
    imageName,
    volumes = [],
    doNotPullImage,
    tag
  }) {
    const existingContainers = await this.listContainers(true);
    const matchingContainers = existingContainers.filter(
      (container) => container.Labels && container.Labels["com.example.tag"] === tag
    );
    if (matchingContainers && matchingContainers.length > 0) {
      const randomIndex = Math.floor(Math.random() * matchingContainers.length);
      const selectedContainer = matchingContainers[randomIndex];
      if (selectedContainer) {
        await this.connectToContainer(selectedContainer.Id);
        return { Id: selectedContainer.Id, isNew: false };
      }
    }
    const newContainer = await this.createContainer({
      imageName,
      volumes,
      doNotPullImage,
      tag
    });
    return { Id: newContainer.Id, isNew: true };
  }
  async startContainer() {
    if (!this.containerId) {
      throw new Error("No container created or connected");
    }
    const response = await this.fetchDockerAPI(
      `/containers/${this.containerId}/start`,
      {
        method: "POST"
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to start container: ${response.statusText}`);
    }
  }
  async connectToContainer(containerId) {
    const response = await this.fetchDockerAPI(
      `/containers/${containerId}/json`
    );
    if (!response.ok) {
      throw new Error(`Failed to connect to container: ${response.statusText}`);
    }
    this.containerId = containerId;
  }
  async stopContainers({
    tag,
    remove,
    timeout = 10
  }) {
    const results = [];
    const containers = await this.listContainers(true);
    const targetContainers = tag ? containers.filter(
      (container) => container.Labels["com.example.tag"] === tag
    ) : containers;
    for (const container of targetContainers) {
      if (container.State.Status === "running") {
        const stopResponse = await this.fetchDockerAPI(
          `/containers/${container.Id}/stop?t=${timeout}`,
          { method: "POST" }
        );
        if (!stopResponse.ok) {
          console.warn(
            `Failed to stop container ${container.Id}: ${stopResponse.statusText}`
          );
          continue;
        }
        results.push({ Id: container.Id, Action: "stopped" });
      }
      if (remove) {
        const removeResponse = await this.fetchDockerAPI(
          `/containers/${container.Id}`,
          { method: "DELETE" }
        );
        if (!removeResponse.ok) {
          console.warn(
            `Failed to remove container ${container.Id}: ${removeResponse.statusText}`
          );
          continue;
        }
        results.push({ Id: container.Id, Action: "removed" });
      }
    }
    return results;
  }
  async listContainers(all = false) {
    const response = await this.fetchDockerAPI(`/containers/json?all=${all}`, {
      method: "GET"
    });
    return response.json();
  }
  async getContainerLogs() {
    if (!this.containerId) {
      throw new Error("No container created or connected");
    }
    const response = await this.fetchDockerAPI(
      `/containers/${this.containerId}/logs?stdout=true&stderr=true`,
      { method: "GET" }
    );
    return response.text();
  }
  async executeCommand(command) {
    console.log("Executing command:", command);
    if (!this.containerId) {
      throw new Error("No container created or connected");
    }
    const containerInfo = await this.getContainerInfo(this.containerId);
    if (containerInfo.State.Status !== "running") {
      await this.startContainer();
      await this.waitForContainerToBeRunning(this.containerId);
    }
    const createResponse = await this.fetchDockerAPI(
      `/containers/${this.containerId}/exec`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          Cmd: ["sh", "-c", command],
          AttachStdout: true,
          AttachStderr: true
        })
      }
    );
    if (!createResponse.ok) {
      throw new Error(
        `Failed to create exec instance: ${createResponse.statusText}`
      );
    }
    const execData = await createResponse.json();
    const startResponse = await this.fetchDockerAPI(
      `/exec/${execData.Id}/start`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          Detach: false,
          Tty: false
        })
      }
    );
    if (!startResponse.ok) {
      throw new Error(
        `Failed to start exec instance: ${startResponse.statusText}`
      );
    }
    return await startResponse.text();
  }
  // Add these new methods to the class:
  async getContainerInfo(containerId) {
    const response = await this.fetchDockerAPI(
      `/containers/${containerId}/json`
    );
    if (!response.ok) {
      throw new Error(`Failed to get container info: ${response.statusText}`);
    }
    return response.json();
  }
  async waitForContainerToBeRunning(containerId, timeout = 3e4) {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
      const containerInfo = await this.getContainerInfo(containerId);
      if (containerInfo.State.Status === "running") {
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 1e3));
    }
    throw new Error("Timeout waiting for container to start");
  }
  async fetchDockerAPI(endpoint, options) {
    const url = new URL(endpoint, this.apiUrl).toString();
    return await fetch(url, options);
  }
  toFunction() {
    return {
      name: "commandExecution",
      description: "Use this function to execute shell commands, scripts, and programs. This function enables interaction with the file system, running system utilities, and performing tasks that require a shell interface.",
      parameters: {
        type: "object",
        properties: {
          command: {
            type: "string",
            description: 'Shell command to execute. eg. `ls -l` or `echo "Hello, World!"`.'
          }
        },
        required: ["command"]
      },
      func: async ({ command }) => await this.executeCommand(command)
    };
  }
};

// dsp/loader.ts
var AxHFDataLoader = class {
  rows = [];
  baseUrl;
  dataset;
  split;
  config;
  options;
  constructor({
    dataset,
    split,
    config,
    options
  }) {
    this.baseUrl = "https://datasets-server.huggingface.co/rows";
    this.dataset = dataset;
    this.split = split;
    this.config = config;
    this.options = options;
  }
  async fetchDataFromAPI(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Error fetching data: ${response.statusText}`);
      }
      const data = await response.json();
      if (!data?.rows) {
        throw new Error("Invalid data format");
      }
      return data.rows;
    } catch (error) {
      console.error("Error fetching data from API:", error);
      throw error;
    }
  }
  // https://datasets-server.huggingface.co/rows?dataset=hotpot_qa&config=distractor&split=train&offset=0&length=100
  async loadData() {
    const offset = this.options?.offset ?? 0;
    const length = this.options?.length ?? 100;
    const ds = encodeURIComponent(this.dataset);
    const url = `${this.baseUrl}?dataset=${ds}&config=${this.config}&split=${this.split}&offset=${offset}&length=${length}`;
    console.log("Downloading data from API.");
    this.rows = await this.fetchDataFromAPI(url);
    return this.rows;
  }
  setData(rows) {
    this.rows = rows;
  }
  getData() {
    return this.rows;
  }
  async getRows({
    count,
    fields,
    renameMap
  }) {
    if (this.rows.length === 0) {
      throw new Error("No data loaded, call loadData or setData first.");
    }
    const dataRows = this.rows.slice(0, count);
    return dataRows.map((item) => {
      const result = {};
      fields.forEach((field) => {
        const keys = field.split(".");
        let value = item.row;
        for (const key of keys) {
          if (Object.prototype.hasOwnProperty.call(
            value,
            key
          )) {
            value = value[key];
          }
        }
        if (!value) {
          return;
        }
        const resultFieldName = renameMap && field in renameMap ? renameMap[field] : field;
        if (!resultFieldName) {
          throw new Error(`Invalid field name: ${field}`);
        }
        result[resultFieldName] = value;
      });
      return result;
    }).filter((v) => Object.keys(v).length !== 0);
  }
};

// funcs/code.ts
import * as _crypto from "crypto";
import * as _http from "http";
import * as _https from "https";
import * as _fs from "node:fs";
import * as _os from "os";
import * as _process from "process";
import { runInNewContext } from "vm";
var AxJSInterpreterPermission = /* @__PURE__ */ ((AxJSInterpreterPermission2) => {
  AxJSInterpreterPermission2["FS"] = "node:fs";
  AxJSInterpreterPermission2["NET"] = "net";
  AxJSInterpreterPermission2["OS"] = "os";
  AxJSInterpreterPermission2["CRYPTO"] = "crypto";
  AxJSInterpreterPermission2["PROCESS"] = "process";
  return AxJSInterpreterPermission2;
})(AxJSInterpreterPermission || {});
var AxJSInterpreter = class {
  permissions;
  constructor({
    permissions = []
  } = {}) {
    this.permissions = permissions ?? [];
  }
  codeInterpreterJavascript(code) {
    const context = { console };
    if (this.permissions.includes("node:fs" /* FS */)) {
      context.fs = _fs;
    }
    if (this.permissions.includes("net" /* NET */)) {
      context.http = _http;
      context.https = _https;
    }
    if (this.permissions.includes("os" /* OS */)) {
      context.os = _os;
    }
    if (this.permissions.includes("crypto" /* CRYPTO */)) {
      context.crypto = _crypto;
    }
    if (this.permissions.includes("process" /* PROCESS */)) {
      context.process = _process;
    }
    return runInNewContext(`(function() { ${code} })()`, context);
  }
  toFunction() {
    return {
      name: "javascriptInterpreter",
      description: "Use this function to run Javascript code and get any expected return value",
      parameters: {
        type: "object",
        properties: {
          code: {
            type: "string",
            description: "JS code with a return value in the end."
          }
        },
        required: ["code"]
      },
      func: ({ code }) => this.codeInterpreterJavascript(code)
    };
  }
};

// dsp/router.ts
var colorLog4 = new ColorLog();
var AxRoute = class {
  name;
  context;
  constructor(name, context) {
    this.name = name;
    this.context = context;
  }
  getName() {
    return this.name;
  }
  getContext() {
    return this.context;
  }
};
var AxRouter = class {
  ai;
  db;
  debug;
  constructor(ai) {
    this.db = new AxDBMemory();
    this.ai = ai;
  }
  getState() {
    return this.db.getDB();
  }
  setState(state) {
    this.db.setDB(state);
  }
  setRoutes = async (routes) => {
    for (const ro of routes) {
      const ret = await this.ai.embed({ texts: ro.getContext() });
      await this.db.upsert({
        id: ro.getName(),
        table: "routes",
        values: ret.embeddings[0]
      });
    }
  };
  async forward(text, options) {
    const { embeddings } = await this.ai.embed({ texts: [text] });
    const matches = await this.db.query({
      table: "routes",
      values: embeddings[0]
    });
    let m = matches.matches;
    if (typeof options?.cutoff === "number") {
      const { cutoff } = options;
      m = m.filter((m2) => m2.score <= cutoff);
    }
    if (this.debug) {
      console.log(
        colorLog4.whiteBright(`query: ${text}`) + "\n" + colorLog4.greenBright(
          JSON.stringify(m.map((m2) => `${m2.id}, ${m2.score}`))
        )
      );
    }
    const route = m.at(0);
    if (!route) {
      return "";
    }
    return route.id;
  }
  setOptions(options) {
    if (typeof options.debug === "boolean") {
      this.debug = options.debug;
    }
  }
};

// dsp/evaluate.ts
var AxTestPrompt = class {
  ai;
  program;
  examples;
  constructor({
    ai,
    program,
    examples = []
  }) {
    if (examples.length == 0) {
      throw new Error("No examples found");
    }
    this.ai = ai;
    this.program = program;
    this.examples = examples;
  }
  async run(metricFn) {
    const st = (/* @__PURE__ */ new Date()).getTime();
    const total = this.examples.length;
    let successCount = 0;
    for (let i = 0; i < total; i++) {
      const ex = this.examples[i];
      if (!ex) {
        throw new Error("Invalid example");
      }
      const res = await this.program.forward(this.ai, ex);
      const success = metricFn({ prediction: res, example: ex });
      if (success) {
        successCount++;
      }
      const et = (/* @__PURE__ */ new Date()).getTime() - st;
      updateProgressBar(i, total, successCount, et, 30, "Testing Prompt");
    }
    console.log(
      "\nPerformance: ",
      successCount,
      "/",
      total,
      "Accuracy: ",
      successCount / total,
      "\n"
    );
  }
};

// prompts/cot.ts
var AxChainOfThought = class extends AxGen {
  constructor(signature, options) {
    const sig = new AxSignature(signature);
    const description = `Let's work this out in a step by step way in order to ensure we have the right answer.`;
    sig.setOutputFields([
      {
        name: "reason",
        description
      },
      ...sig.getOutputFields()
    ]);
    super(sig, options);
  }
};

// docs/rewriter.ts
var AxDefaultQueryRewriter = class extends AxGen {
  constructor(options) {
    const signature = `"You are a query rewriter assistant tasked with rewriting a given query to improve its clarity, specificity, and relevance. Your role involves analyzing the query to identify any ambiguities, generalizations, or irrelevant information and then rephrasing it to make it more focused and precise. The rewritten query should be concise, easy to understand, and directly related to the original query. Output only the rewritten query."
    query: string -> rewrittenQuery: string`;
    super(signature, options);
  }
};

// dsp/strutil.ts
var trimNonAlphaNum = (str) => {
  return str.replace(/^\W+|\W+$/g, "");
};
var splitIntoTwo = (str, separator) => {
  const index = str.search(separator);
  if (index === -1) {
    return [str];
  }
  const matchResult = str.match(separator);
  if (!matchResult) {
    throw new Error("Match failed unexpectedly.");
  }
  const firstPart = str.substring(0, index);
  const secondPart = str.substring(index + matchResult[0].length);
  return [firstPart, secondPart];
};
var dedup = (seq) => {
  const seen = /* @__PURE__ */ new Set();
  const result = [];
  for (const x of seq) {
    if (!seen.has(x)) {
      seen.add(x);
      result.push(x);
    }
  }
  return result;
};
var extractIdAndText = (input) => {
  const match = input.match(/^(\d+)[.,\s]+(.*)$/);
  if (!match || match.length < 3) {
    throw new Error(
      'line must start with a number, a dot and then text. e.g. "1. hello"'
    );
  }
  const id = parseInt(match[1], 10);
  const text = match[2].trim();
  return { id, text };
};
var extractIndexPrefixedText = (input) => {
  const match = input.match(/^(\d+)[.,\s]+(.*)$/);
  if (match && match[2] !== void 0) {
    return match[2].trim();
  }
  return input;
};
var batchArray = (arr, size) => {
  const chunkedArr = [];
  for (let i = 0; i < arr.length; i += size) {
    chunkedArr.push(arr.slice(i, i + size));
  }
  return chunkedArr;
};
var axStringUtil = {
  trimNonAlphaNum,
  splitIntoTwo,
  dedup,
  extractIdAndText,
  extractIndexPrefixedText,
  batchArray
};

// docs/reranker.ts
var AxDefaultResultReranker = class extends AxGen {
  constructor(options) {
    const signature = `"You are a re-ranker assistant tasked with evaluating a set of content items in relation to a specific question. Your role involves critically analyzing each content item to determine its relevance to the question and re-ranking them accordingly. This process includes assigning a relevance score from 0 to 10 to each content item based on how well it answers the question, its coverage of the topic, and the reliability of its information. This re-ranked list should start with the content item that is most relevant to the question and end with the least relevant. Output only the list."
    query: string, items: string[] -> rankedItems: string[] "list of id, 5-words Rationale, relevance score"`;
    super(signature, options);
  }
  forward = async (ai, input, options) => {
    const { rankedItems } = await super.forward(ai, input, options);
    const sortedIndexes = rankedItems.map((item) => {
      const { id: index } = axStringUtil.extractIdAndText(item);
      return index;
    });
    const sortedItems = input.items.map((_, index) => {
      const originalIndex = sortedIndexes[index];
      return originalIndex !== void 0 ? input.items[originalIndex] : void 0;
    }).filter((item) => item !== void 0);
    return { rankedItems: sortedItems };
  };
};

// funcs/embed.ts
var AxEmbeddingAdapter = class {
  aiService;
  info;
  func;
  constructor({
    ai,
    info,
    func
  }) {
    this.aiService = ai;
    this.info = info;
    this.func = func;
  }
  async embedAdapter(text, extra) {
    const embedRes = await this.aiService.embed(
      { texts: [text] },
      { sessionId: extra?.sessionId }
    );
    const embeds = embedRes.embeddings.at(0);
    if (!embeds) {
      throw new Error("Failed to embed text");
    }
    return this.func.length === 2 ? this.func(embeds, extra) : this.func(embeds);
  }
  toFunction() {
    return {
      name: this.info.name,
      description: this.info.description,
      parameters: {
        type: "object",
        properties: {
          text: {
            type: "string",
            description: this.info.argumentDescription
          }
        },
        required: ["text"]
      },
      func: ({ text }, options) => this.embedAdapter(text, options)
    };
  }
};

// prompts/rag.ts
var AxRAG = class extends AxChainOfThought {
  genQuery;
  queryFn;
  maxHops;
  constructor(queryFn, options) {
    const sig = '"Answer questions with short factoid answers." context:string[] "may contain relevant facts", question -> answer';
    super(sig, options);
    this.maxHops = options?.maxHops ?? 3;
    const qsig = new AxSignature(
      '"Write a simple search query that will help answer a complex question." context?:string[] "may contain relevant facts", question -> query "question to further our understanding"'
    );
    this.genQuery = new AxGen(qsig);
    this.queryFn = queryFn;
    this.register(this.genQuery);
  }
  async forward(ai, { question }, options) {
    let context = [];
    for (let i = 0; i < this.maxHops; i++) {
      const { query } = await this.genQuery.forward(
        ai,
        {
          context,
          question
        },
        options
      );
      const val = await this.queryFn(query);
      context = axStringUtil.dedup([...context, val]);
    }
    return super.forward(ai, { context, question }, options);
  }
};
export {
  AxAI,
  AxAIAnthropic,
  AxAIAnthropicModel,
  AxAIAzureOpenAI,
  AxAICohere,
  AxAICohereEmbedModel,
  AxAICohereModel,
  AxAIDeepSeek,
  AxAIDeepSeekModel,
  AxAIGoogleGemini,
  AxAIGoogleGeminiEmbedModel,
  AxAIGoogleGeminiModel,
  AxAIGoogleGeminiSafetyCategory,
  AxAIGoogleGeminiSafetyThreshold,
  AxAIGroq,
  AxAIGroqModel,
  AxAIHuggingFace,
  AxAIHuggingFaceModel,
  AxAIMistral,
  AxAIMistralEmbedModels,
  AxAIMistralModel,
  AxAIOllama,
  AxAIOpenAI,
  AxAIOpenAIEmbedModel,
  AxAIOpenAIModel,
  AxAIReka,
  AxAIRekaModel,
  AxAITogether,
  AxAgent,
  AxApacheTika,
  AxAssertionError,
  AxBalancer,
  AxBaseAI,
  AxBootstrapFewShot,
  AxChainOfThought,
  AxDB,
  AxDBBase,
  AxDBCloudflare,
  AxDBManager,
  AxDBMemory,
  AxDBPinecone,
  AxDBWeaviate,
  AxDefaultQueryRewriter,
  AxDefaultResultReranker,
  AxDockerSession,
  AxEmbeddingAdapter,
  AxFunctionProcessor,
  AxGen,
  AxHFDataLoader,
  AxInstanceRegistry,
  AxJSInterpreter,
  AxJSInterpreterPermission,
  AxLLMRequestTypeValues,
  AxMemory,
  AxProgram,
  AxProgramWithSignature,
  AxPromptTemplate,
  AxRAG,
  AxRateLimiterTokenUsage,
  AxRoute,
  AxRouter,
  AxSignature,
  AxSpanKindValues,
  AxTestPrompt,
  AxValidationError
};
//# sourceMappingURL=index.js.map
{"version":3,"sources":["../ai/base.ts","../dsp/modelinfo.ts","../trace/trace.ts","../util/apicall.ts","../util/sse.ts","../util/stream.ts","../util/log.ts","../util/transform.ts","../ai/anthropic/types.ts","../ai/anthropic/info.ts","../ai/anthropic/api.ts","../ai/openai/types.ts","../ai/openai/info.ts","../ai/openai/api.ts","../ai/azure-openai/api.ts","../ai/cohere/types.ts","../ai/cohere/info.ts","../ai/cohere/api.ts","../ai/deepseek/types.ts","../ai/deepseek/info.ts","../ai/deepseek/api.ts","../ai/google-gemini/types.ts","../ai/google-gemini/info.ts","../ai/google-gemini/api.ts","../util/rate-limit.ts","../ai/groq/types.ts","../ai/groq/info.ts","../ai/groq/api.ts","../ai/huggingface/info.ts","../ai/huggingface/types.ts","../ai/huggingface/api.ts","../ai/mistral/types.ts","../ai/mistral/info.ts","../ai/mistral/api.ts","../ai/ollama/api.ts","../ai/reka/types.ts","../ai/reka/info.ts","../ai/reka/api.ts","../ai/together/info.ts","../ai/together/api.ts","../ai/wrap.ts","../prompts/agent.ts","../dsp/generate.ts","../ai/util.ts","../mem/memory.ts","../dsp/asserts.ts","../dsp/extract.ts","../dsp/datetime.ts","../dsp/program.ts","../dsp/registry.ts","../dsp/sig.ts","../dsp/parser.ts","../dsp/util.ts","../dsp/prompt.ts","../dsp/validate.ts","../dsp/functions.ts","../dsp/jsonschema.ts","../docs/tika.ts","../ai/balance.ts","../dsp/optimize.ts","../db/base.ts","../db/cloudflare.ts","../db/memory.ts","../db/pinecone.ts","../db/weaviate.ts","../db/wrap.ts","../docs/manager.ts","../funcs/docker.ts","../dsp/loader.ts","../funcs/code.ts","../dsp/router.ts","../dsp/evaluate.ts","../prompts/cot.ts","../docs/rewriter.ts","../dsp/strutil.ts","../docs/reranker.ts","../funcs/embed.ts","../prompts/rag.ts"],"sourcesContent":["import type { ReadableStream } from 'stream/web'\n\nimport { type Span, SpanKind } from '@opentelemetry/api'\n\nimport { getModelInfo } from '../dsp/modelinfo.js'\nimport { axSpanAttributes } from '../trace/trace.js'\nimport { apiCall } from '../util/apicall.js'\nimport { ColorLog } from '../util/log.js'\nimport { RespTransformStream } from '../util/transform.js'\n\nimport type {\n  AxAIModelMap,\n  AxAIPromptConfig,\n  AxAIService,\n  AxAIServiceActionOptions,\n  AxAIServiceImpl,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxModelConfig,\n  AxModelInfo,\n  AxModelInfoWithProvider,\n  AxTokenUsage,\n} from './types.js'\n\nconst colorLog = new ColorLog()\n\nexport interface AxBaseAIFeatures {\n  functions: boolean\n  streaming: boolean\n}\n\nexport interface AxBaseAIArgs {\n  name: string\n  apiURL: string\n  headers: Record<string, string>\n  modelInfo: Readonly<AxModelInfo[]>\n  models: Readonly<{ model: string; embedModel?: string }>\n  options?: Readonly<AxAIServiceOptions>\n  supportFor: AxBaseAIFeatures | ((model: string) => AxBaseAIFeatures)\n  modelMap?: AxAIModelMap\n}\n\nexport const axBaseAIDefaultConfig = (): AxModelConfig =>\n  structuredClone({\n    maxTokens: 2000,\n    temperature: 0,\n    topK: 40,\n    frequencyPenalty: 0.2,\n  })\n\nexport const axBaseAIDefaultCreativeConfig = (): AxModelConfig =>\n  structuredClone({\n    maxTokens: 500,\n    temperature: 0.4,\n    topP: 0.7,\n    frequencyPenalty: 0.2,\n    presencePenalty: 0.2,\n  })\n\nexport class AxBaseAI<\n  TChatRequest,\n  TEmbedRequest,\n  TChatResponse,\n  TChatResponseDelta,\n  TEmbedResponse,\n> implements AxAIService\n{\n  private debug = false\n\n  private rt?: AxAIServiceOptions['rateLimiter']\n  private fetch?: AxAIServiceOptions['fetch']\n  private tracer?: AxAIServiceOptions['tracer']\n  private modelMap?: AxAIModelMap\n\n  private modelInfo: readonly AxModelInfo[]\n  private modelUsage?: AxTokenUsage\n  private embedModelUsage?: AxTokenUsage\n  private models: AxBaseAIArgs['models']\n\n  protected apiURL: string\n  protected name: string\n  protected headers: Record<string, string>\n  protected supportFor: AxBaseAIFeatures | ((model: string) => AxBaseAIFeatures)\n\n  // Add private metrics tracking properties\n  private metrics: AxAIServiceMetrics = {\n    latency: {\n      chat: {\n        mean: 0,\n        p95: 0,\n        p99: 0,\n        samples: [],\n      },\n      embed: {\n        mean: 0,\n        p95: 0,\n        p99: 0,\n        samples: [],\n      },\n    },\n    errors: {\n      chat: {\n        count: 0,\n        rate: 0,\n        total: 0,\n      },\n      embed: {\n        count: 0,\n        rate: 0,\n        total: 0,\n      },\n    },\n  }\n\n  constructor(\n    private readonly aiImpl: Readonly<\n      AxAIServiceImpl<\n        TChatRequest,\n        TEmbedRequest,\n        TChatResponse,\n        TChatResponseDelta,\n        TEmbedResponse\n      >\n    >,\n    {\n      name,\n      apiURL,\n      headers,\n      modelInfo,\n      models,\n      options = {},\n      supportFor,\n      modelMap,\n    }: Readonly<AxBaseAIArgs>\n  ) {\n    this.name = name\n    this.apiURL = apiURL\n    this.headers = headers\n    this.supportFor = supportFor\n    this.tracer = options.tracer\n    this.modelInfo = modelInfo\n    this.modelMap = modelMap\n    this.models = {\n      model: modelMap?.[models.model] ?? models.model,\n      embedModel: modelMap?.[models.embedModel ?? ''] ?? models.embedModel,\n    }\n\n    if (\n      !models.model ||\n      typeof models.model !== 'string' ||\n      models.model === ''\n    ) {\n      throw new Error('No model defined')\n    }\n\n    this.setOptions(options)\n  }\n\n  public setName(name: string): void {\n    this.name = name\n  }\n\n  public setAPIURL(apiURL: string): void {\n    this.apiURL = apiURL\n  }\n\n  public setHeaders(headers: Record<string, string>): void {\n    this.headers = headers\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    if (options.debug) {\n      this.debug = options.debug\n    }\n\n    if (options.rateLimiter) {\n      this.rt = options.rateLimiter\n    }\n\n    if (options.fetch) {\n      this.fetch = options.fetch\n    }\n\n    if (options.tracer) {\n      this.tracer = options.tracer\n    }\n  }\n\n  getModelInfo(): Readonly<AxModelInfoWithProvider> {\n    const mi = getModelInfo({\n      model: this.models.model,\n      modelInfo: this.modelInfo,\n      modelMap: this.modelMap,\n    })\n    return {\n      ...mi,\n      provider: this.name,\n    }\n  }\n\n  getEmbedModelInfo(): AxModelInfoWithProvider | undefined {\n    if (!this.models.embedModel) {\n      return\n    }\n\n    const mi = getModelInfo({\n      model: this.models.embedModel,\n      modelInfo: this.modelInfo,\n      modelMap: this.modelMap,\n    })\n    return {\n      ...mi,\n      provider: this.name,\n    }\n  }\n\n  getModelMap(): AxAIModelMap | undefined {\n    return this.modelMap\n  }\n\n  getName(): string {\n    return this.name\n  }\n\n  getFeatures(model?: string): AxBaseAIFeatures {\n    return typeof this.supportFor === 'function'\n      ? this.supportFor(model ?? this.models.model)\n      : this.supportFor\n  }\n\n  // Method to calculate percentiles\n  private calculatePercentile(\n    samples: readonly number[],\n    percentile: number\n  ): number {\n    if (samples.length === 0) return 0\n    const sorted = [...samples].sort((a, b) => a - b)\n    const index = Math.ceil((percentile / 100) * sorted.length) - 1\n    return sorted[index] ?? 0\n  }\n\n  // Method to update latency metrics\n  private updateLatencyMetrics(type: 'chat' | 'embed', duration: number): void {\n    const metrics = this.metrics.latency[type]\n    metrics.samples.push(duration)\n\n    // Keep only last 1000 samples to prevent memory issues\n    if (metrics.samples.length > 1000) {\n      metrics.samples.shift()\n    }\n\n    // Update statistics\n    metrics.mean =\n      metrics.samples.reduce((a, b) => a + b, 0) / metrics.samples.length\n    metrics.p95 = this.calculatePercentile(metrics.samples, 95)\n    metrics.p99 = this.calculatePercentile(metrics.samples, 99)\n  }\n\n  // Method to update error metrics\n  private updateErrorMetrics(type: 'chat' | 'embed', isError: boolean): void {\n    const metrics = this.metrics.errors[type]\n    metrics.total++\n    if (isError) {\n      metrics.count++\n    }\n    metrics.rate = metrics.count / metrics.total\n  }\n\n  // Public method to get metrics\n  public getMetrics(): AxAIServiceMetrics {\n    return structuredClone(this.metrics)\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest>,\n    options?: Readonly<AxAIPromptConfig & AxAIServiceActionOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    const startTime = performance.now()\n    let isError = false\n\n    try {\n      return this._chat1(req, options)\n    } catch (error) {\n      isError = true\n      throw error\n    } finally {\n      const duration = performance.now() - startTime\n      this.updateLatencyMetrics('chat', duration)\n      this.updateErrorMetrics('chat', isError)\n    }\n  }\n\n  private async _chat1(\n    req: Readonly<AxChatRequest>,\n    options?: Readonly<AxAIPromptConfig & AxAIServiceActionOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    const model = req.model\n      ? (this.modelMap?.[req.model] ?? req.model)\n      : (this.modelMap?.[this.models.model] ?? this.models.model)\n\n    const modelConfig = {\n      ...this.aiImpl.getModelConfig(),\n      ...req.modelConfig,\n    }\n\n    // stream is true by default unless explicitly set to false\n    modelConfig.stream =\n      (options?.stream !== undefined ? options.stream : modelConfig.stream) ??\n      true\n\n    const canStream = this.getFeatures(model).streaming\n    if (!canStream) {\n      modelConfig.stream = false\n    }\n\n    if (this.tracer) {\n      return await this.tracer?.startActiveSpan(\n        'Chat Request',\n        {\n          kind: SpanKind.SERVER,\n          attributes: {\n            [axSpanAttributes.LLM_SYSTEM]: this.name,\n            [axSpanAttributes.LLM_REQUEST_MODEL]: model,\n            [axSpanAttributes.LLM_REQUEST_MAX_TOKENS]: modelConfig.maxTokens,\n            [axSpanAttributes.LLM_REQUEST_TEMPERATURE]: modelConfig.temperature,\n            [axSpanAttributes.LLM_REQUEST_TOP_P]: modelConfig.topP,\n            [axSpanAttributes.LLM_REQUEST_TOP_K]: modelConfig.topK,\n            [axSpanAttributes.LLM_REQUEST_FREQUENCY_PENALTY]:\n              modelConfig.frequencyPenalty,\n            [axSpanAttributes.LLM_REQUEST_PRESENCE_PENALTY]:\n              modelConfig.presencePenalty,\n            [axSpanAttributes.LLM_REQUEST_STOP_SEQUENCES]:\n              modelConfig.stopSequences?.join(', '),\n            [axSpanAttributes.LLM_REQUEST_LLM_IS_STREAMING]: modelConfig.stream,\n            // [AxSpanAttributes.LLM_PROMPTS]: _req.chatPrompt\n            //   ?.map((v) => v.content)\n            //   .join('\\n')\n          },\n        },\n        async (span) => {\n          const res = await this._chat2(model, modelConfig, req, options, span)\n          span.end()\n          return res\n        }\n      )\n    }\n    return await this._chat2(model, modelConfig, req, options)\n  }\n\n  private async _chat2(\n    model: string,\n    modelConfig: Readonly<AxModelConfig>,\n    chatReq: Readonly<Omit<AxChatRequest, 'modelConfig'>>,\n    options?: Readonly<AxAIServiceActionOptions>,\n    span?: Span\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    if (!this.aiImpl.createChatReq) {\n      throw new Error('generateChatReq not implemented')\n    }\n\n    let functions\n    if (chatReq.functions && chatReq.functions.length > 0) {\n      functions = chatReq.functions\n    }\n\n    const req = {\n      ...chatReq,\n      model,\n      functions,\n      modelConfig,\n    }\n\n    const fn = async () => {\n      const [apiConfig, reqValue] = this.aiImpl.createChatReq(\n        req,\n        options as AxAIPromptConfig\n      )\n\n      const res = await apiCall(\n        {\n          name: apiConfig.name,\n          url: this.apiURL,\n          headers: this.buildHeaders(apiConfig.headers),\n          stream: modelConfig.stream,\n          debug: this.debug,\n          fetch: this.fetch,\n          span,\n        },\n        reqValue\n      )\n      return res\n    }\n\n    if (this.debug) {\n      logChatRequest(req)\n    }\n\n    const rt = options?.rateLimiter ?? this.rt\n    const rv = rt ? await rt(fn, { modelUsage: this.modelUsage }) : await fn()\n\n    if (modelConfig.stream) {\n      if (!this.aiImpl.createChatStreamResp) {\n        throw new Error('generateChatResp not implemented')\n      }\n\n      const respFn = this.aiImpl.createChatStreamResp\n      const wrappedRespFn =\n        (state: object) => (resp: Readonly<TChatResponseDelta>) => {\n          const res = respFn(resp, state)\n          res.sessionId = options?.sessionId\n\n          if (res.modelUsage) {\n            this.modelUsage = res.modelUsage\n          }\n\n          if (span?.isRecording()) {\n            setResponseAttr(res, span)\n          }\n\n          if (this.debug) {\n            logResponse(res)\n          }\n          return res\n        }\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const doneCb = async (_values: readonly AxChatResponse[]) => {\n        if (this.debug) {\n          process.stdout.write('\\n')\n        }\n      }\n\n      const st = (rv as ReadableStream<TChatResponseDelta>).pipeThrough(\n        new RespTransformStream<TChatResponseDelta, AxChatResponse>(\n          wrappedRespFn({}),\n          doneCb\n        )\n      )\n      return st\n    }\n\n    if (!this.aiImpl.createChatResp) {\n      throw new Error('generateChatResp not implemented')\n    }\n    const res = this.aiImpl.createChatResp(rv as TChatResponse)\n    res.sessionId = options?.sessionId\n\n    if (res.modelUsage) {\n      this.modelUsage = res.modelUsage\n    }\n\n    if (span?.isRecording()) {\n      setResponseAttr(res, span)\n    }\n\n    if (this.debug) {\n      logResponse(res)\n    }\n\n    span?.end()\n    return res\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest>,\n    options?: Readonly<AxAIServiceActionOptions>\n  ): Promise<AxEmbedResponse> {\n    const startTime = performance.now()\n    let isError = false\n\n    try {\n      return this._embed1(req, options)\n    } catch (error) {\n      isError = true\n      throw error\n    } finally {\n      const duration = performance.now() - startTime\n      this.updateLatencyMetrics('embed', duration)\n      this.updateErrorMetrics('embed', isError)\n    }\n  }\n\n  private async _embed1(\n    req: Readonly<AxEmbedRequest>,\n    options?: Readonly<AxAIServiceActionOptions>\n  ): Promise<AxEmbedResponse> {\n    const embedModel = req.embedModel\n      ? (this.modelMap?.[req.embedModel] ?? req.embedModel)\n      : (this.modelMap?.[this.models.embedModel ?? ''] ??\n        this.models.embedModel)\n\n    if (!embedModel) {\n      throw new Error('No embed model defined')\n    }\n\n    if (this.tracer) {\n      await this.tracer?.startActiveSpan(\n        'Embed Request',\n        {\n          kind: SpanKind.SERVER,\n          attributes: {\n            [axSpanAttributes.LLM_SYSTEM]: this.name,\n            [axSpanAttributes.LLM_REQUEST_MODEL]:\n              req.embedModel ?? this.models.embedModel,\n          },\n        },\n        async (span) => {\n          const res = await this._embed2(embedModel, req, options, span)\n          span.end()\n          return res\n        }\n      )\n    }\n    return this._embed2(embedModel, req, options)\n  }\n\n  private async _embed2(\n    embedModel: string,\n    embedReq: Readonly<AxEmbedRequest>,\n    options?: Readonly<AxAIServiceActionOptions>,\n    span?: Span\n  ): Promise<AxEmbedResponse> {\n    if (!this.aiImpl.createEmbedReq) {\n      throw new Error('generateEmbedReq not implemented')\n    }\n    if (!this.aiImpl.createEmbedResp) {\n      throw new Error('generateEmbedResp not implemented')\n    }\n\n    const req = {\n      ...embedReq,\n      embedModel,\n    }\n\n    const fn = async () => {\n      const [apiConfig, reqValue] = this.aiImpl.createEmbedReq!(req)\n\n      const res = await apiCall(\n        {\n          name: apiConfig.name,\n          url: this.apiURL,\n          headers: this.buildHeaders(apiConfig.headers),\n          debug: this.debug,\n          fetch: this.fetch,\n          span,\n        },\n        reqValue\n      )\n\n      return res\n    }\n\n    const resValue = this.rt\n      ? await this.rt(fn, { embedModelUsage: this.embedModelUsage })\n      : await fn()\n    const res = this.aiImpl.createEmbedResp!(resValue as TEmbedResponse)\n\n    res.sessionId = options?.sessionId\n\n    if (span?.isRecording()) {\n      if (res.modelUsage) {\n        this.embedModelUsage = res.modelUsage\n        span.setAttributes({\n          [axSpanAttributes.LLM_USAGE_COMPLETION_TOKENS]:\n            res.modelUsage.completionTokens ?? 0,\n          [axSpanAttributes.LLM_USAGE_PROMPT_TOKENS]:\n            res.modelUsage.promptTokens,\n        })\n      }\n    }\n\n    span?.end()\n    return res\n  }\n\n  private buildHeaders(\n    headers: Record<string, string> = {}\n  ): Record<string, string> {\n    return { ...headers, ...this.headers }\n  }\n}\n\nconst logChatRequest = (req: Readonly<AxChatRequest>) => {\n  const items = req.chatPrompt?.map((msg) => {\n    switch (msg.role) {\n      case 'system':\n        return `${colorLog.blueBright('System:')}\\n${colorLog.whiteBright(msg.content)}`\n      case 'function':\n        return `${colorLog.blueBright('\\nFunction Result:')}\\n${colorLog.whiteBright(msg.result)}`\n      case 'user': {\n        if (typeof msg.content === 'string') {\n          return `${colorLog.blueBright('\\nUser:')}\\n${colorLog.whiteBright(msg.content)}`\n        }\n        const items = msg.content.map((v) => {\n          switch (v.type) {\n            case 'text':\n              return `(Text) ${colorLog.whiteBright(v.text)}`\n            case 'image':\n              return `(Image, ${v.mimeType}) ${colorLog.whiteBright(v.image.substring(0, 10))}`\n            default:\n              throw new Error('Invalid content type')\n          }\n        })\n        return `${colorLog.blueBright('\\nUser:')}\\n${items.join('\\n')}`\n      }\n      case 'assistant': {\n        if (msg.functionCalls) {\n          const fns = msg.functionCalls?.map(({ function: fn }) => {\n            const args =\n              typeof fn.params !== 'string'\n                ? JSON.stringify(fn.params, null, 2)\n                : fn.params\n            return `${fn.name}(${args})`\n          })\n          return `${colorLog.blueBright('\\nFunctions:')}\\n${colorLog.whiteBright(fns.join('\\n'))}`\n        }\n        return `${colorLog.blueBright('\\nAssistant:')}\\n${colorLog.whiteBright(msg.content ?? '<empty>')}`\n      }\n      default:\n        throw new Error('Invalid role')\n    }\n  })\n\n  if (items) {\n    console.log('\\n==========')\n    console.log(items.join('\\n'))\n  }\n}\n\nconst logResponse = (resp: Readonly<AxChatResponse>) => {\n  if (!resp.results) {\n    return\n  }\n  for (const r of resp.results) {\n    if (r.content) {\n      process.stdout.write(colorLog.greenBright(r.content))\n    }\n    if (r.functionCalls) {\n      for (const [i, f] of r.functionCalls.entries()) {\n        if (f.function.name) {\n          if (i > 0) {\n            process.stdout.write('\\n\\n')\n          }\n          process.stdout.write(\n            `Function ${i + 1} -> ${colorLog.greenBright(f.function.name)} `\n          )\n        }\n        if (f.function.params) {\n          const params =\n            typeof f.function.params === 'string'\n              ? f.function.params\n              : JSON.stringify(f.function.params, null, 2)\n          process.stdout.write(`${colorLog.greenBright(params)}`)\n        }\n      }\n    }\n  }\n}\n\nconst setResponseAttr = (res: Readonly<AxChatResponse>, span: Span) => {\n  if (res.modelUsage) {\n    span.setAttributes({\n      [axSpanAttributes.LLM_USAGE_COMPLETION_TOKENS]:\n        res.modelUsage.completionTokens ?? 0,\n      [axSpanAttributes.LLM_USAGE_PROMPT_TOKENS]: res.modelUsage.promptTokens,\n    })\n  }\n}\n","import type { AxModelInfo } from '../ai/types.js'\n\ninterface GetModelInfoParams {\n  model: string\n  modelInfo: readonly AxModelInfo[]\n  modelMap?: Record<string, string>\n}\n\nexport function getModelInfo({\n  model,\n  modelInfo,\n  modelMap = {},\n}: Readonly<GetModelInfoParams>): Readonly<AxModelInfo> {\n  // First check if there's a mapping for this model\n  const mappedModel = modelMap?.[model] ?? model\n\n  // Try exact match first\n  const exactMatch = modelInfo.find((v) => v.name === model)\n  if (exactMatch) return exactMatch\n\n  // Handle normalization if no exact match\n  const normalizedName = mappedModel\n    // Remove vendor prefixes\n    .replace(/^(anthropic\\.|openai\\.)/, '')\n    // Remove various postfixes one by one, stopping after first match\n    .replace(/-latest$/, '')\n    .replace(/-\\d{8}$/, '') // YYYYMMDD\n    .replace(/-v\\d+:\\d+$/, '') // v2:0\n    .replace(/@\\d{8}$/, '') // @YYYYMMDD\n    .replace(/-\\d{2,}(-[a-zA-Z0-9-]+)?$/, '') // XX or XXXXX-something\n    .replace(/-v\\d+@\\d{8}$/, '') // vX@YYYYMMDD\n    .replace(/-v\\d+$/, '') // Remove standalone version number\n\n  // Try to find a match with the normalized name\n  const normalizedMatch = modelInfo.find((v) => v.name === normalizedName)\n  if (normalizedMatch) return normalizedMatch\n\n  // Return default if no match found\n  return {\n    name: model,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n  }\n}\n","export const axSpanAttributes = {\n  // LLM\n  LLM_SYSTEM: 'gen_ai.system',\n  LLM_REQUEST_MODEL: 'gen_ai.request.model',\n  LLM_REQUEST_MAX_TOKENS: 'gen_ai.request.max_tokens',\n  LLM_REQUEST_TEMPERATURE: 'gen_ai.request.temperature',\n  LLM_REQUEST_TOP_K: 'gen_ai.request.top_k',\n  LLM_REQUEST_FREQUENCY_PENALTY: 'gen_ai.request.frequency_penalty',\n  LLM_REQUEST_PRESENCE_PENALTY: 'gen_ai.request.presence_penalty',\n  LLM_REQUEST_STOP_SEQUENCES: 'gen_ai.request.stop_sequences',\n  LLM_REQUEST_LLM_IS_STREAMING: 'gen_ai.request.llm_is_streaming',\n  LLM_REQUEST_TOP_P: 'gen_ai.request.top_p',\n\n  LLM_USAGE_PROMPT_TOKENS: 'gen_ai.usage.prompt_tokens',\n  LLM_USAGE_COMPLETION_TOKENS: 'gen_ai.usage.completion_tokens',\n\n  // Vector DB\n  DB_SYSTEM: 'db.system',\n  DB_TABLE: 'db.table',\n  DB_NAMESPACE: 'db.namespace',\n  DB_ID: 'db.id',\n  DB_QUERY_TEXT: 'db.query.text',\n  DB_VECTOR: 'db.vector',\n  DB_OPERATION_NAME: 'db.operation.name',\n  DB_VECTOR_QUERY_TOP_K: 'db.vector.query.top_k',\n\n  DB_QUERY_EMBEDDINGS: 'db.query.embeddings',\n  DB_QUERY_RESULT: 'db.query.result',\n\n  // Query Embeddings\n  DB_QUERY_EMBEDDINGS_VECTOR: 'db.query.embeddings.vector',\n\n  // Query Result (canonical format)\n  DB_QUERY_RESULT_ID: 'db.query.result.id',\n  DB_QUERY_RESULT_SCORE: 'db.query.result.score',\n  DB_QUERY_RESULT_DISTANCE: 'db.query.result.distance',\n  DB_QUERY_RESULT_METADATA: 'db.query.result.metadata',\n  DB_QUERY_RESULT_VECTOR: 'db.query.result.vector',\n  DB_QUERY_RESULT_DOCUMENT: 'db.query.result.document',\n}\n\nexport const axSpanEvents = {\n  LLM_PROMPT: 'gen_ai.prompt',\n}\n\nexport enum AxLLMRequestTypeValues {\n  COMPLETION = 'completion',\n  CHAT = 'chat',\n  RERANK = 'rerank',\n  UNKNOWN = 'unknown',\n}\n\nexport enum AxSpanKindValues {\n  WORKFLOW = 'workflow',\n  TASK = 'task',\n  AGENT = 'agent',\n  TOOL = 'tool',\n  UNKNOWN = 'unknown',\n}\n","import path from 'path'\nimport {\n  type ReadableStream,\n  TextDecoderStream as TextDecoderStreamNative,\n} from 'stream/web'\n\nimport { type Span } from '@opentelemetry/api'\n\nimport { SSEParser } from './sse.js'\nimport { TextDecoderStreamPolyfill } from './stream.js'\n\n/**\n * Util: API details\n */\nexport type AxAPI = {\n  name?: string\n  headers?: Record<string, string>\n  put?: boolean\n}\n\nconst textDecoderStream = TextDecoderStreamNative ?? TextDecoderStreamPolyfill\n\nexport const apiCall = async <TRequest = unknown, TResponse = unknown>(\n  api: Readonly<\n    AxAPI & {\n      url: string | URL\n      stream?: boolean\n      debug?: boolean\n      fetch?: typeof fetch\n      span?: Span\n    }\n  >,\n  json: TRequest\n): Promise<TResponse | ReadableStream<TResponse>> => {\n  const baseUrl = new URL(process.env['PROXY'] ?? api.url)\n  const apiPath = path.join(baseUrl.pathname, api.name ?? '/', baseUrl.search)\n  const apiUrl = new URL(apiPath, baseUrl)\n\n  if (api.span?.isRecording()) {\n    api.span.setAttributes({\n      'http.request.method': api.put ? 'PUT' : 'POST',\n      'url.full': apiUrl.href,\n    })\n  }\n\n  let res: Response | ReadableStream<TResponse> | undefined\n\n  try {\n    res = await (api.fetch ?? fetch)(apiUrl, {\n      method: api.put ? 'PUT' : 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        ...api.headers,\n      },\n      body: JSON.stringify(json),\n    })\n\n    if (res.status >= 400) {\n      const reqBody = JSON.stringify(json, null, 2)\n      throw new Error(\n        `API Request Error: ${res.status}, ${res.statusText}\\n:Request Body: ${reqBody}`\n      )\n    }\n\n    if (!api.stream) {\n      const resJson = await res.json()\n      return resJson as TResponse\n    }\n\n    if (!res.body) {\n      throw new Error('Response body is null')\n    }\n\n    const st = res.body\n      .pipeThrough(new textDecoderStream())\n      .pipeThrough(new SSEParser<TResponse>())\n\n    return st\n  } catch (e) {\n    if (api.span?.isRecording()) {\n      api.span.recordException(e as Error)\n    }\n\n    const reqBody = JSON.stringify(json, null, 2)\n    throw new Error(\n      `API Response Error: ${apiUrl.href}, ${e}\\nRequest Body: ${reqBody}`\n    )\n  }\n}\n","import { TransformStream, TransformStreamDefaultController } from 'stream/web'\n\ninterface CurrentEventState {\n  event?: string\n  rawData: string\n  id?: string\n  retry?: number\n}\n\nexport class SSEParser<T = unknown> extends TransformStream<string, T> {\n  private buffer: string = ''\n  private currentEvent: CurrentEventState = { rawData: '' }\n\n  constructor(private readonly dataParser: (data: string) => T = JSON.parse) {\n    super({\n      transform: (chunk, controller) => this.handleChunk(chunk, controller),\n      flush: (controller) => this.handleFlush(controller),\n    })\n  }\n\n  private handleChunk(\n    chunk: string,\n    controller: TransformStreamDefaultController<T>\n  ): void {\n    this.buffer += chunk\n    this.processBuffer(controller)\n  }\n\n  private handleFlush(controller: TransformStreamDefaultController<T>): void {\n    this.processBuffer(controller)\n    if (this.currentEvent.rawData) {\n      this.emitEvent(controller)\n    }\n  }\n\n  private processBuffer(controller: TransformStreamDefaultController<T>): void {\n    const lines = this.buffer.split(/\\r\\n|\\r|\\n/)\n    this.buffer = lines.pop() || ''\n\n    for (const line of lines) {\n      if (line.trim() === '') {\n        this.emitEvent(controller)\n      } else {\n        this.parseLine(line)\n      }\n    }\n  }\n\n  private parseLine(line: string): void {\n    const colonIndex = line.indexOf(':')\n    if (colonIndex === -1) {\n      // If there's no colon, treat the whole line as data\n      this.currentEvent.rawData += this.currentEvent.rawData\n        ? '\\n' + line.trim()\n        : line.trim()\n      return\n    }\n\n    const field = line.slice(0, colonIndex).trim()\n    const value = line.slice(colonIndex + 1).trim()\n\n    switch (field) {\n      case 'event':\n        this.currentEvent.event = value\n        break\n      case 'data':\n        this.currentEvent.rawData += this.currentEvent.rawData\n          ? '\\n' + value\n          : value\n        break\n      case 'id':\n        this.currentEvent.id = value\n        break\n      case 'retry': {\n        const retryValue = parseInt(value, 10)\n        if (!isNaN(retryValue)) {\n          this.currentEvent.retry = retryValue\n        }\n        break\n      }\n    }\n  }\n\n  private emitEvent(controller: TransformStreamDefaultController<T>): void {\n    if (this.currentEvent.rawData) {\n      // Check for special \"[DONE]\" message or other non-JSON data\n      if (\n        this.currentEvent.rawData.trim() === '[DONE]' ||\n        this.currentEvent.rawData.trim().startsWith('[')\n      ) {\n        return\n      } else {\n        try {\n          // Attempt to parse the data using the provided dataParser\n          const parsedData: T = this.dataParser(this.currentEvent.rawData)\n          // Emit only if we successfully parsed the data\n          controller.enqueue(parsedData)\n        } catch (e) {\n          // If parsing fails, log the error without emitting\n          console.warn('Failed to parse event data:', e)\n          console.log(\n            'Raw data that failed to parse:',\n            this.currentEvent.rawData\n          )\n        }\n      }\n\n      // Reset the current event\n      this.currentEvent = { rawData: '' }\n    }\n  }\n}\n","import {\n  type Transformer,\n  TransformStream,\n  type TransformStreamDefaultController,\n} from 'stream/web'\n\nexport interface TextDecoderCommon {\n  readonly encoding: string\n  readonly fatal: boolean\n  readonly ignoreBOM: boolean\n}\n\nclass TextDecodeTransformer\n  implements Transformer<ArrayBuffer | Uint8Array, string>\n{\n  private decoder\n\n  constructor() {\n    this.decoder = new TextDecoder()\n  }\n\n  transform(\n    chunk: ArrayBuffer | Uint8Array,\n    controller: TransformStreamDefaultController<string>\n  ) {\n    if (!(chunk instanceof ArrayBuffer || ArrayBuffer.isView(chunk))) {\n      throw new TypeError('Input data must be a BufferSource')\n    }\n    const text = this.decoder.decode(chunk, { stream: true })\n    if (text.length !== 0) {\n      controller.enqueue(text)\n    }\n  }\n\n  flush(controller: TransformStreamDefaultController<string>) {\n    const text = this.decoder.decode()\n    if (text.length !== 0) {\n      controller.enqueue(text)\n    }\n  }\n}\n\nexport class TextDecoderStreamPolyfill extends TransformStream<\n  ArrayBuffer | Uint8Array,\n  string\n> {\n  constructor() {\n    super(new TextDecodeTransformer())\n  }\n}\n","export class ColorLog {\n  // ANSI escape codes for different colors\n  private readonly ANSI_WHITE_BRIGHT = '\\x1b[97m'\n  private readonly ANSI_GREEN_BRIGHT = '\\x1b[92m'\n  private readonly ANSI_BLUE_BRIGHT = '\\x1b[94m'\n  private readonly ANSI_YELLOW = '\\x1b[93m'\n  private readonly ANSI_RED = '\\x1b[91m'\n  private readonly ANSI_RESET = '\\x1b[0m'\n\n  // Method to wrap text with the specified ANSI color code\n  private colorize(text: string, colorCode: string): string {\n    return `${colorCode}${text}${this.ANSI_RESET}`\n  }\n\n  // Public methods to colorize text in various colors\n  public whiteBright(text: string): string {\n    return this.colorize(text, this.ANSI_WHITE_BRIGHT)\n  }\n\n  public greenBright(text: string): string {\n    return this.colorize(text, this.ANSI_GREEN_BRIGHT)\n  }\n\n  public blueBright(text: string): string {\n    return this.colorize(text, this.ANSI_BLUE_BRIGHT)\n  }\n\n  public yellow(text: string): string {\n    return this.colorize(text, this.ANSI_YELLOW)\n  }\n\n  public red(text: string): string {\n    return this.colorize(text, this.ANSI_RED)\n  }\n}\n","import {\n  type Transformer,\n  TransformStream,\n  type TransformStreamDefaultController,\n} from 'stream/web'\n\nclass TypeTransformer<I, O> implements Transformer<I, O> {\n  private buffer?: O[]\n  private doneCallback?: (args0: readonly O[]) => Promise<void>\n  private transformFn: (arg0: I) => O\n\n  constructor(\n    transformFn: (arg0: I) => O,\n    doneCallback?: (args0: readonly O[]) => Promise<void>\n  ) {\n    this.transformFn = transformFn\n    this.doneCallback = doneCallback\n    this.buffer = doneCallback ? [] : undefined\n  }\n\n  async transform(obj: I, controller: TransformStreamDefaultController<O>) {\n    const val = this.transformFn(obj)\n    if (val) {\n      controller.enqueue(val)\n      this.buffer?.push(val)\n    }\n  }\n\n  async flush(controller: TransformStreamDefaultController<O>) {\n    await this.doneCallback?.(this.buffer ?? [])\n    controller.terminate()\n  }\n}\n\nexport class RespTransformStream<I, O> extends TransformStream<I, O> {\n  constructor(\n    transformFn: (arg0: I) => O,\n    doneCallback?: (args0: readonly O[]) => Promise<void>\n  ) {\n    super(new TypeTransformer<I, O>(transformFn, doneCallback))\n  }\n}\n","import type { AxModelConfig } from '../types.js'\n\nexport enum AxAIAnthropicModel {\n  Claude35Sonnet = 'claude-3-5-sonnet-latest',\n  Claude35Haiku = 'claude-3-5-haiku-latest',\n\n  Claude3Opus = 'claude-3-opus-latest',\n  Claude3Sonnet = 'claude-3-sonnet-20240229',\n  Claude3Haiku = 'claude-3-haiku-20240307',\n\n  Claude21 = 'claude-2.1',\n  ClaudeInstant12 = 'claude-instant-1.2',\n}\n\nexport type AxAIAnthropicConfig = AxModelConfig & {\n  model: AxAIAnthropicModel\n}\n\nexport type AxAIAnthropicChatRequestCacheParam = {\n  cache_control?: { type: 'ephemeral' }\n}\n\n// Type for the request to create a message using Anthropic's Messages API\nexport type AxAIAnthropicChatRequest = {\n  model: string\n  messages: (\n    | {\n        role: 'user'\n        content:\n          | string\n          | (\n              | ({\n                  type: 'text'\n                  text: string\n                } & AxAIAnthropicChatRequestCacheParam)\n              | ({\n                  type: 'image'\n                  source: { type: 'base64'; media_type: string; data: string }\n                } & AxAIAnthropicChatRequestCacheParam)\n              | {\n                  type: 'tool_result'\n                  is_error?: boolean\n                  tool_use_id: string\n                  content:\n                    | string\n                    | (\n                        | ({\n                            type: 'text'\n                            text: string\n                          } & AxAIAnthropicChatRequestCacheParam)\n                        | ({\n                            type: 'image'\n                            source: {\n                              type: 'base64'\n                              media_type: string\n                              data: string\n                            }\n                          } & AxAIAnthropicChatRequestCacheParam)\n                      )[]\n                }\n            )[]\n      }\n    | {\n        role: 'assistant'\n        content:\n          | string\n          | (\n              | { type: 'text'; text: string }\n              | { type: 'tool_use'; id: string; name: string; input: object }\n            )[]\n      }\n  )[]\n  tools?: ({\n    name: string\n    description: string\n    input_schema?: object\n  } & AxAIAnthropicChatRequestCacheParam)[]\n  tool_choice?: { type: 'auto' | 'any' } | { type: 'tool'; name?: string }\n  max_tokens?: number // Maximum number of tokens to generate\n  // Optional metadata about the request\n  stop_sequences?: string[] // Custom sequences that trigger the end of generation\n  stream?: boolean // Whether to stream the response incrementally\n  system?:\n    | string\n    | ({\n        type: 'text'\n        text: string\n      } & AxAIAnthropicChatRequestCacheParam)[] // system prompt\n  temperature?: number // Randomness of the response\n  top_p?: number // Nucleus sampling probability\n  top_k?: number // Sample from the top K options\n  metadata?: {\n    user_id: string\n  }\n}\n\nexport type AxAIAnthropicChatResponse = {\n  id: string // Unique identifier for the response\n  type: 'message' // Object type, always 'message' for this API\n  role: 'assistant' // Conversational role of the generated message, always 'assistant'\n  content: (\n    | {\n        type: 'text'\n        text: string\n      }\n    | {\n        id: string\n        name: string\n        type: 'tool_use'\n        input?: string\n      }\n  )[]\n  model: string\n  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use'\n  stop_sequence?: string\n  usage: {\n    input_tokens: number\n    output_tokens: number\n  }\n}\n\nexport type AxAIAnthropicChatError = {\n  type: 'error'\n  error: {\n    type: 'authentication_error'\n    message: string\n  }\n}\n\n// Represents the start of a message with an empty content array\nexport interface AxAIAnthropicMessageStartEvent {\n  type: 'message_start'\n  message: {\n    id: string\n    type: 'message'\n    role: 'assistant'\n    content: []\n    model: string\n    stop_reason: null | string\n    stop_sequence: null | string\n    usage: {\n      input_tokens: number\n      output_tokens: number\n    }\n  }\n}\n\n// Indicates the start of a content block within a message\nexport interface AxAIAnthropicContentBlockStartEvent {\n  index: number\n  type: 'content_block_start'\n  content_block:\n    | {\n        type: 'text'\n        text: string\n      }\n    | {\n        type: 'tool_use'\n        id: string\n        name: string\n        input: object\n      }\n}\n\n// Represents incremental updates to a content block\nexport interface AxAIAnthropicContentBlockDeltaEvent {\n  index: number\n  type: 'content_block_delta'\n  delta:\n    | {\n        type: 'text_delta'\n        text: string\n      }\n    | {\n        type: 'input_json_delta'\n        partial_json: string\n      }\n}\n\n// Marks the end of a content block within a message\nexport interface AxAIAnthropicContentBlockStopEvent {\n  type: 'content_block_stop'\n  index: number\n}\n\n// Indicates top-level changes to the final message object\nexport interface AxAIAnthropicMessageDeltaEvent {\n  type: 'message_delta'\n  delta: {\n    stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | null\n    stop_sequence: string | null\n  }\n  usage: {\n    output_tokens: number\n  }\n}\n\n// Marks the end of a message\nexport interface AxAIAnthropicMessageStopEvent {\n  type: 'message_stop'\n}\n\n// Represents a ping event, which can occur any number of times\nexport interface AxAIAnthropicPingEvent {\n  type: 'ping'\n}\n\n// Represents an error event\nexport interface AxAIAnthropicErrorEvent {\n  type: 'error'\n  error: {\n    type: 'overloaded_error'\n    message: string\n  }\n}\n\n// Union type for all possible event types in the stream\nexport type AxAIAnthropicChatResponseDelta =\n  | AxAIAnthropicMessageStartEvent\n  | AxAIAnthropicContentBlockStartEvent\n  | AxAIAnthropicContentBlockDeltaEvent\n  | AxAIAnthropicContentBlockStopEvent\n  | AxAIAnthropicMessageDeltaEvent\n  | AxAIAnthropicMessageStopEvent\n  | AxAIAnthropicPingEvent\n  | AxAIAnthropicErrorEvent\n","import type { AxModelInfo } from '../types.js'\n\nimport { AxAIAnthropicModel } from './types.js'\n\nexport const axModelInfoAnthropic: AxModelInfo[] = [\n  // 35\n  {\n    name: AxAIAnthropicModel.Claude35Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n  },\n  {\n    name: AxAIAnthropicModel.Claude35Haiku,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.8,\n    completionTokenCostPer1M: 4.0,\n  },\n  // 3\n  {\n    name: AxAIAnthropicModel.Claude3Opus,\n    currency: 'usd',\n    promptTokenCostPer1M: 15.0,\n    completionTokenCostPer1M: 75.0,\n  },\n  {\n    name: AxAIAnthropicModel.Claude3Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n  },\n  {\n    name: AxAIAnthropicModel.Claude3Haiku,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.25,\n    completionTokenCostPer1M: 1.25,\n  },\n  // 21\n  {\n    name: AxAIAnthropicModel.Claude21,\n    currency: 'usd',\n    promptTokenCostPer1M: 8.0,\n    completionTokenCostPer1M: 25,\n  },\n  {\n    name: AxAIAnthropicModel.ClaudeInstant12,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.8,\n    completionTokenCostPer1M: 2.24,\n  },\n]\n","import type { AxAPI } from '../../util/apicall.js'\nimport { AxBaseAI, axBaseAIDefaultConfig } from '../base.js'\nimport type {\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxInternalChatRequest,\n  AxModelConfig,\n} from '../types.js'\n\nimport { axModelInfoAnthropic } from './info.js'\nimport {\n  type AxAIAnthropicChatError,\n  type AxAIAnthropicChatRequest,\n  type AxAIAnthropicChatResponse,\n  type AxAIAnthropicChatResponseDelta,\n  type AxAIAnthropicConfig,\n  type AxAIAnthropicContentBlockDeltaEvent,\n  type AxAIAnthropicContentBlockStartEvent,\n  type AxAIAnthropicErrorEvent,\n  type AxAIAnthropicMessageDeltaEvent,\n  type AxAIAnthropicMessageStartEvent,\n  AxAIAnthropicModel,\n} from './types.js'\n\nexport const axAIAnthropicDefaultConfig = (): AxAIAnthropicConfig =>\n  structuredClone({\n    model: AxAIAnthropicModel.Claude35Sonnet,\n    ...axBaseAIDefaultConfig(),\n  })\n\nexport interface AxAIAnthropicArgs {\n  name: 'anthropic'\n  apiKey: string\n  config?: Readonly<Partial<AxAIAnthropicConfig>>\n  options?: Readonly<AxAIServiceOptions>\n  modelMap?: Record<string, AxAIAnthropicModel | string>\n}\n\nclass AxAIAnthropicImpl\n  implements\n    AxAIServiceImpl<\n      AxAIAnthropicChatRequest,\n      unknown,\n      AxAIAnthropicChatResponse,\n      AxAIAnthropicChatResponseDelta,\n      unknown\n    >\n{\n  constructor(private config: AxAIAnthropicConfig) {}\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      stream: config.stream,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      n: config.n,\n    } as AxModelConfig\n  }\n\n  createChatReq = (\n    req: Readonly<AxInternalChatRequest>\n  ): [AxAPI, AxAIAnthropicChatRequest] => {\n    const model = req.model\n\n    const apiConfig = {\n      name: '/messages',\n    }\n\n    const system = req.chatPrompt\n      .filter((msg) => msg.role === 'system')\n      .map((msg) => ({\n        type: 'text' as const,\n        text: msg.content,\n        ...(msg.cache ? { cache: { type: 'ephemeral' } } : {}),\n      }))\n\n    const otherMessages = req.chatPrompt.filter((msg) => msg.role !== 'system')\n\n    const messages = createMessages(otherMessages)\n\n    const tools: AxAIAnthropicChatRequest['tools'] = req.functions?.map(\n      (v) => ({\n        name: v.name,\n        description: v.description,\n        input_schema: v.parameters,\n      })\n    )\n\n    const stream = req.modelConfig?.stream ?? this.config.stream\n\n    const reqValue: AxAIAnthropicChatRequest = {\n      model,\n      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      stop_sequences:\n        req.modelConfig?.stopSequences ?? this.config.stopSequences,\n      temperature: req.modelConfig?.temperature ?? this.config.temperature,\n      top_p: req.modelConfig?.topP ?? this.config.topP,\n      top_k: req.modelConfig?.topK ?? this.config.topK,\n      ...(tools && tools.length > 0\n        ? { tools, tool_choice: { type: 'auto' } }\n        : {}),\n      ...(stream ? { stream: true } : {}),\n      ...(system ? { system } : {}),\n      messages,\n    }\n\n    return [apiConfig, reqValue]\n  }\n\n  createChatResp = (\n    resp: Readonly<AxAIAnthropicChatResponse | AxAIAnthropicChatError>\n  ): AxChatResponse => {\n    if (resp.type === 'error') {\n      throw new Error(`Anthropic Chat API Error: ${resp.error.message}`)\n    }\n\n    const finishReason = mapFinishReason(resp.stop_reason)\n\n    const results = resp.content.map((msg): AxChatResponseResult => {\n      if (msg.type === 'tool_use') {\n        return {\n          id: msg.id,\n          functionCalls: [\n            {\n              id: msg.id,\n              type: 'function' as const,\n              function: {\n                name: msg.name,\n                params: msg.input,\n              },\n            },\n          ],\n          finishReason,\n        }\n      }\n      return {\n        content: msg.type === 'text' ? msg.text : '',\n        id: resp.id,\n        finishReason,\n      }\n    })\n\n    const modelUsage = {\n      promptTokens: resp.usage.input_tokens,\n      completionTokens: resp.usage.output_tokens,\n      totalTokens: resp.usage.input_tokens + resp.usage.output_tokens,\n    }\n\n    return {\n      results,\n      modelUsage,\n      remoteId: resp.id,\n    }\n  }\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIAnthropicChatResponseDelta>,\n    state: object\n  ): AxChatResponse => {\n    if (!('type' in resp)) {\n      throw new Error('Invalid Anthropic streaming event')\n    }\n\n    const sstate = state as {\n      indexIdMap: Record<number, string>\n    }\n\n    if (!sstate.indexIdMap) {\n      sstate.indexIdMap = {}\n    }\n\n    if (resp.type === 'error') {\n      const { error } = resp as unknown as AxAIAnthropicErrorEvent\n      throw new Error(error.message)\n    }\n\n    if (resp.type === 'message_start') {\n      const { message } = resp as unknown as AxAIAnthropicMessageStartEvent\n      const results = [{ content: '', id: message.id }]\n      const modelUsage = {\n        promptTokens: message.usage?.input_tokens ?? 0,\n        completionTokens: message.usage?.output_tokens ?? 0,\n        totalTokens:\n          (message.usage?.input_tokens ?? 0) +\n          (message.usage?.output_tokens ?? 0),\n      }\n      return {\n        results,\n        modelUsage,\n      }\n    }\n\n    if (resp.type === 'content_block_start') {\n      const { content_block: contentBlock } =\n        resp as unknown as AxAIAnthropicContentBlockStartEvent\n\n      if (contentBlock.type === 'text') {\n        return {\n          results: [{ content: contentBlock.text }],\n        }\n      }\n      if (contentBlock.type === 'tool_use') {\n        if (\n          typeof contentBlock.id === 'string' &&\n          typeof resp.index === 'number' &&\n          !sstate.indexIdMap[resp.index]\n        ) {\n          sstate.indexIdMap[resp.index] = contentBlock.id\n          const functionCalls = [\n            {\n              id: contentBlock.id,\n              type: 'function' as const,\n              function: {\n                name: contentBlock.name,\n                params: '',\n              },\n            },\n          ]\n          return {\n            results: [{ functionCalls }],\n          }\n        }\n      }\n    }\n\n    if (resp.type === 'content_block_delta') {\n      const { delta } = resp as unknown as AxAIAnthropicContentBlockDeltaEvent\n      if (delta.type === 'text_delta') {\n        return {\n          results: [{ content: delta.text }],\n        }\n      }\n      if (delta.type === 'input_json_delta') {\n        const id = sstate.indexIdMap[resp.index]\n        if (!id) {\n          throw new Error('invalid streaming index no id found: ' + resp.index)\n        }\n        const functionCalls = [\n          {\n            id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: delta.partial_json,\n            },\n          },\n        ]\n        return {\n          results: [{ functionCalls }],\n        }\n      }\n    }\n\n    if (resp.type === 'message_delta') {\n      const { delta, usage } = resp as unknown as AxAIAnthropicMessageDeltaEvent\n      return {\n        results: [\n          {\n            content: '',\n            finishReason: mapFinishReason(delta.stop_reason),\n          },\n        ],\n        modelUsage: {\n          promptTokens: 0,\n          completionTokens: usage.output_tokens,\n          totalTokens: usage.output_tokens,\n        },\n      }\n    }\n\n    return {\n      results: [{ content: '' }],\n    }\n  }\n}\n\nexport class AxAIAnthropic extends AxBaseAI<\n  AxAIAnthropicChatRequest,\n  unknown,\n  AxAIAnthropicChatResponse,\n  AxAIAnthropicChatResponseDelta,\n  unknown\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    modelMap,\n  }: Readonly<Omit<AxAIAnthropicArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Anthropic API key not set')\n    }\n    const _config = {\n      ...axAIAnthropicDefaultConfig(),\n      ...config,\n    }\n\n    const aiImpl = new AxAIAnthropicImpl(_config)\n\n    super(aiImpl, {\n      name: 'Anthropic',\n      apiURL: 'https://api.anthropic.com/v1',\n      headers: {\n        'anthropic-version': '2023-06-01',\n        'anthropic-beta': 'prompt-caching-2024-07-31',\n        'x-api-key': apiKey,\n      },\n      modelInfo: axModelInfoAnthropic,\n      models: { model: _config.model },\n      options,\n      supportFor: { functions: true, streaming: true },\n      modelMap,\n    })\n  }\n}\n\nfunction createMessages(\n  chatPrompt: Readonly<AxChatRequest['chatPrompt']>\n): AxAIAnthropicChatRequest['messages'] {\n  const items: AxAIAnthropicChatRequest['messages'] = chatPrompt.map((msg) => {\n    switch (msg.role) {\n      case 'function':\n        return {\n          role: 'user' as const,\n          content: [\n            {\n              type: 'tool_result',\n              content: msg.result,\n              tool_use_id: msg.functionId,\n              ...(msg.cache ? { cache: { type: 'ephemeral' } } : {}),\n            },\n          ],\n        }\n      case 'user': {\n        if (typeof msg.content === 'string') {\n          return {\n            role: 'user' as const,\n            content: msg.content,\n          }\n        }\n        const content = msg.content.map((v) => {\n          switch (v.type) {\n            case 'text':\n              return {\n                type: 'text' as const,\n                text: v.text,\n                ...(v.cache ? { cache: { type: 'ephemeral' } } : {}),\n              }\n            case 'image':\n              return {\n                type: 'image' as const,\n                source: {\n                  type: 'base64' as const,\n                  media_type: v.mimeType,\n                  data: v.image,\n                },\n                ...(v.cache ? { cache: { type: 'ephemeral' } } : {}),\n              }\n            default:\n              throw new Error('Invalid content type')\n          }\n        })\n        return {\n          role: 'user' as const,\n          content,\n        }\n      }\n      case 'assistant': {\n        let content: Extract<\n          AxAIAnthropicChatRequest['messages'][0],\n          { role: 'assistant' }\n        >['content'] = ''\n\n        if (typeof msg.content === 'string') {\n          content = msg.content\n        }\n        if (typeof msg.functionCalls !== 'undefined') {\n          content = msg.functionCalls.map((v) => {\n            let input\n            if (typeof v.function.params === 'string') {\n              input = JSON.parse(v.function.params)\n            } else if (typeof v.function.params === 'object') {\n              input = v.function.params\n            }\n            return {\n              type: 'tool_use' as const,\n              id: v.id,\n              name: v.function.name,\n              input,\n              ...(msg.cache ? { cache: { type: 'ephemeral' } } : {}),\n            }\n          })\n        }\n        return {\n          role: 'assistant' as const,\n          content,\n        }\n      }\n      default:\n        throw new Error('Invalid role')\n    }\n  })\n\n  return mergeAssistantMessages(items)\n}\n\n// Anthropic and some others need this in non-streaming mode\nfunction mergeAssistantMessages(\n  messages: Readonly<AxAIAnthropicChatRequest['messages']>\n): AxAIAnthropicChatRequest['messages'] {\n  const mergedMessages: AxAIAnthropicChatRequest['messages'] = []\n\n  for (const [i, cur] of messages.entries()) {\n    // Continue if not an assistant message or first message\n    if (cur.role !== 'assistant') {\n      mergedMessages.push(cur)\n      continue\n    }\n\n    // Merge current message with the previous one if both are from the assistant\n    if (i > 0 && messages.at(i - 1)?.role === 'assistant') {\n      const lastMessage = mergedMessages.pop()\n\n      mergedMessages.push({\n        ...(lastMessage ? lastMessage : {}),\n        ...cur,\n      })\n    } else {\n      mergedMessages.push(cur)\n    }\n  }\n\n  return mergedMessages\n}\n\nfunction mapFinishReason(\n  stopReason?: AxAIAnthropicChatResponse['stop_reason'] | null\n): AxChatResponse['results'][0]['finishReason'] | undefined {\n  if (!stopReason) {\n    return undefined\n  }\n  switch (stopReason) {\n    case 'stop_sequence':\n      return 'stop'\n      break\n    case 'max_tokens':\n      return 'length'\n      break\n    case 'tool_use':\n      return 'function_call'\n      break\n    case 'end_turn':\n      return 'stop'\n      break\n    default:\n      return 'stop'\n  }\n}\n","import type { AxModelConfig } from '../types.js'\n\nexport enum AxAIOpenAIModel {\n  O1Preview = 'o1-preview',\n  O1Mini = 'o1-mini',\n  GPT4 = 'gpt-4',\n  GPT4O = 'gpt-4o',\n  GPT4OMini = 'gpt-4o-mini',\n  GPT4ChatGPT4O = 'chatgpt-4o-latest',\n  GPT4Turbo = 'gpt-4-turbo',\n  GPT35Turbo = 'gpt-3.5-turbo',\n  GPT35TurboInstruct = 'gpt-3.5-turbo-instruct',\n  GPT35TextDavinci002 = 'text-davinci-002',\n  GPT3TextBabbage002 = 'text-babbage-002',\n  GPT3TextAda001 = 'text-ada-001',\n}\n\nexport enum AxAIOpenAIEmbedModel {\n  TextEmbeddingAda002 = 'text-embedding-ada-002',\n  TextEmbedding3Small = 'text-embedding-3-small',\n  TextEmbedding3Large = 'text-embedding-3-large',\n}\n\nexport type AxAIOpenAIConfig = Omit<AxModelConfig, 'topK'> & {\n  model: AxAIOpenAIModel | string\n  embedModel?: AxAIOpenAIEmbedModel | string\n  user?: string\n  responseFormat?: 'json_object'\n  bestOf?: number\n  logitBias?: Map<string, number>\n  suffix?: string | null\n  stop?: string[]\n  logprobs?: number\n  echo?: boolean\n  dimensions?: number\n}\n\nexport type AxAIOpenAILogprob = {\n  tokens: string[]\n  token_logprobs: number[]\n  top_logprobs: Map<string, number>\n  text_offset: number[]\n}\n\nexport type AxAIOpenAIUsage = {\n  prompt_tokens: number\n  completion_tokens: number\n  total_tokens: number\n}\n\nexport interface AxAIOpenAIResponseDelta<T> {\n  id: string\n  object: string\n  created: number\n  model: string\n  choices: {\n    index: number\n    delta: T\n    finish_reason: 'stop' | 'length' | 'content_filter' | 'tool_calls'\n  }[]\n  usage?: AxAIOpenAIUsage\n  system_fingerprint: string\n}\n\nexport type AxAIOpenAIChatRequest = {\n  model: string\n  messages: (\n    | { role: 'system'; content: string }\n    | {\n        role: 'user'\n        content:\n          | string\n          | (\n              | {\n                  type: 'text'\n                  text: string\n                }\n              | {\n                  type: 'image_url'\n                  image_url: { url: string; details?: 'high' | 'low' | 'auto' }\n                }\n              | {\n                  type: 'input_audio'\n                  input_audio: { data: string; format?: 'wav' }\n                }\n            )[]\n        name?: string\n      }\n    | {\n        role: 'assistant'\n        content: string\n        name?: string\n        tool_calls?: {\n          type: 'function'\n          function: {\n            name: string\n            // eslint-disable-next-line functional/functional-parameters\n            arguments?: string\n          }\n        }[]\n      }\n    | { role: 'tool'; content: string; tool_call_id: string }\n  )[]\n  tools?: {\n    type: 'function'\n    function: {\n      name: string\n      description: string\n      parameters?: object\n    }\n  }[]\n  tool_choice?:\n    | 'none'\n    | 'auto'\n    | 'required'\n    | { type: 'function'; function: { name: string } }\n  response_format?: { type: string }\n  max_tokens: number\n  temperature?: number\n  top_p?: number\n  n?: number\n  stream?: boolean\n  stop?: readonly string[]\n  presence_penalty?: number\n  frequency_penalty?: number\n  logit_bias?: Map<string, number>\n  user?: string\n  organization?: string\n}\n\nexport type AxAIOpenAIChatResponse = {\n  id: string\n  object: 'chat.completion'\n  created: number\n  model: string\n  choices: {\n    index: number\n    message: {\n      role: string\n      content: string\n      tool_calls?: {\n        id: string\n        type: 'function'\n        // eslint-disable-next-line functional/functional-parameters\n        function: { name: string; arguments: string }\n      }[]\n    }\n    finish_reason: 'stop' | 'length' | 'content_filter' | 'tool_calls'\n  }[]\n  usage?: AxAIOpenAIUsage\n  error?: {\n    message: string\n    type: string\n    param: string\n    code: number\n  }\n  system_fingerprint: string\n}\n\nexport type AxAIOpenAIChatResponseDelta = AxAIOpenAIResponseDelta<{\n  content: string\n  role?: string\n  tool_calls?: (NonNullable<\n    AxAIOpenAIChatResponse['choices'][0]['message']['tool_calls']\n  >[0] & {\n    index: number\n  })[]\n}>\n\nexport type AxAIOpenAIEmbedRequest = {\n  input: readonly string[]\n  model: string\n  dimensions?: number\n  user?: string\n}\n\nexport type AxAIOpenAIEmbedResponse = {\n  model: string\n  data: {\n    embedding: readonly number[]\n    index: number\n  }[]\n  usage: AxAIOpenAIUsage\n}\n","import type { AxModelInfo } from '../types.js'\n\nimport { AxAIOpenAIEmbedModel, AxAIOpenAIModel } from './types.js'\n\n/**\n * OpenAI: Model information\n */\nexport const axModelInfoOpenAI: AxModelInfo[] = [\n  {\n    name: AxAIOpenAIModel.O1Preview,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIModel.O1Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 3,\n    completionTokenCostPer1M: 12,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4,\n    currency: 'usd',\n    promptTokenCostPer1M: 30,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4OMini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.15,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4ChatGPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 10,\n    completionTokenCostPer1M: 30,\n  },\n  {\n    name: AxAIOpenAIModel.GPT35Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  {\n    name: AxAIOpenAIEmbedModel.TextEmbeddingAda002,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAIOpenAIEmbedModel.TextEmbedding3Small,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.02,\n    completionTokenCostPer1M: 0.02,\n  },\n  {\n    name: AxAIOpenAIEmbedModel.TextEmbedding3Large,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.13,\n    completionTokenCostPer1M: 0.13,\n  },\n]\n","import type { AxAPI } from '../../util/apicall.js'\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js'\nimport type {\n  AxAIPromptConfig,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxModelInfo,\n} from '../types.js'\n\nimport { axModelInfoOpenAI } from './info.js'\nimport {\n  type AxAIOpenAIChatRequest,\n  type AxAIOpenAIChatResponse,\n  type AxAIOpenAIChatResponseDelta,\n  type AxAIOpenAIConfig,\n  AxAIOpenAIEmbedModel,\n  type AxAIOpenAIEmbedRequest,\n  type AxAIOpenAIEmbedResponse,\n  AxAIOpenAIModel,\n} from './types.js'\n\nexport const axAIOpenAIDefaultConfig = (): AxAIOpenAIConfig =>\n  structuredClone({\n    model: AxAIOpenAIModel.GPT4O,\n    embedModel: AxAIOpenAIEmbedModel.TextEmbedding3Small,\n    ...axBaseAIDefaultConfig(),\n  })\n\nexport const axAIOpenAIBestConfig = (): AxAIOpenAIConfig =>\n  structuredClone({\n    ...axAIOpenAIDefaultConfig(),\n    model: AxAIOpenAIModel.GPT4Turbo,\n  })\n\nexport const axAIOpenAICreativeConfig = (): AxAIOpenAIConfig =>\n  structuredClone({\n    model: AxAIOpenAIModel.GPT4Turbo,\n    embedModel: AxAIOpenAIEmbedModel.TextEmbedding3Small,\n    ...axBaseAIDefaultCreativeConfig(),\n  })\n\nexport const axAIOpenAIFastConfig = (): AxAIOpenAIConfig => ({\n  ...axAIOpenAIDefaultConfig(),\n  model: AxAIOpenAIModel.GPT4O,\n})\n\nexport interface AxAIOpenAIArgs {\n  name: 'openai'\n  apiKey: string\n  apiURL?: string\n  config?: Readonly<Partial<AxAIOpenAIConfig>>\n  options?: Readonly<AxAIServiceOptions & { streamingUsage?: boolean }>\n  modelInfo?: Readonly<AxModelInfo[]>\n  modelMap?: Record<string, AxAIOpenAIModel | AxAIOpenAIEmbedModel | string>\n}\n\nclass AxAIOpenAIImpl\n  implements\n    AxAIServiceImpl<\n      AxAIOpenAIChatRequest,\n      AxAIOpenAIEmbedRequest,\n      AxAIOpenAIChatResponse,\n      AxAIOpenAIChatResponseDelta,\n      AxAIOpenAIEmbedResponse\n    >\n{\n  constructor(\n    private config: AxAIOpenAIConfig,\n    private streamingUsage: boolean,\n    private dimensions?: number\n  ) {}\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this\n\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      topP: config.topP,\n      n: config.n,\n      stream: config.stream,\n    }\n  }\n\n  createChatReq(\n    req: Readonly<AxInternalChatRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _config: Readonly<AxAIPromptConfig>\n  ): [AxAPI, AxAIOpenAIChatRequest] {\n    const model = req.model\n\n    if (!req.chatPrompt || req.chatPrompt.length === 0) {\n      throw new Error('Chat prompt is empty')\n    }\n\n    const apiConfig = {\n      name: '/chat/completions',\n    }\n\n    const tools = req.functions?.map((v) => ({\n      type: 'function' as const,\n      function: {\n        name: v.name,\n        description: v.description,\n        parameters: v.parameters,\n      },\n    }))\n\n    if (tools && isO1Model(model)) {\n      throw new Error('Functions are not supported for O1 models')\n    }\n\n    const toolsChoice =\n      !req.functionCall && req.functions && req.functions.length > 0\n        ? 'auto'\n        : req.functionCall\n\n    const messages = createMessages(req)\n\n    const frequencyPenalty =\n      req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty\n\n    const stream = req.modelConfig?.stream ?? this.config.stream\n\n    if (stream && isO1Model(model)) {\n      throw new Error('Streaming is not supported for O1 models')\n    }\n\n    const reqValue: AxAIOpenAIChatRequest = {\n      model,\n      messages,\n      response_format: this.config?.responseFormat\n        ? { type: this.config?.responseFormat }\n        : undefined,\n      tools,\n      tool_choice: toolsChoice,\n      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens ?? 500,\n      temperature: req.modelConfig?.temperature ?? this.config.temperature,\n      top_p: req.modelConfig?.topP ?? this.config.topP ?? 1,\n      n: req.modelConfig?.n ?? this.config.n,\n      stop: req.modelConfig?.stopSequences ?? this.config.stop,\n      presence_penalty:\n        req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n      logit_bias: this.config.logitBias,\n      ...(frequencyPenalty ? { frequency_penalty: frequencyPenalty } : {}),\n      ...(stream && this.streamingUsage\n        ? { stream: true, stream_options: { include_usage: true } }\n        : {}),\n    }\n\n    return [apiConfig, reqValue]\n  }\n\n  createEmbedReq(\n    req: Readonly<AxInternalEmbedRequest>\n  ): [AxAPI, AxAIOpenAIEmbedRequest] {\n    const model = req.embedModel\n\n    if (!model) {\n      throw new Error('Embed model not set')\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty')\n    }\n\n    const apiConfig = {\n      name: '/embeddings',\n    }\n\n    const reqValue = {\n      model: model,\n      input: req.texts,\n      dimensions: this.dimensions,\n    }\n\n    return [apiConfig, reqValue]\n  }\n\n  createChatResp(resp: Readonly<AxAIOpenAIChatResponse>): AxChatResponse {\n    const { id, usage, choices, error } = resp\n\n    if (error) {\n      throw error\n    }\n\n    const modelUsage = usage\n      ? {\n          promptTokens: usage.prompt_tokens,\n          completionTokens: usage.completion_tokens,\n          totalTokens: usage.total_tokens,\n        }\n      : undefined\n\n    const results = choices.map((choice) => {\n      const finishReason = mapFinishReason(choice.finish_reason)\n\n      const functionCalls = choice.message.tool_calls?.map(\n        ({ id, function: { arguments: params, name } }) => ({\n          id: id,\n          type: 'function' as const,\n          function: { name, params },\n        })\n      )\n\n      return {\n        id: `${choice.index}`,\n        content: choice.message.content,\n        functionCalls,\n        finishReason,\n      }\n    })\n\n    return {\n      modelUsage,\n      results,\n      remoteId: id,\n    }\n  }\n\n  createChatStreamResp(\n    resp: Readonly<AxAIOpenAIChatResponseDelta>,\n    state: object\n  ): AxChatResponse {\n    const { id, usage, choices } = resp\n\n    const modelUsage = usage\n      ? {\n          promptTokens: usage.prompt_tokens,\n          completionTokens: usage.completion_tokens,\n          totalTokens: usage.total_tokens,\n        }\n      : undefined\n\n    const sstate = state as {\n      indexIdMap: Record<number, string>\n    }\n\n    if (!sstate.indexIdMap) {\n      sstate.indexIdMap = {}\n    }\n\n    const results = choices.map(\n      ({\n        delta: { content, role, tool_calls: toolCalls },\n        finish_reason: oaiFinishReason,\n      }) => {\n        const finishReason = mapFinishReason(oaiFinishReason)\n\n        const functionCalls = toolCalls\n          ?.map(({ id: _id, index, function: { name, arguments: params } }) => {\n            if (\n              typeof _id === 'string' &&\n              typeof index === 'number' &&\n              !sstate.indexIdMap[index]\n            ) {\n              sstate.indexIdMap[index] = _id\n            }\n\n            const id = sstate.indexIdMap[index]\n            if (!id) {\n              return null\n            }\n\n            return {\n              id,\n              type: 'function' as const,\n              function: { name, params },\n            }\n          })\n          .filter((v) => v !== null)\n\n        return {\n          content,\n          role: role,\n          functionCalls,\n          finishReason,\n          id,\n        }\n      }\n    )\n\n    return {\n      results,\n      modelUsage,\n    }\n  }\n\n  createEmbedResp(resp: Readonly<AxAIOpenAIEmbedResponse>): AxEmbedResponse {\n    const { data, usage } = resp\n\n    const modelUsage = usage\n      ? {\n          promptTokens: usage.prompt_tokens,\n          completionTokens: usage.completion_tokens,\n          totalTokens: usage.total_tokens,\n        }\n      : undefined\n\n    return {\n      embeddings: data.map((v) => v.embedding),\n      modelUsage,\n    }\n  }\n}\n\nconst mapFinishReason = (\n  finishReason: AxAIOpenAIChatResponse['choices'][0]['finish_reason']\n): AxChatResponseResult['finishReason'] => {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop' as const\n    case 'length':\n      return 'length' as const\n    case 'content_filter':\n      return 'error' as const\n    case 'tool_calls':\n      return 'function_call' as const\n  }\n}\n\nfunction createMessages(\n  req: Readonly<AxInternalChatRequest>\n): AxAIOpenAIChatRequest['messages'] {\n  return req.chatPrompt.map((msg) => {\n    if (msg.role === 'system' && isO1Model(req.model)) {\n      msg = {\n        role: 'user',\n        content: msg.content,\n      }\n    }\n    switch (msg.role) {\n      case 'system':\n        return { role: 'system' as const, content: msg.content }\n      case 'user':\n        if (Array.isArray(msg.content)) {\n          return {\n            role: 'user' as const,\n            name: msg.name,\n            content: msg.content.map((c) => {\n              switch (c.type) {\n                case 'text':\n                  return { type: 'text' as const, text: c.text }\n                case 'image': {\n                  const url = `data:${c.mimeType};base64,` + c.image\n                  return {\n                    type: 'image_url' as const,\n                    image_url: { url, details: c.details ?? 'auto' },\n                  }\n                }\n                case 'audio': {\n                  const data = c.data\n                  return {\n                    type: 'input_audio' as const,\n                    input_audio: { data, format: c.format ?? 'wav' },\n                  }\n                }\n                default:\n                  throw new Error('Invalid content type')\n              }\n            }),\n          }\n        }\n        return { role: 'user' as const, content: msg.content, name: msg.name }\n      case 'assistant':\n        return {\n          role: 'assistant' as const,\n          content: msg.content as string,\n          name: msg.name,\n          tool_calls: msg.functionCalls?.map((v) => ({\n            id: v.id,\n            type: 'function' as const,\n            function: {\n              name: v.function.name,\n              arguments:\n                typeof v.function.params === 'object'\n                  ? JSON.stringify(v.function.params)\n                  : v.function.params,\n            },\n          })),\n        }\n      case 'function':\n        return {\n          role: 'tool' as const,\n          content: msg.result,\n          tool_call_id: msg.functionId,\n        }\n      default:\n        throw new Error('Invalid role')\n    }\n  })\n}\n\nexport class AxAIOpenAI extends AxBaseAI<\n  AxAIOpenAIChatRequest,\n  AxAIOpenAIEmbedRequest,\n  AxAIOpenAIChatResponse,\n  AxAIOpenAIChatResponseDelta,\n  AxAIOpenAIEmbedResponse\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    apiURL,\n    modelInfo = axModelInfoOpenAI,\n    modelMap,\n  }: Readonly<Omit<AxAIOpenAIArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set')\n    }\n\n    const _config = {\n      ...axAIOpenAIDefaultConfig(),\n      ...config,\n    }\n\n    const aiImpl = new AxAIOpenAIImpl(\n      _config,\n      options?.streamingUsage ?? true,\n      config?.dimensions\n    )\n\n    super(aiImpl, {\n      name: 'OpenAI',\n      apiURL: apiURL ? apiURL : 'https://api.openai.com/v1',\n      headers: { Authorization: `Bearer ${apiKey}` },\n      modelInfo,\n      models: {\n        model: _config.model as string,\n        embedModel: _config.embedModel as string,\n      },\n      options,\n      supportFor: (model: string) => {\n        return isO1Model(model)\n          ? { functions: false, streaming: false }\n          : { functions: true, streaming: true }\n      },\n      modelMap,\n    })\n  }\n}\n\nconst isO1Model = (model: string): boolean =>\n  [AxAIOpenAIModel.O1Mini, AxAIOpenAIModel.O1Preview].includes(\n    model as AxAIOpenAIModel\n  )\n","import {\n  AxAIOpenAI,\n  axAIOpenAIBestConfig,\n  axAIOpenAICreativeConfig,\n  axAIOpenAIDefaultConfig,\n  axAIOpenAIFastConfig,\n} from '../openai/api.js'\nimport type {\n  AxAIOpenAIConfig,\n  AxAIOpenAIEmbedModel,\n  AxAIOpenAIModel,\n} from '../openai/types.js'\nimport type { AxAIServiceOptions } from '../types.js'\n\nexport const axAIAzureOpenAIDefaultConfig = axAIOpenAIDefaultConfig\n\nexport const axAIAzureOpenAICreativeConfig = axAIOpenAICreativeConfig\n\nexport const axAIAzureOpenAIFastConfig = axAIOpenAIFastConfig\n\nexport const axAIAzureOpenAIBestConfig = axAIOpenAIBestConfig\n\nexport interface AxAIAzureOpenAIArgs {\n  name: 'azure-openai'\n  apiKey: string\n  resourceName: string\n  deploymentName: string\n  version?: string\n  config?: Readonly<Partial<AxAIOpenAIConfig>>\n  options?: Readonly<AxAIServiceOptions>\n  modelMap?: Record<string, AxAIOpenAIModel | AxAIOpenAIEmbedModel>\n}\n\nexport class AxAIAzureOpenAI extends AxAIOpenAI {\n  constructor({\n    apiKey,\n    resourceName,\n    deploymentName,\n    version = 'api-version=2024-02-15-preview',\n    config,\n    options,\n    modelMap,\n  }: Readonly<Omit<AxAIAzureOpenAIArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Azure OpenAPI API key not set')\n    }\n    if (!resourceName || resourceName === '') {\n      throw new Error('Azure OpenAPI resource name not set')\n    }\n    if (!deploymentName || deploymentName === '') {\n      throw new Error('Azure OpenAPI deployment id not set')\n    }\n    const _config = {\n      ...axAIAzureOpenAIDefaultConfig(),\n      ...config,\n    }\n    super({ apiKey, config: _config, options, modelMap })\n\n    const host = resourceName.includes('://')\n      ? resourceName\n      : `https://${resourceName}.openai.azure.com/`\n\n    super.setName('Azure OpenAI')\n\n    super.setAPIURL(\n      new URL(\n        `/openai/deployments/${deploymentName}?api-version=${version}`,\n        host\n      ).href\n    )\n\n    super.setHeaders({ 'api-key': apiKey })\n  }\n}\n","import type { AxModelConfig } from '../types.js'\n\n/**\n * Cohere: Models for text generation\n */\nexport enum AxAICohereModel {\n  CommandRPlus = 'command-r-plus',\n  CommandR = 'command-r',\n  Command = 'command',\n  CommandLight = 'command-light',\n}\n\n/**\n * Cohere: Models for use in embeddings\n */\nexport enum AxAICohereEmbedModel {\n  EmbedEnglishV30 = 'embed-english-v3.0',\n  EmbedEnglishLightV30 = 'embed-english-light-v3.0',\n  EmbedMultiLingualV30 = 'embed-multilingual-v3.0',\n  EmbedMultiLingualLightV30 = 'embed-multilingual-light-v3.0',\n}\n\n/**\n * Cohere: Model options for text generation\n */\nexport type AxAICohereConfig = AxModelConfig & {\n  model: AxAICohereModel\n  embedModel?: AxAICohereEmbedModel\n}\n\nexport type AxAICohereChatResponseToolCalls = {\n  name: string\n  parameters?: object\n}[]\n\nexport type AxAICohereChatRequestToolResults = {\n  call: AxAICohereChatResponseToolCalls[0]\n  outputs: object[]\n}[]\n\nexport type AxAICohereChatRequest = {\n  message?: string\n  preamble?: string\n  chat_history: (\n    | {\n        role: 'CHATBOT'\n        message: string\n        tool_calls?: AxAICohereChatResponseToolCalls\n      }\n    | {\n        role: 'SYSTEM'\n        message: string\n      }\n    | {\n        role: 'USER'\n        message: string\n      }\n    | {\n        role: 'TOOL'\n        message?: string\n        tool_results: AxAICohereChatRequestToolResults\n      }\n  )[]\n\n  model: AxAICohereModel | string\n  max_tokens?: number\n  temperature?: number\n  k?: number\n  p?: number\n  frequency_penalty?: number\n  presence_penalty?: number\n  end_sequences?: readonly string[]\n  stop_sequences?: string[]\n  tools?: {\n    name: string\n    description: string\n    parameter_definitions: Record<\n      string,\n      {\n        description: string\n        type: string\n        required: boolean\n      }\n    >\n  }[]\n  tool_results?: AxAICohereChatRequestToolResults\n}\n\nexport type AxAICohereChatResponse = {\n  response_id: string\n  meta: {\n    billed_units: {\n      input_tokens: number\n      output_tokens: number\n    }\n  }\n  generation_id: string\n  text: string\n  finish_reason:\n    | 'COMPLETE'\n    | 'ERROR'\n    | 'ERROR_TOXIC'\n    | 'ERROR_LIMIT'\n    | 'USER_CANCEL'\n    | 'MAX_TOKENS'\n  tool_calls: AxAICohereChatResponseToolCalls\n}\n\nexport type AxAICohereChatResponseDelta = AxAICohereChatResponse & {\n  event_type:\n    | 'stream-start'\n    | 'text-generation'\n    | 'tool-calls-generation'\n    | 'stream-end'\n}\n\nexport type AxAICohereEmbedRequest = {\n  texts: readonly string[]\n  model: AxAICohereModel | string\n  truncate: string\n}\n\nexport type AxAICohereEmbedResponse = {\n  id: string\n  texts: string[]\n  model: string\n  embeddings: number[][]\n}\n","import type { AxModelInfo } from '../types.js'\n\nimport { AxAICohereEmbedModel, AxAICohereModel } from './types.js'\n\nexport const axModelInfoCohere: AxModelInfo[] = [\n  {\n    name: AxAICohereModel.CommandRPlus,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAICohereModel.CommandR,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  {\n    name: AxAICohereModel.Command,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  {\n    name: AxAICohereModel.CommandLight,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.3,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedEnglishLightV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedEnglishV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedMultiLingualV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedMultiLingualLightV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n]\n","import type { AxAPI } from '../../util/apicall.js'\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js'\nimport type {\n  AxAIPromptConfig,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n} from '../types.js'\n\nimport { axModelInfoCohere } from './info.js'\nimport {\n  type AxAICohereChatRequest,\n  type AxAICohereChatResponse,\n  type AxAICohereChatResponseDelta,\n  type AxAICohereConfig,\n  AxAICohereEmbedModel,\n  type AxAICohereEmbedRequest,\n  type AxAICohereEmbedResponse,\n  AxAICohereModel,\n} from './types.js'\n\nexport const axAICohereDefaultConfig = (): AxAICohereConfig =>\n  structuredClone({\n    model: AxAICohereModel.CommandRPlus,\n    embedModel: AxAICohereEmbedModel.EmbedEnglishV30,\n    ...axBaseAIDefaultConfig(),\n  })\n\nexport const axAICohereCreativeConfig = (): AxAICohereConfig =>\n  structuredClone({\n    model: AxAICohereModel.CommandR,\n    embedModel: AxAICohereEmbedModel.EmbedEnglishV30,\n    ...axBaseAIDefaultCreativeConfig(),\n  })\n\nexport interface AxAICohereArgs {\n  name: 'cohere'\n  apiKey: string\n  config?: Readonly<Partial<AxAICohereConfig>>\n  options?: Readonly<AxAIServiceOptions>\n  modelMap?: Record<string, AxAICohereModel | AxAICohereEmbedModel | string>\n}\n\nclass AxAICohereImpl\n  implements\n    AxAIServiceImpl<\n      AxAICohereChatRequest,\n      AxAICohereEmbedRequest,\n      AxAICohereChatResponse,\n      AxAICohereChatResponseDelta,\n      AxAICohereEmbedResponse\n    >\n{\n  constructor(private config: AxAICohereConfig) {}\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      frequencyPenalty: config.frequencyPenalty,\n      presencePenalty: config.presencePenalty,\n      endSequences: config.endSequences,\n      stopSequences: config.stopSequences,\n      stream: config.stream,\n      n: config.n,\n    } as AxModelConfig\n  }\n\n  createChatReq(\n    req: Readonly<AxInternalChatRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _config: Readonly<AxAIPromptConfig>\n  ): [AxAPI, AxAICohereChatRequest] {\n    const model = req.model\n\n    const lastChatMsg = req.chatPrompt.at(-1)\n    const restOfChat = req.chatPrompt.slice(0, -1)\n\n    let message: AxAICohereChatRequest['message'] | undefined\n\n    if (\n      lastChatMsg &&\n      lastChatMsg.role === 'user' &&\n      typeof lastChatMsg.content === 'string'\n    ) {\n      message = lastChatMsg?.content\n    }\n\n    const chatHistory = createHistory(restOfChat)\n\n    type PropValue = NonNullable<\n      AxAICohereChatRequest['tools']\n    >[0]['parameter_definitions'][0]\n\n    const tools: AxAICohereChatRequest['tools'] = req.functions?.map((v) => {\n      const props: Record<string, PropValue> = {}\n      if (v.parameters?.properties) {\n        for (const [key, value] of Object.entries(v.parameters.properties)) {\n          props[key] = {\n            description: value.description,\n            type: value.type,\n            required: v.parameters.required?.includes(key) ?? false,\n          }\n        }\n      }\n\n      return {\n        name: v.name,\n        description: v.description,\n        parameter_definitions: props,\n      }\n    })\n\n    type FnType = Extract<AxChatRequest['chatPrompt'][0], { role: 'function' }>\n\n    const toolResults: AxAICohereChatRequest['tool_results'] = (\n      req.chatPrompt as FnType[]\n    )\n      .filter((chat) => chat.role === 'function')\n      .map((chat) => {\n        const fn = tools?.find((t) => t.name === chat.functionId)\n        if (!fn) {\n          throw new Error('Function not found')\n        }\n        return {\n          call: { name: fn.name, parameters: fn.parameter_definitions },\n          outputs: [{ result: chat.result ?? '' }],\n        }\n      })\n\n    const apiConfig = {\n      name: '/chat',\n    }\n\n    const reqValue: AxAICohereChatRequest = {\n      message,\n      model,\n      tools,\n      ...(toolResults && !message ? { tool_results: toolResults } : {}),\n      chat_history: chatHistory,\n      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      temperature: req.modelConfig?.temperature ?? this.config.temperature,\n      k: req.modelConfig?.topK ?? this.config.topK,\n      p: req.modelConfig?.topP ?? this.config.topP,\n      frequency_penalty:\n        req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty,\n      presence_penalty:\n        req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n      end_sequences: this.config.endSequences,\n      stop_sequences:\n        req.modelConfig?.stopSequences ?? this.config.stopSequences,\n    }\n\n    return [apiConfig, reqValue]\n  }\n\n  createEmbedReq = (\n    req: Readonly<AxInternalEmbedRequest>\n  ): [AxAPI, AxAICohereEmbedRequest] => {\n    const model = req.embedModel\n\n    if (!model) {\n      throw new Error('Embed model not set')\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty')\n    }\n\n    const apiConfig = {\n      name: '/embed',\n    }\n\n    const reqValue = {\n      model,\n      texts: req.texts ?? [],\n      input_type: 'classification',\n      truncate: '',\n    }\n\n    return [apiConfig, reqValue]\n  }\n\n  createChatResp = (resp: Readonly<AxAICohereChatResponse>): AxChatResponse => {\n    const modelUsage = resp.meta.billed_units\n      ? {\n          promptTokens: resp.meta.billed_units.input_tokens,\n          completionTokens: resp.meta.billed_units.output_tokens,\n          totalTokens:\n            resp.meta.billed_units.input_tokens +\n            resp.meta.billed_units.output_tokens,\n        }\n      : undefined\n\n    let finishReason: AxChatResponse['results'][0]['finishReason']\n    if ('finish_reason' in resp) {\n      switch (resp.finish_reason) {\n        case 'COMPLETE':\n          finishReason = 'stop'\n          break\n        case 'MAX_TOKENS':\n          finishReason = 'length'\n          break\n        case 'ERROR':\n          throw new Error('Finish reason: ERROR')\n        case 'ERROR_TOXIC':\n          throw new Error('Finish reason: CONTENT_FILTER')\n        default:\n          finishReason = 'stop'\n          break\n      }\n    }\n\n    let functionCalls: AxChatResponse['results'][0]['functionCalls']\n\n    if ('tool_calls' in resp) {\n      functionCalls = resp.tool_calls?.map(\n        (v): NonNullable<AxChatResponse['results'][0]['functionCalls']>[0] => {\n          return {\n            id: v.name,\n            type: 'function' as const,\n            function: { name: v.name, params: v.parameters },\n          }\n        }\n      )\n    }\n\n    const results: AxChatResponse['results'] = [\n      {\n        id: resp.generation_id,\n        content: resp.text,\n        functionCalls,\n        finishReason,\n      },\n    ]\n\n    return {\n      results,\n      modelUsage,\n      remoteId: resp.response_id,\n    }\n  }\n\n  createChatStreamResp = (\n    resp: Readonly<AxAICohereChatResponseDelta>,\n    state: object\n  ): AxChatResponse => {\n    const ss = state as {\n      generation_id?: string\n    }\n\n    if (resp.event_type === 'stream-start') {\n      ss.generation_id = resp.generation_id\n    }\n\n    const { results } = this.createChatResp(resp)\n    const result = results[0]\n    if (!result) {\n      throw new Error('No result')\n    }\n\n    result.id = ss.generation_id ?? ''\n    return { results }\n  }\n\n  createEmbedResp(resp: Readonly<AxAICohereEmbedResponse>): AxEmbedResponse {\n    return {\n      remoteId: resp.id,\n      embeddings: resp.embeddings,\n    }\n  }\n}\n\nexport class AxAICohere extends AxBaseAI<\n  AxAICohereChatRequest,\n  AxAICohereEmbedRequest,\n  AxAICohereChatResponse,\n  AxAICohereChatResponseDelta,\n  AxAICohereEmbedResponse\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    modelMap,\n  }: Readonly<Omit<AxAICohereArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Cohere API key not set')\n    }\n    const _config = {\n      ...axAICohereDefaultConfig(),\n      ...config,\n    }\n\n    const aiImpl = new AxAICohereImpl(_config)\n\n    super(aiImpl, {\n      name: 'Cohere',\n      apiURL: 'https://api.cohere.ai/v1',\n      headers: { Authorization: `Bearer ${apiKey}` },\n      modelInfo: axModelInfoCohere,\n      models: { model: _config.model },\n      supportFor: { functions: true, streaming: true },\n      options,\n      modelMap,\n    })\n  }\n}\nfunction createHistory(\n  chatPrompt: Readonly<AxChatRequest['chatPrompt']>\n): AxAICohereChatRequest['chat_history'] {\n  return chatPrompt.map((chat) => {\n    let message: string = ''\n\n    if (\n      chat.role === 'system' ||\n      chat.role === 'assistant' ||\n      chat.role === 'user'\n    ) {\n      if (typeof chat.content === 'string') {\n        message = chat.content\n      } else {\n        throw new Error('Multi-modal content not supported')\n      }\n    }\n\n    switch (chat.role) {\n      case 'user':\n        return { role: 'USER' as const, message }\n      case 'system':\n        return { role: 'SYSTEM' as const, message }\n      case 'assistant': {\n        const toolCalls = createToolCall(chat.functionCalls)\n        return {\n          role: 'CHATBOT' as const,\n          message,\n          tool_calls: toolCalls,\n        }\n      }\n      case 'function': {\n        const functionCalls = chatPrompt\n          .map((v) => {\n            if (v.role === 'assistant') {\n              return v.functionCalls?.find((f) => f.id === chat.functionId)\n            }\n            return undefined\n          })\n          .filter((v) => v !== undefined)\n\n        const call = createToolCall(functionCalls)?.at(0)\n\n        if (!call) {\n          throw new Error('Function call not found')\n        }\n\n        const outputs = [{ result: chat.result }]\n        return {\n          role: 'TOOL' as const,\n          tool_results: [\n            {\n              call,\n              outputs,\n            },\n          ],\n        }\n      }\n      default:\n        throw new Error('Unknown role')\n    }\n  })\n}\nfunction createToolCall(\n  functionCalls: Readonly<\n    Extract<\n      AxChatRequest['chatPrompt'][0],\n      { role: 'assistant' }\n    >['functionCalls']\n  >\n) {\n  return functionCalls?.map((v) => {\n    const parameters =\n      typeof v.function.params === 'string'\n        ? JSON.parse(v.function.params)\n        : v.function.params\n    return { name: v.function.name, parameters }\n  })\n}\n","/**\n * DeepSeek: Models for text generation\n */\nexport enum AxAIDeepSeekModel {\n  DeepSeekChat = 'deepseek-chat',\n  DeepSeekCoder = 'deepseek-coder',\n}\n","import type { AxModelInfo } from '../types.js'\n\nimport { AxAIDeepSeekModel } from './types.js'\n\nexport const axModelInfoDeepSeek: AxModelInfo[] = [\n  {\n    name: AxAIDeepSeekModel.DeepSeekChat,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.14,\n    completionTokenCostPer1M: 0.28,\n  },\n  {\n    name: AxAIDeepSeekModel.DeepSeekCoder,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.14,\n    completionTokenCostPer1M: 0.28,\n  },\n]\n","import {\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js'\nimport { AxAIOpenAI } from '../openai/api.js'\nimport type { AxAIOpenAIConfig } from '../openai/types.js'\nimport type { AxAIServiceOptions } from '../types.js'\n\nimport { axModelInfoDeepSeek } from './info.js'\nimport { AxAIDeepSeekModel } from './types.js'\n\ntype DeepSeekConfig = AxAIOpenAIConfig\n\nexport const axAIDeepSeekDefaultConfig = (): DeepSeekConfig =>\n  structuredClone({\n    model: AxAIDeepSeekModel.DeepSeekChat,\n    ...axBaseAIDefaultConfig(),\n  })\n\nexport const axAIDeepSeekCodeConfig = (): DeepSeekConfig =>\n  structuredClone({\n    model: AxAIDeepSeekModel.DeepSeekCoder,\n    ...axBaseAIDefaultCreativeConfig(),\n  })\n\nexport interface AxAIDeepSeekArgs {\n  name: 'deepseek'\n  apiKey: string\n  config?: Readonly<Partial<DeepSeekConfig>>\n  options?: Readonly<AxAIServiceOptions>\n  modelMap?: Record<string, AxAIDeepSeekModel | string>\n}\n\nexport class AxAIDeepSeek extends AxAIOpenAI {\n  constructor({\n    apiKey,\n    config,\n    options,\n    modelMap,\n  }: Readonly<Omit<AxAIDeepSeekArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('DeepSeek API key not set')\n    }\n    const _config = {\n      ...axAIDeepSeekDefaultConfig(),\n      ...config,\n    }\n    super({\n      apiKey,\n      config: _config,\n      options,\n      apiURL: 'https://api.deepseek.com',\n      modelInfo: axModelInfoDeepSeek,\n      modelMap,\n    })\n\n    super.setName('DeepSeek')\n  }\n}\n","import type { AxModelConfig } from '../types.js'\n\nexport enum AxAIGoogleGeminiModel {\n  Gemini1Pro = 'gemini-1.0-pro',\n  Gemini15Flash = 'gemini-1.5-flash',\n  Gemini15Flash8B = 'gemini-1.5-flash-8b',\n  Gemini15Pro = 'gemini-1.5-pro',\n  Gemma2 = 'gemma-2-27b-it',\n  AQA = 'aqa',\n}\n\nexport enum AxAIGoogleGeminiEmbedModel {\n  TextEmbedding004 = 'text-embedding-004',\n}\n\nexport enum AxAIGoogleGeminiSafetyCategory {\n  HarmCategoryHarassment = 'HARM_CATEGORY_HARASSMENT',\n  HarmCategoryHateSpeech = 'HARM_CATEGORY_HATE_SPEECH',\n  HarmCategorySexuallyExplicit = 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n  HarmCategoryDangerousContent = 'HARM_CATEGORY_DANGEROUS_CONTENT',\n}\n\nexport enum AxAIGoogleGeminiSafetyThreshold {\n  BlockNone = 'BLOCK_NONE',\n  BlockOnlyHigh = 'BLOCK_ONLY_HIGH',\n  BlockMediumAndAbove = 'BLOCK_MEDIUM_AND_ABOVE',\n  BlockLowAndAbove = 'BLOCK_LOW_AND_ABOVE',\n  BlockDefault = 'HARM_BLOCK_THRESHOLD_UNSPECIFIED',\n}\n\nexport type AxAIGoogleGeminiContent =\n  | {\n      role: 'user'\n      parts: (\n        | {\n            text: string\n          }\n        | {\n            inlineData: {\n              mimeType: string\n              data: string\n            }\n          }\n        | {\n            fileData: {\n              mimeType: string\n              fileUri: string\n            }\n          }\n      )[]\n    }\n  | {\n      role: 'model'\n      parts:\n        | {\n            text: string\n          }[]\n        | {\n            functionCall: {\n              name: string\n              args: object\n            }\n          }[]\n    }\n  | {\n      role: 'function'\n      parts: {\n        functionResponse: {\n          name: string\n          response: object\n        }\n      }[]\n    }\n\nexport type AxAIGoogleGeminiToolFunctionDeclaration = {\n  name: string\n  description?: string\n  parameters?: object\n}\n\nexport type AxAIGoogleGeminiToolGoogleSearchRetrieval = {\n  dynamic_retrieval_config: {\n    mode?: 'MODE_DYNAMIC'\n    dynamic_threshold?: number\n  }\n}\n\nexport type AxAIGoogleGeminiTool = {\n  function_declarations?: AxAIGoogleGeminiToolFunctionDeclaration[]\n  code_execution?: object\n  google_search_retrieval?: AxAIGoogleGeminiToolGoogleSearchRetrieval\n}\n\nexport type AxAIGoogleGeminiToolConfig = {\n  function_calling_config: {\n    mode: 'ANY' | 'NONE' | 'AUTO'\n    allowed_function_names?: string[]\n  }\n}\n\nexport type AxAIGoogleGeminiGenerationConfig = {\n  temperature?: number\n  topP?: number\n  topK?: number\n  candidateCount?: number\n  maxOutputTokens?: number\n  stopSequences?: readonly string[]\n}\n\nexport type AxAIGoogleGeminiSafetySettings = {\n  category: AxAIGoogleGeminiSafetyCategory\n  threshold: AxAIGoogleGeminiSafetyThreshold\n}[]\n\nexport type AxAIGoogleGeminiChatRequest = {\n  contents: AxAIGoogleGeminiContent[]\n  tools?: AxAIGoogleGeminiTool[]\n  toolConfig?: AxAIGoogleGeminiToolConfig\n  systemInstruction?: AxAIGoogleGeminiContent\n  generationConfig: AxAIGoogleGeminiGenerationConfig\n  safetySettings?: AxAIGoogleGeminiSafetySettings\n}\n\nexport type AxAIGoogleGeminiChatResponse = {\n  candidates: {\n    content: AxAIGoogleGeminiContent\n\n    finishReason:\n      | 'STOP'\n      | 'MAX_TOKENS'\n      | 'SAFETY'\n      | 'RECITATION'\n      | 'OTHER'\n      | 'MALFORMED_FUNCTION_CALL'\n    citationMetadata: {\n      citations: {\n        startIndex: number\n        endIndex: number\n        uri: string\n        title: string\n        license: string\n        publicationDate: {\n          year: number\n          month: number\n          day: number\n        }\n      }[]\n    }\n  }[]\n  usageMetadata: {\n    promptTokenCount: number\n    candidatesTokenCount: number\n    totalTokenCount: number\n  }\n}\n\nexport type AxAIGoogleGeminiChatResponseDelta = AxAIGoogleGeminiChatResponse\n\n/**\n * AxAIGoogleGeminiConfig: Configuration options for Google Gemini API\n */\nexport type AxAIGoogleGeminiConfig = AxModelConfig & {\n  model: AxAIGoogleGeminiModel | string\n  embedModel?: AxAIGoogleGeminiEmbedModel\n  safetySettings?: AxAIGoogleGeminiSafetySettings\n}\n\n/**\n * AxAIGoogleGeminiEmbedRequest: Structure for making an embedding request to the Google Gemini API.\n */\nexport type AxAIGoogleGeminiBatchEmbedRequest = {\n  requests: {\n    model: string\n    content: {\n      parts: { text: string }[]\n    }\n  }[]\n}\n\n/**\n * AxAIGoogleGeminiEmbedResponse: Structure for handling responses from the Google Gemini API embedding requests.\n */\nexport type AxAIGoogleGeminiBatchEmbedResponse = {\n  embeddings: {\n    values: number[]\n  }[]\n}\n","import type { AxModelInfo } from '../types.js'\n\nimport { AxAIGoogleGeminiModel } from './types.js'\n\n/**\n * AxAIGoogleGemini: Model information\n */\nexport const axModelInfoGoogleGemini: AxModelInfo[] = [\n  {\n    name: AxAIGoogleGeminiModel.Gemini15Flash,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.075,\n    completionTokenCostPer1M: 0.3,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini15Flash8B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.0375,\n    completionTokenCostPer1M: 0.15,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini15Pro,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 1.25,\n    completionTokenCostPer1M: 5.0,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini1Pro,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n]\n","import type { AxAPI } from '../../util/apicall.js'\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js'\nimport type {\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js'\n\nimport { axModelInfoGoogleGemini } from './info.js'\nimport {\n  type AxAIGoogleGeminiBatchEmbedRequest,\n  type AxAIGoogleGeminiBatchEmbedResponse,\n  type AxAIGoogleGeminiChatRequest,\n  type AxAIGoogleGeminiChatResponse,\n  type AxAIGoogleGeminiChatResponseDelta,\n  type AxAIGoogleGeminiConfig,\n  AxAIGoogleGeminiEmbedModel,\n  AxAIGoogleGeminiModel,\n  AxAIGoogleGeminiSafetyCategory,\n  type AxAIGoogleGeminiSafetySettings,\n  AxAIGoogleGeminiSafetyThreshold,\n} from './types.js'\n\nconst safetySettings: AxAIGoogleGeminiSafetySettings = [\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryHarassment,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryHateSpeech,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategorySexuallyExplicit,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryDangerousContent,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n]\n\n/**\n * AxAIGoogleGemini: Default Model options for text generation\n */\nexport const axAIGoogleGeminiDefaultConfig = (): AxAIGoogleGeminiConfig =>\n  structuredClone({\n    model: AxAIGoogleGeminiModel.Gemini15Pro,\n    embedModel: AxAIGoogleGeminiEmbedModel.TextEmbedding004,\n    safetySettings,\n    ...axBaseAIDefaultConfig(),\n  })\n\nexport const axAIGoogleGeminiDefaultCreativeConfig =\n  (): AxAIGoogleGeminiConfig =>\n    structuredClone({\n      model: AxAIGoogleGeminiModel.Gemini15Flash,\n      embedModel: AxAIGoogleGeminiEmbedModel.TextEmbedding004,\n      safetySettings,\n      ...axBaseAIDefaultCreativeConfig(),\n    })\n\nexport interface AxAIGoogleGeminiOptionsTools {\n  codeExecution?: boolean\n  googleSearchRetrieval?: {\n    mode?: 'MODE_DYNAMIC'\n    dynamicThreshold?: number\n  }\n}\n\nexport interface AxAIGoogleGeminiArgs {\n  name: 'google-gemini'\n  apiKey: string\n  projectId?: string\n  region?: string\n  config?: Readonly<Partial<AxAIGoogleGeminiConfig>>\n  options?: Readonly<AxAIServiceOptions & AxAIGoogleGeminiOptionsTools>\n  modelMap?: Record<\n    string,\n    AxAIGoogleGeminiModel | AxAIGoogleGeminiEmbedModel | string\n  >\n}\n\nclass AxAIGoogleGeminiImpl\n  implements\n    AxAIServiceImpl<\n      AxAIGoogleGeminiChatRequest,\n      AxAIGoogleGeminiBatchEmbedRequest,\n      AxAIGoogleGeminiChatResponse,\n      AxAIGoogleGeminiChatResponseDelta,\n      AxAIGoogleGeminiBatchEmbedResponse\n    >\n{\n  constructor(\n    private config: AxAIGoogleGeminiConfig,\n    private apiKey: string,\n    private isVertex: boolean,\n    private options?: AxAIGoogleGeminiArgs['options']\n  ) {}\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      stream: config.stream,\n      n: config.n,\n    } as AxModelConfig\n  }\n\n  createChatReq = (\n    req: Readonly<AxInternalChatRequest>\n  ): [AxAPI, AxAIGoogleGeminiChatRequest] => {\n    const model = req.model\n    const stream = req.modelConfig?.stream ?? this.config.stream\n\n    if (!req.chatPrompt || req.chatPrompt.length === 0) {\n      throw new Error('Chat prompt is empty')\n    }\n\n    const apiConfig = {\n      name: stream\n        ? `/models/${model}:streamGenerateContent?alt=sse`\n        : `/models/${model}:createContent`,\n    }\n\n    if (this.isVertex === false) {\n      const pf = stream ? '&' : '?'\n      apiConfig.name += `${pf}key=${this.apiKey}`\n    }\n\n    const systemPrompts = req.chatPrompt\n      .filter((p) => p.role === 'system')\n      .map((p) => p.content)\n\n    const systemInstruction =\n      systemPrompts.length > 0\n        ? {\n            role: 'user' as const,\n            parts: [{ text: systemPrompts.join(' ') }],\n          }\n        : undefined\n\n    const contents: AxAIGoogleGeminiChatRequest['contents'] = req.chatPrompt\n      .filter((p) => p.role !== 'system')\n      .map((msg, i) => {\n        switch (msg.role) {\n          case 'user': {\n            const parts: Extract<\n              AxAIGoogleGeminiChatRequest['contents'][0],\n              { role: 'user' }\n            >['parts'] = Array.isArray(msg.content)\n              ? msg.content.map((c, i) => {\n                  switch (c.type) {\n                    case 'text':\n                      return { text: c.text }\n                    case 'image':\n                      return {\n                        inlineData: { mimeType: c.mimeType, data: c.image },\n                      }\n                    default:\n                      throw new Error(\n                        `Chat prompt content type not supported (index: ${i})`\n                      )\n                  }\n                })\n              : [{ text: msg.content }]\n            return {\n              role: 'user' as const,\n              parts,\n            }\n          }\n\n          case 'assistant': {\n            let parts: Extract<\n              AxAIGoogleGeminiChatRequest['contents'][0],\n              { role: 'model' }\n            >['parts'] = []\n\n            if (msg.functionCalls) {\n              parts = msg.functionCalls.map((f) => {\n                const args =\n                  typeof f.function.params === 'string'\n                    ? JSON.parse(f.function.params)\n                    : f.function.params\n                return {\n                  functionCall: {\n                    name: f.function.name,\n                    args: args,\n                  },\n                }\n              })\n\n              if (!parts) {\n                throw new Error('Function call is empty')\n              }\n\n              return {\n                role: 'model' as const,\n                parts,\n              }\n            }\n\n            if (!msg.content) {\n              throw new Error('Assistant content is empty')\n            }\n\n            parts = [{ text: msg.content }]\n            return {\n              role: 'model' as const,\n              parts,\n            }\n          }\n\n          case 'function': {\n            if (!('functionId' in msg)) {\n              throw new Error(`Chat prompt functionId is empty (index: ${i})`)\n            }\n            const parts: Extract<\n              AxAIGoogleGeminiChatRequest['contents'][0],\n              { role: 'function' }\n            >['parts'] = [\n              {\n                functionResponse: {\n                  name: msg.functionId,\n                  response: { result: msg.result },\n                },\n              },\n            ]\n\n            return {\n              role: 'function' as const,\n              parts,\n            }\n          }\n\n          default:\n            throw new Error('Invalid role')\n        }\n      })\n\n    let tools: AxAIGoogleGeminiChatRequest['tools'] | undefined = []\n\n    if (req.functions && req.functions.length > 0) {\n      tools.push({ function_declarations: req.functions })\n    }\n\n    if (this.options?.codeExecution) {\n      tools.push({ code_execution: {} })\n    }\n\n    if (this.options?.googleSearchRetrieval) {\n      tools.push({\n        google_search_retrieval: {\n          dynamic_retrieval_config: this.options.googleSearchRetrieval,\n        },\n      })\n    }\n\n    if (tools.length === 0) {\n      tools = undefined\n    }\n\n    let toolConfig\n\n    if (req.functionCall) {\n      if (req.functionCall === 'none') {\n        toolConfig = { function_calling_config: { mode: 'NONE' as const } }\n      } else if (req.functionCall === 'auto') {\n        toolConfig = { function_calling_config: { mode: 'AUTO' as const } }\n      } else if (req.functionCall === 'required') {\n        toolConfig = {\n          function_calling_config: { mode: 'ANY' as const },\n        }\n      } else {\n        const allowedFunctionNames = req.functionCall.function?.name\n          ? {\n              allowedFunctionNames: [req.functionCall.function.name],\n            }\n          : {}\n        toolConfig = {\n          function_calling_config: { mode: 'ANY' as const },\n          ...allowedFunctionNames,\n        }\n      }\n    } else if (tools && tools.length > 0) {\n      toolConfig = { function_calling_config: { mode: 'AUTO' as const } }\n    }\n\n    const generationConfig = {\n      maxOutputTokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      temperature: req.modelConfig?.temperature ?? this.config.temperature,\n      topP: req.modelConfig?.topP ?? this.config.topP,\n      topK: req.modelConfig?.topK ?? this.config.topK,\n      candidateCount: 1,\n      stopSequences:\n        req.modelConfig?.stopSequences ?? this.config.stopSequences,\n    }\n\n    const safetySettings = this.config.safetySettings\n\n    const reqValue: AxAIGoogleGeminiChatRequest = {\n      contents,\n      tools,\n      toolConfig,\n      systemInstruction,\n      generationConfig,\n      safetySettings,\n    }\n\n    return [apiConfig, reqValue]\n  }\n\n  createEmbedReq = (\n    req: Readonly<AxInternalEmbedRequest>\n  ): [AxAPI, AxAIGoogleGeminiBatchEmbedRequest] => {\n    const model = req.embedModel\n\n    if (!model) {\n      throw new Error('Embed model not set')\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty')\n    }\n\n    const apiConfig = {\n      name: `/models/${model}:batchEmbedContents?key=${this.apiKey}`,\n    }\n\n    const reqValue: AxAIGoogleGeminiBatchEmbedRequest = {\n      requests: req.texts.map((text) => ({\n        model: 'models/' + model,\n        content: { parts: [{ text }] },\n      })),\n    }\n\n    return [apiConfig, reqValue]\n  }\n\n  createChatResp = (\n    resp: Readonly<AxAIGoogleGeminiChatResponse>\n  ): AxChatResponse => {\n    const results: AxChatResponseResult[] = resp.candidates?.map(\n      (candidate) => {\n        const result: AxChatResponseResult = {}\n\n        switch (candidate.finishReason) {\n          case 'MAX_TOKENS':\n            result.finishReason = 'length'\n            break\n          case 'STOP':\n            result.finishReason = 'stop'\n            break\n          case 'SAFETY':\n            throw new Error('Finish reason: SAFETY')\n          case 'RECITATION':\n            throw new Error('Finish reason: RECITATION')\n          case 'MALFORMED_FUNCTION_CALL':\n            throw new Error('Finish reason: MALFORMED_FUNCTION_CALL')\n        }\n\n        if (!candidate.content || !candidate.content.parts) {\n          return result\n        }\n\n        for (const part of candidate.content.parts) {\n          if ('text' in part) {\n            result.content = part.text\n            continue\n          }\n          if ('functionCall' in part) {\n            result.functionCalls = [\n              {\n                id: part.functionCall.name,\n                type: 'function',\n                function: {\n                  name: part.functionCall.name,\n                  params: part.functionCall.args,\n                },\n              },\n            ]\n          }\n        }\n        return result\n      }\n    )\n\n    let modelUsage: AxTokenUsage | undefined\n    if (resp.usageMetadata) {\n      modelUsage = {\n        totalTokens: resp.usageMetadata.totalTokenCount,\n        promptTokens: resp.usageMetadata.promptTokenCount,\n        completionTokens: resp.usageMetadata.candidatesTokenCount,\n      }\n    }\n    return {\n      results,\n      modelUsage,\n    }\n  }\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIGoogleGeminiChatResponseDelta>\n  ): AxChatResponse => {\n    return this.createChatResp(resp)\n  }\n\n  createEmbedResp = (\n    resp: Readonly<AxAIGoogleGeminiBatchEmbedResponse>\n  ): AxEmbedResponse => {\n    const embeddings = resp.embeddings.map((embedding) => embedding.values)\n\n    return {\n      embeddings,\n    }\n  }\n}\n\n/**\n * AxAIGoogleGemini: AI Service\n */\nexport class AxAIGoogleGemini extends AxBaseAI<\n  AxAIGoogleGeminiChatRequest,\n  AxAIGoogleGeminiBatchEmbedRequest,\n  AxAIGoogleGeminiChatResponse,\n  AxAIGoogleGeminiChatResponseDelta,\n  AxAIGoogleGeminiBatchEmbedResponse\n> {\n  constructor({\n    apiKey,\n    projectId,\n    region,\n    config,\n    options,\n    modelMap,\n  }: Readonly<Omit<AxAIGoogleGeminiArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('GoogleGemini AI API key not set')\n    }\n\n    const isVertex = projectId !== undefined && region !== undefined\n\n    let apiURL\n    let headers\n\n    if (isVertex) {\n      apiURL = `https://${region}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${region}/publishers/google/`\n      headers = { Authorization: `Bearer ${apiKey}` }\n    } else {\n      apiURL = 'https://generativelanguage.googleapis.com/v1beta'\n      headers = {}\n    }\n\n    const _config = {\n      ...axAIGoogleGeminiDefaultConfig(),\n      ...config,\n    }\n\n    const aiImpl = new AxAIGoogleGeminiImpl(_config, apiKey, isVertex, options)\n\n    super(aiImpl, {\n      name: 'GoogleGeminiAI',\n      apiURL,\n      headers,\n      modelInfo: axModelInfoGoogleGemini,\n      models: {\n        model: _config.model as AxAIGoogleGeminiModel,\n        embedModel: _config.embedModel as AxAIGoogleGeminiEmbedModel,\n      },\n      options,\n      supportFor: { functions: true, streaming: true },\n      modelMap,\n    })\n  }\n}\n","import { ColorLog } from './log.js'\n\nconst colorLog = new ColorLog()\n\nexport interface AxRateLimiterTokenUsageOptions {\n  debug?: boolean\n}\n\nexport class AxRateLimiterTokenUsage {\n  private options?: Readonly<AxRateLimiterTokenUsageOptions>\n  private maxTokens: number\n  private refillRate: number\n  private currentTokens: number\n  private lastRefillTime: number\n\n  constructor(\n    maxTokens: number,\n    refillRate: number,\n    options?: Readonly<AxRateLimiterTokenUsageOptions>\n  ) {\n    this.maxTokens = maxTokens\n    this.refillRate = refillRate\n    this.currentTokens = maxTokens\n    this.lastRefillTime = Date.now()\n    this.options = options\n  }\n\n  private refillTokens() {\n    const now = Date.now()\n    const timeElapsed = (now - this.lastRefillTime) / 1000 // Convert ms to seconds\n    const tokensToAdd = timeElapsed * this.refillRate\n    this.currentTokens = Math.min(\n      this.maxTokens,\n      this.currentTokens + tokensToAdd\n    )\n    this.lastRefillTime = now\n  }\n\n  private async waitUntilTokensAvailable(tokens: number): Promise<void> {\n    this.refillTokens()\n    if (this.currentTokens >= tokens) {\n      this.currentTokens -= tokens\n      return\n    }\n    if (this.options?.debug) {\n      console.log(\n        colorLog.red(\n          `Rate limiter: Waiting for ${tokens - this.currentTokens} tokens`\n        )\n      )\n    }\n    await new Promise((resolve) => setTimeout(resolve, 100)) // Wait for 100ms before checking again\n    return this.waitUntilTokensAvailable(tokens) // Recursive call\n  }\n\n  public async acquire(tokens: number): Promise<void> {\n    await this.waitUntilTokensAvailable(tokens)\n  }\n}\n\n/**\n * Example usage of the rate limiter. Limits to 5800 tokens per minute.\nconst rateLimiter = new AxRateLimiterTokenUsage(5800, 5800 / 60);\n\nconst axRateLimiterFunction = async (func, info) => {\n  const totalTokens = info.modelUsage?.totalTokens || 0;\n  await rateLimiter.acquire(totalTokens);\n  return func();\n};\n**/\n","export enum AxAIGroqModel {\n  Llama3_8B = 'llama3-8b-8192',\n  Llama3_70B = 'llama3-70b-8192',\n  Mixtral_8x7B = 'mixtral-8x7b-32768',\n  Gemma_7B = 'gemma-7b-it',\n}\n","import type { AxModelInfo } from '../types.js'\n\nimport { AxAIGroqModel } from './types.js'\n\n/**\n * AxAIGroq: Model information\n */\nexport const axModelInfoGroq: AxModelInfo[] = [\n  {\n    name: AxAIGroqModel.Gemma_7B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.2,\n    completionTokenCostPer1M: 0.2,\n  },\n  {\n    name: AxAIGroqModel.Llama3_70B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.59,\n    completionTokenCostPer1M: 0.79,\n  },\n  {\n    name: AxAIGroqModel.Llama3_8B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.05,\n    completionTokenCostPer1M: 0.08,\n  },\n  {\n    name: AxAIGroqModel.Mixtral_8x7B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.24,\n    completionTokenCostPer1M: 0.24,\n  },\n]\n","import { AxRateLimiterTokenUsage } from '../../util/rate-limit.js'\nimport { axBaseAIDefaultConfig } from '../base.js'\nimport { AxAIOpenAI } from '../openai/api.js'\nimport type { AxAIOpenAIConfig } from '../openai/types.js'\nimport type { AxAIServiceOptions, AxRateLimiterFunction } from '../types.js'\n\nimport { axModelInfoGroq } from './info.js'\nimport { AxAIGroqModel } from './types.js'\n\ntype AxAIGroqAIConfig = AxAIOpenAIConfig\n\nconst axAIGroqDefaultConfig = (): AxAIGroqAIConfig =>\n  structuredClone({\n    model: AxAIGroqModel.Llama3_70B,\n    ...axBaseAIDefaultConfig(),\n  })\n\nexport interface AxAIGroqArgs {\n  name: 'groq'\n  apiKey: string\n  config?: Readonly<Partial<AxAIGroqAIConfig>>\n  options?: Readonly<AxAIServiceOptions> & { tokensPerMinute?: number }\n  modelMap?: Record<string, AxAIGroqModel>\n}\n\nexport class AxAIGroq extends AxAIOpenAI {\n  constructor({\n    apiKey,\n    config,\n    options,\n    modelMap,\n  }: Readonly<Omit<AxAIGroqArgs, 'groq'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Groq API key not set')\n    }\n    const _config = {\n      ...axAIGroqDefaultConfig(),\n      ...config,\n    }\n\n    const _options = {\n      ...options,\n      streamingUsage: false,\n    }\n\n    super({\n      apiKey,\n      config: _config,\n      options: _options,\n      modelInfo: axModelInfoGroq,\n      apiURL: 'https://api.groq.com/openai/v1',\n      modelMap,\n    })\n\n    super.setName('Groq')\n    this.setOptions(_options)\n  }\n\n  override setOptions = (options: Readonly<AxAIServiceOptions>) => {\n    const rateLimiter = this.newRateLimiter(options)\n    super.setOptions({ ...options, rateLimiter })\n  }\n\n  private newRateLimiter = (options: Readonly<AxAIGroqArgs['options']>) => {\n    if (options?.rateLimiter) {\n      return options.rateLimiter\n    }\n\n    const tokensPerMin = options?.tokensPerMinute ?? 4800\n    const rt = new AxRateLimiterTokenUsage(tokensPerMin, tokensPerMin / 60, {\n      debug: options?.debug,\n    })\n\n    const rtFunc: AxRateLimiterFunction = async (func, info) => {\n      const totalTokens = info.modelUsage?.totalTokens || 0\n      await rt.acquire(totalTokens)\n      return await func()\n    }\n\n    return rtFunc\n  }\n}\n","import type { AxModelInfo } from '../types.js'\n\n/**\n * HuggingFace: Model information\n */\nexport const axModelInfoHuggingFace: AxModelInfo[] = []\n","import type { AxModelConfig } from '../types.js'\n\nexport enum AxAIHuggingFaceModel {\n  MetaLlama270BChatHF = 'meta-llama/Llama-2-70b-chat-hf',\n}\n\nexport type AxAIHuggingFaceConfig = AxModelConfig & {\n  model: AxAIHuggingFaceModel\n  returnFullText?: boolean\n  doSample?: boolean\n  maxTime?: number\n  useCache?: boolean\n  waitForModel?: boolean\n}\n\nexport type AxAIHuggingFaceRequest = {\n  model: AxAIHuggingFaceModel | string\n  inputs: string\n  parameters: {\n    max_new_tokens?: number\n    repetition_penalty?: number\n    temperature?: number\n    top_p?: number\n    top_k?: number\n    return_full_text?: boolean\n    num_return_sequences?: number\n    do_sample?: boolean\n    max_time?: number\n  }\n  options?: {\n    use_cache?: boolean\n    wait_for_model?: boolean\n  }\n}\n\nexport type AxAIHuggingFaceResponse = {\n  generated_text: string\n}\n","import type { AxAPI } from '../../util/apicall.js'\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js'\nimport type {\n  AxAIPromptConfig,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxInternalChatRequest,\n  AxModelConfig,\n} from '../types.js'\n\nimport { axModelInfoHuggingFace } from './info.js'\nimport {\n  type AxAIHuggingFaceConfig,\n  AxAIHuggingFaceModel,\n  type AxAIHuggingFaceRequest,\n  type AxAIHuggingFaceResponse,\n} from './types.js'\n\nexport const axAIHuggingFaceDefaultConfig = (): AxAIHuggingFaceConfig =>\n  structuredClone({\n    model: AxAIHuggingFaceModel.MetaLlama270BChatHF,\n    ...axBaseAIDefaultConfig(),\n  })\n\nexport const axAIHuggingFaceCreativeConfig = (): AxAIHuggingFaceConfig =>\n  structuredClone({\n    model: AxAIHuggingFaceModel.MetaLlama270BChatHF,\n    ...axBaseAIDefaultCreativeConfig(),\n  })\n\nexport interface AxAIHuggingFaceArgs {\n  name: 'huggingface'\n  apiKey: string\n  config?: Readonly<Partial<AxAIHuggingFaceConfig>>\n  options?: Readonly<AxAIServiceOptions>\n  modelMap?: Record<string, AxAIHuggingFaceModel>\n}\n\nclass AxAIHuggingFaceImpl\n  implements\n    AxAIServiceImpl<\n      AxAIHuggingFaceRequest,\n      unknown,\n      AxAIHuggingFaceResponse,\n      unknown,\n      unknown\n    >\n{\n  constructor(private config: AxAIHuggingFaceConfig) {}\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      n: config.n,\n      presencePenalty: config.presencePenalty,\n    } as AxModelConfig\n  }\n\n  createChatReq = (\n    req: Readonly<AxInternalChatRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _config: Readonly<AxAIPromptConfig>\n  ): [AxAPI, AxAIHuggingFaceRequest] => {\n    const model = req.model\n\n    const functionsList = req.functions\n      ? `Functions:\\n${JSON.stringify(req.functions, null, 2)}\\n`\n      : ''\n\n    const prompt = req.chatPrompt\n      ?.map((msg) => {\n        switch (msg.role) {\n          case 'user':\n            return `User: ${msg.content}`\n          case 'system':\n            return `System: ${msg.content}`\n          case 'function':\n            return `Function Result: ${msg.result}`\n          case 'assistant': {\n            const fc = msg.functionCalls\n              ?.map((fc) => {\n                const args =\n                  typeof fc.function.params === 'string'\n                    ? fc.function.params\n                    : JSON.stringify(fc.function.params)\n\n                return `${fc.function.name}(${args})`\n              })\n              .join('\\n')\n            if (fc) {\n              return `Assistant: ${msg.content}\\n Functions:\\n${fc}`\n            }\n            return `Assistant: ${msg.content}`\n          }\n          default:\n            throw new Error(`Unknown role`)\n        }\n\n        //return `${msg.role}: ${msg.content}`;\n      })\n      .join('\\n')\n\n    const inputs = `${functionsList} ${prompt}`.trim()\n\n    const apiConfig = {\n      name: '/models',\n    }\n\n    const reqValue: AxAIHuggingFaceRequest = {\n      model,\n      inputs,\n      parameters: {\n        max_new_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n        repetition_penalty:\n          req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n        temperature: req.modelConfig?.temperature ?? this.config.temperature,\n        top_p: req.modelConfig?.topP ?? this.config.topP,\n        top_k: req.modelConfig?.topK ?? this.config.topK,\n        return_full_text: this.config.returnFullText,\n        num_return_sequences: this.config.n,\n        do_sample: this.config.doSample,\n        max_time: this.config.maxTime,\n      },\n      options: {\n        use_cache: this.config.useCache,\n        wait_for_model: this.config.waitForModel,\n      },\n    }\n\n    return [apiConfig, reqValue]\n  }\n\n  createChatResp = (\n    resp: Readonly<AxAIHuggingFaceResponse>\n  ): AxChatResponse => {\n    return {\n      results: [\n        {\n          content: resp.generated_text,\n        },\n      ],\n    }\n  }\n}\n\nexport class AxAIHuggingFace extends AxBaseAI<\n  AxAIHuggingFaceRequest,\n  unknown,\n  AxAIHuggingFaceResponse,\n  unknown,\n  unknown\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    modelMap,\n  }: Readonly<Omit<AxAIHuggingFaceArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('HuggingFace API key not set')\n    }\n    const _config = {\n      ...axAIHuggingFaceDefaultConfig(),\n      ...config,\n    }\n\n    const aiImpl = new AxAIHuggingFaceImpl(_config)\n\n    super(aiImpl, {\n      name: 'HuggingFace',\n      apiURL: 'https://api-inference.huggingface.co',\n      headers: { Authorization: `Bearer ${apiKey}` },\n      modelInfo: axModelInfoHuggingFace,\n      models: { model: _config.model },\n      options,\n      supportFor: { functions: false, streaming: false },\n      modelMap,\n    })\n  }\n}\n","// cspell:ignore mistral, mixtral, codestral, nemo\n\nexport enum AxAIMistralModel {\n  Mistral7B = 'open-mistral-7b',\n  Mistral8x7B = 'open-mixtral-8x7b',\n  MistralSmall = 'mistral-small-latest',\n  MistralNemo = 'mistral-nemo-latest',\n  MistralLarge = 'mistral-large-latest',\n  Codestral = 'codestral-latest',\n  OpenCodestralMamba = 'open-codestral-mamba',\n  OpenMistralNemo = 'open-mistral-nemo-latest',\n}\n\nexport enum AxAIMistralEmbedModels {\n  MistralEmbed = 'mistral-embed',\n}\n","// cspell:ignore mistral, mixtral, codestral, nemo\n\nimport type { AxModelInfo } from '../types.js'\n\nimport { AxAIMistralModel } from './types.js'\n\nexport const axModelInfoMistral: AxModelInfo[] = [\n  {\n    name: AxAIMistralModel.Mistral7B,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.25,\n    completionTokenCostPer1M: 0.25,\n  },\n  {\n    name: AxAIMistralModel.Mistral8x7B,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.7,\n    completionTokenCostPer1M: 0.7,\n  },\n  {\n    name: AxAIMistralModel.MistralNemo,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.15,\n    completionTokenCostPer1M: 0.15,\n  },\n  {\n    name: AxAIMistralModel.MistralSmall,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.2,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIMistralModel.MistralLarge,\n    currency: 'USD',\n    promptTokenCostPer1M: 2,\n    completionTokenCostPer1M: 6,\n  },\n  {\n    name: AxAIMistralModel.Codestral,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.2,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIMistralModel.OpenCodestralMamba,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.25,\n    completionTokenCostPer1M: 0.25,\n  },\n  {\n    name: AxAIMistralModel.OpenMistralNemo,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.3,\n    completionTokenCostPer1M: 0.3,\n  },\n]\n","import { axBaseAIDefaultConfig } from '../base.js'\nimport { AxAIOpenAI } from '../openai/api.js'\nimport type { AxAIOpenAIConfig } from '../openai/types.js'\nimport type { AxAIServiceOptions } from '../types.js'\n\nimport { axModelInfoMistral } from './info.js'\nimport { AxAIMistralEmbedModels, AxAIMistralModel } from './types.js'\n\ntype MistralConfig = AxAIOpenAIConfig\n\nexport const axAIMistralDefaultConfig = (): MistralConfig =>\n  structuredClone({\n    model: AxAIMistralModel.MistralSmall,\n    ...axBaseAIDefaultConfig(),\n  })\n\nexport const axAIMistralBestConfig = (): AxAIOpenAIConfig =>\n  structuredClone({\n    ...axAIMistralDefaultConfig(),\n    model: AxAIMistralModel.MistralLarge,\n  })\n\nexport interface AxAIMistralArgs {\n  name: 'mistral'\n  apiKey: string\n  config?: Readonly<Partial<MistralConfig>>\n  options?: Readonly<AxAIServiceOptions>\n  modelMap?: Record<string, AxAIMistralModel | AxAIMistralEmbedModels | string>\n}\n\nexport class AxAIMistral extends AxAIOpenAI {\n  constructor({\n    apiKey,\n    config,\n    options,\n    modelMap,\n  }: Readonly<Omit<AxAIMistralArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Mistral API key not set')\n    }\n    const _config = {\n      ...axAIMistralDefaultConfig(),\n      ...config,\n    }\n    super({\n      apiKey,\n      config: _config,\n      options,\n      apiURL: 'https://api.mistral.ai/v1',\n      modelInfo: axModelInfoMistral,\n      modelMap,\n    })\n\n    super.setName('Mistral')\n  }\n}\n","import {\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js'\nimport { AxAIOpenAI } from '../openai/api.js'\nimport type { AxAIOpenAIConfig } from '../openai/types.js'\nimport type { AxAIServiceOptions } from '../types.js'\n\nexport type AxAIOllamaAIConfig = AxAIOpenAIConfig\n\nexport const axAIOllamaDefaultConfig = (): AxAIOllamaAIConfig =>\n  structuredClone({\n    ...axBaseAIDefaultConfig(),\n    model: 'nous-hermes2',\n    embedModel: 'all-minilm',\n  })\n\nexport const axAIOllamaDefaultCreativeConfig = (): AxAIOllamaAIConfig =>\n  structuredClone({\n    ...axBaseAIDefaultCreativeConfig(),\n    model: 'nous-hermes2',\n    embedModel: 'all-minilm',\n  })\n\nexport type AxAIOllamaArgs = {\n  name: 'ollama'\n  model?: string\n  embedModel?: string\n  url?: string\n  apiKey?: string\n  config?: Readonly<Partial<AxAIOllamaAIConfig>>\n  options?: Readonly<AxAIServiceOptions>\n  modelMap?: Record<string, string>\n}\n\n/**\n * OllamaAI: AI Service\n */\nexport class AxAIOllama extends AxAIOpenAI {\n  constructor({\n    apiKey = 'not-set',\n    url = 'http://localhost:11434/v1',\n    config,\n    options,\n    modelMap,\n  }: Readonly<Omit<AxAIOllamaArgs, 'name'>>) {\n    const _config = {\n      ...axAIOllamaDefaultConfig(),\n      ...config,\n    }\n    super({\n      apiKey,\n      options,\n      config: _config,\n      apiURL: url,\n      modelMap,\n    })\n\n    super.setName('Ollama')\n  }\n}\n","import type { AxModelConfig } from '../types.js'\n\nexport enum AxAIRekaModel {\n  RekaCore = 'reka-core',\n  RekaFlash = 'reka-flash',\n  RekaEdge = 'reka-edge',\n}\n\nexport type AxAIRekaConfig = Omit<AxModelConfig, 'topK'> & {\n  model: AxAIRekaModel | string\n  stop?: readonly string[]\n  useSearchEngine?: boolean\n}\n\nexport type AxAIRekaUsage = {\n  input_tokens: number\n  output_tokens: number\n}\n\nexport type AxAIRekaChatRequest = {\n  model: string\n  messages: (\n    | {\n        role: 'user'\n        content:\n          | string\n          | {\n              type: 'text'\n              text: string\n            }[]\n      }\n    | {\n        role: 'assistant'\n        content:\n          | string\n          | {\n              type: 'text'\n              text: string\n            }[]\n      }\n  )[]\n  usage?: AxAIRekaUsage\n  response_format?: { type: string }\n  max_tokens: number\n  temperature?: number\n  top_p?: number\n  top_k?: number\n  stream?: boolean\n  stop?: readonly string[]\n  presence_penalty?: number\n  frequency_penalty?: number\n  use_search_engine?: boolean\n}\n\nexport type AxAIRekaChatResponse = {\n  id: string\n  model: string\n  responses: {\n    message: {\n      content:\n        | string\n        | {\n            type: 'text'\n            text: string\n          }\n    }\n    finish_reason: 'stop' | 'length' | 'context'\n  }[]\n  usage?: AxAIRekaUsage\n}\n\nexport type AxAIRekaChatResponseDelta = {\n  id: string\n  model: string\n  responses: {\n    chunk: AxAIRekaChatResponse['responses'][0]['message']\n    finish_reason: AxAIRekaChatResponse['responses'][0]['finish_reason']\n  }[]\n  usage?: AxAIRekaUsage\n}\n","import type { AxModelInfo } from '../types.js'\n\nimport { AxAIRekaModel } from './types.js'\n/**\n * OpenAI: Model information\n */\nexport const axModelInfoReka: AxModelInfo[] = [\n  {\n    name: AxAIRekaModel.RekaCore,\n    currency: 'usd',\n    promptTokenCostPer1M: 3,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIRekaModel.RekaFlash,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.8,\n    completionTokenCostPer1M: 2,\n  },\n  {\n    name: AxAIRekaModel.RekaEdge,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.4,\n    completionTokenCostPer1M: 1,\n  },\n]\n","import type { AxAPI } from '../../util/apicall.js'\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js'\nimport type {\n  AxAIPromptConfig,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxInternalChatRequest,\n  AxModelConfig,\n  AxModelInfo,\n} from '../types.js'\n\nimport { axModelInfoReka } from './info.js'\nimport {\n  type AxAIRekaChatRequest,\n  type AxAIRekaChatResponse,\n  type AxAIRekaChatResponseDelta,\n  type AxAIRekaConfig,\n  AxAIRekaModel,\n} from './types.js'\n\nexport const axAIRekaDefaultConfig = (): AxAIRekaConfig =>\n  structuredClone({\n    model: AxAIRekaModel.RekaCore,\n    ...axBaseAIDefaultConfig(),\n  })\n\nexport const axAIRekaBestConfig = (): AxAIRekaConfig =>\n  structuredClone({\n    ...axAIRekaDefaultConfig(),\n    model: AxAIRekaModel.RekaCore,\n  })\n\nexport const axAIRekaCreativeConfig = (): AxAIRekaConfig =>\n  structuredClone({\n    model: AxAIRekaModel.RekaCore,\n    ...axBaseAIDefaultCreativeConfig(),\n  })\n\nexport const axAIRekaFastConfig = (): AxAIRekaConfig => ({\n  ...axAIRekaDefaultConfig(),\n  model: AxAIRekaModel.RekaFlash,\n})\n\nexport interface AxAIRekaArgs {\n  name: 'reka'\n  apiKey: string\n  apiURL?: string\n  config?: Readonly<Partial<AxAIRekaConfig>>\n  options?: Readonly<AxAIServiceOptions & { streamingUsage?: boolean }>\n  modelInfo?: Readonly<AxModelInfo[]>\n  modelMap?: Record<string, AxAIRekaModel | string>\n}\n\nclass AxAIRekaImpl\n  implements\n    AxAIServiceImpl<\n      AxAIRekaChatRequest,\n      unknown,\n      AxAIRekaChatResponse,\n      AxAIRekaChatResponseDelta,\n      unknown\n    >\n{\n  constructor(private config: AxAIRekaConfig) {}\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      topP: config.topP,\n      n: config.n,\n      stream: config.stream,\n    }\n  }\n\n  createChatReq = (\n    req: Readonly<AxInternalChatRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _config: Readonly<AxAIPromptConfig>\n  ): [AxAPI, AxAIRekaChatRequest] => {\n    const model = req.model\n\n    if (!req.chatPrompt || req.chatPrompt.length === 0) {\n      throw new Error('Chat prompt is empty')\n    }\n\n    const apiConfig = {\n      name: '/chat/completions',\n    }\n\n    const messages = createMessages(req)\n\n    const frequencyPenalty =\n      req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty\n\n    const stream = req.modelConfig?.stream ?? this.config.stream\n\n    const reqValue: AxAIRekaChatRequest = {\n      model,\n      messages,\n      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens ?? 500,\n      temperature: req.modelConfig?.temperature ?? this.config.temperature,\n      top_k: req.modelConfig?.n ?? this.config.n,\n      top_p: req.modelConfig?.topP ?? this.config.topP ?? 1,\n      stop: req.modelConfig?.stopSequences ?? this.config.stop,\n      presence_penalty:\n        req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n      ...(frequencyPenalty ? { frequency_penalty: frequencyPenalty } : {}),\n      ...(stream ? { stream: true } : {}),\n    }\n\n    return [apiConfig, reqValue]\n  }\n\n  createChatResp = (resp: Readonly<AxAIRekaChatResponse>): AxChatResponse => {\n    const { id, usage, responses } = resp\n\n    const modelUsage = usage\n      ? {\n          promptTokens: usage.input_tokens,\n          completionTokens: usage.output_tokens,\n          totalTokens: usage.input_tokens + usage.output_tokens,\n        }\n      : undefined\n\n    const results = responses.map((res) => {\n      const finishReason = mapFinishReason(res.finish_reason)\n      let content\n      if (typeof res.message.content === 'string') {\n        content = res.message.content\n      } else {\n        content = res.message.content.text\n      }\n\n      return {\n        id: `${id}`,\n        content,\n        finishReason,\n      }\n    })\n\n    return {\n      modelUsage,\n      results,\n      remoteId: id,\n    }\n  }\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIRekaChatResponseDelta>\n  ): AxChatResponse => {\n    const { id, usage, responses } = resp\n\n    const modelUsage = usage\n      ? {\n          promptTokens: usage.input_tokens,\n          completionTokens: usage.output_tokens,\n          totalTokens: usage.input_tokens + usage.output_tokens,\n        }\n      : undefined\n\n    const results = responses.map((res) => {\n      const finishReason = mapFinishReason(res.finish_reason)\n      let content\n      if (typeof res.chunk.content === 'string') {\n        content = res.chunk.content\n      } else {\n        content = res.chunk.content.text\n      }\n\n      return {\n        id: `${id}`,\n        content,\n        finishReason,\n      }\n    })\n\n    return {\n      results,\n      modelUsage,\n    }\n  }\n}\n\nconst mapFinishReason = (\n  finishReason: AxAIRekaChatResponse['responses'][0]['finish_reason']\n): AxChatResponseResult['finishReason'] => {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop' as const\n    case 'context':\n      return 'length' as const\n    case 'length':\n      return 'length' as const\n  }\n}\n\nfunction createMessages(\n  req: Readonly<AxChatRequest>\n): AxAIRekaChatRequest['messages'] {\n  return req.chatPrompt.map((msg) => {\n    switch (msg.role) {\n      case 'system':\n        return { role: 'user' as const, content: msg.content }\n\n      case 'user':\n        if (Array.isArray(msg.content)) {\n          return {\n            role: 'user' as const,\n            content: msg.content.map((c) => {\n              switch (c.type) {\n                case 'text':\n                  return { type: 'text' as const, text: c.text }\n                case 'image': {\n                  throw new Error('Image type not supported')\n                }\n                default:\n                  throw new Error('Invalid content type')\n              }\n            }),\n          }\n        }\n        return { role: 'user' as const, content: msg.content }\n\n      case 'assistant':\n        if (Array.isArray(msg.content)) {\n          return {\n            role: 'assistant' as const,\n            content: msg.content.map((c) => {\n              switch (c.type) {\n                case 'text':\n                  return { type: 'text' as const, text: c.text }\n                case 'image': {\n                  throw new Error('Image type not supported')\n                }\n                default:\n                  throw new Error('Invalid content type')\n              }\n            }),\n          }\n        }\n        if (!msg.content) {\n          throw new Error('Assistant content is empty')\n        }\n        return { role: 'user' as const, content: msg.content }\n      default:\n        throw new Error('Invalid role')\n    }\n  })\n}\n\nexport class AxAIReka extends AxBaseAI<\n  AxAIRekaChatRequest,\n  unknown,\n  AxAIRekaChatResponse,\n  AxAIRekaChatResponseDelta,\n  unknown\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    apiURL,\n    modelInfo = axModelInfoReka,\n    modelMap,\n  }: Readonly<Omit<AxAIRekaArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Reka API key not set')\n    }\n    const _config = {\n      ...axAIRekaDefaultConfig(),\n      ...config,\n    }\n\n    const aiImpl = new AxAIRekaImpl(_config)\n\n    super(aiImpl, {\n      name: 'Reka',\n      apiURL: apiURL ? apiURL : 'https://api.reka.ai/v1/chat',\n      headers: { 'X-Api-Key': apiKey },\n      modelInfo,\n      models: {\n        model: _config.model as string,\n      },\n      options,\n      supportFor: { functions: true, streaming: true },\n      modelMap,\n    })\n  }\n}\n","import type { AxModelInfo } from '../types.js'\n\nexport const axModelInfoTogether: AxModelInfo[] = []\n","import { axBaseAIDefaultConfig } from '../base.js'\nimport { AxAIOpenAI } from '../openai/api.js'\nimport type { AxAIOpenAIConfig } from '../openai/types.js'\nimport type { AxAIServiceOptions } from '../types.js'\n\nimport { axModelInfoTogether } from './info.js'\n\ntype TogetherAIConfig = AxAIOpenAIConfig\n\nexport const axAITogetherDefaultConfig = (): TogetherAIConfig =>\n  structuredClone({\n    // cspell:disable-next-line\n    model: 'mistralai/Mixtral-8x7B-Instruct-v0.1',\n    ...axBaseAIDefaultConfig(),\n  })\n\nexport interface AxAITogetherArgs {\n  name: 'together'\n  apiKey: string\n  config?: Readonly<Partial<TogetherAIConfig>>\n  options?: Readonly<AxAIServiceOptions>\n  modelMap?: Record<string, string>\n}\n\nexport class AxAITogether extends AxAIOpenAI {\n  constructor({\n    apiKey,\n    config,\n    options,\n    modelMap,\n  }: Readonly<Omit<AxAITogetherArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Together API key not set')\n    }\n    const _config = {\n      ...axAITogetherDefaultConfig(),\n      ...config,\n    }\n    super({\n      apiKey,\n      config: _config,\n      options,\n      apiURL: 'https://api.together.xyz/v1',\n      modelInfo: axModelInfoTogether,\n      modelMap,\n    })\n\n    super.setName('Together')\n  }\n}\n","import type { ReadableStream } from 'stream/web'\n\nimport { AxAIAnthropic, type AxAIAnthropicArgs } from './anthropic/api.js'\nimport type { AxAIAnthropicModel } from './anthropic/types.js'\nimport {\n  AxAIAzureOpenAI,\n  type AxAIAzureOpenAIArgs,\n} from './azure-openai/api.js'\nimport { AxAICohere, type AxAICohereArgs } from './cohere/api.js'\nimport type { AxAICohereEmbedModel, AxAICohereModel } from './cohere/types.js'\nimport { AxAIDeepSeek, type AxAIDeepSeekArgs } from './deepseek/api.js'\nimport type { AxAIDeepSeekModel } from './deepseek/types.js'\nimport {\n  AxAIGoogleGemini,\n  type AxAIGoogleGeminiArgs,\n} from './google-gemini/api.js'\nimport type {\n  AxAIGoogleGeminiEmbedModel,\n  AxAIGoogleGeminiModel,\n} from './google-gemini/types.js'\nimport { AxAIGroq, type AxAIGroqArgs } from './groq/api.js'\nimport type { AxAIGroqModel } from './groq/types.js'\nimport { AxAIHuggingFace, type AxAIHuggingFaceArgs } from './huggingface/api.js'\nimport type { AxAIHuggingFaceModel } from './huggingface/types.js'\nimport { AxAIMistral, type AxAIMistralArgs } from './mistral/api.js'\nimport type { AxAIMistralModel } from './mistral/types.js'\nimport { AxAIOllama, type AxAIOllamaArgs } from './ollama/api.js'\nimport {\n  AxAIOpenAI,\n  type AxAIOpenAIArgs as AxAIOpenAIArgs,\n} from './openai/api.js'\nimport type { AxAIOpenAIEmbedModel, AxAIOpenAIModel } from './openai/types.js'\nimport { AxAIReka, type AxAIRekaArgs } from './reka/api.js'\nimport { AxAITogether, type AxAITogetherArgs } from './together/api.js'\nimport type {\n  AxAIModelMap,\n  AxAIPromptConfig,\n  AxAIService,\n  AxAIServiceActionOptions,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxModelInfoWithProvider,\n} from './types.js'\n\nexport type AxAIArgs =\n  | AxAIOpenAIArgs\n  | AxAIAzureOpenAIArgs\n  | AxAITogetherArgs\n  | AxAIAnthropicArgs\n  | AxAIGroqArgs\n  | AxAIGoogleGeminiArgs\n  | AxAICohereArgs\n  | AxAIHuggingFaceArgs\n  | AxAIMistralArgs\n  | AxAIDeepSeekArgs\n  | AxAIOllamaArgs\n  | AxAIRekaArgs\n\nexport type AxAIModels =\n  | AxAIOpenAIModel\n  | AxAIAnthropicModel\n  | AxAIGroqModel\n  | AxAIGoogleGeminiModel\n  | AxAICohereModel\n  | AxAIHuggingFaceModel\n  | AxAIMistralModel\n  | AxAIDeepSeekModel\n  | string\n\nexport type AxAIEmbedModels =\n  | AxAIOpenAIEmbedModel\n  | AxAIGoogleGeminiEmbedModel\n  | AxAICohereEmbedModel\n  | string\n\nexport class AxAI implements AxAIService {\n  private ai: AxAIService\n\n  constructor(options: Readonly<AxAIArgs>) {\n    switch (options.name) {\n      case 'openai':\n        this.ai = new AxAIOpenAI(options)\n        break\n      case 'azure-openai':\n        this.ai = new AxAIAzureOpenAI(options)\n        break\n      case 'huggingface':\n        this.ai = new AxAIHuggingFace(options)\n        break\n      case 'groq':\n        this.ai = new AxAIGroq(options)\n        break\n      case 'together':\n        this.ai = new AxAITogether(options)\n        break\n      case 'cohere':\n        this.ai = new AxAICohere(options)\n        break\n      case 'google-gemini':\n        this.ai = new AxAIGoogleGemini(options)\n        break\n      case 'anthropic':\n        this.ai = new AxAIAnthropic(options)\n        break\n      case 'mistral':\n        this.ai = new AxAIMistral(options)\n        break\n      case 'deepseek':\n        this.ai = new AxAIDeepSeek(options)\n        break\n      case 'ollama':\n        this.ai = new AxAIOllama(options)\n        break\n      case 'reka':\n        this.ai = new AxAIReka(options)\n        break\n      default:\n        throw new Error(`Unknown AI`)\n    }\n  }\n\n  getName(): string {\n    return this.ai.getName()\n  }\n\n  getModelInfo(): Readonly<AxModelInfoWithProvider> {\n    return this.ai.getModelInfo()\n  }\n\n  getEmbedModelInfo(): Readonly<AxModelInfoWithProvider> | undefined {\n    return this.ai.getEmbedModelInfo()\n  }\n\n  getFeatures(model?: string): { functions: boolean; streaming: boolean } {\n    return this.ai.getFeatures(model)\n  }\n\n  getModelMap(): AxAIModelMap | undefined {\n    return this.ai.getModelMap()\n  }\n\n  getMetrics(): AxAIServiceMetrics {\n    return this.ai.getMetrics()\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest>,\n    options?: Readonly<AxAIPromptConfig & AxAIServiceActionOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    return await this.ai.chat(req, options)\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest>,\n    options?: Readonly<AxAIServiceActionOptions & AxAIServiceActionOptions>\n  ): Promise<AxEmbedResponse> {\n    return await this.ai.embed(req, options)\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.ai.setOptions(options)\n  }\n}\n","import { SpanKind } from '@opentelemetry/api'\n\nimport type { AxAIService, AxFunction } from '../ai/types.js'\nimport { AxGen, type AxGenOptions } from '../dsp/generate.js'\nimport {\n  type AxGenIn,\n  type AxGenOut,\n  type AxProgramDemos,\n  type AxProgramExamples,\n  type AxProgramForwardOptions,\n  AxProgramWithSignature,\n  type AxTunable,\n  type AxUsable,\n} from '../dsp/program.js'\nimport { AxSignature } from '../dsp/sig.js'\n\nexport interface AxAgentic extends AxTunable, AxUsable {\n  getFunction(): AxFunction\n}\n\nexport type AxAgentOptions = Omit<AxGenOptions, 'functions'>\n\nexport class AxAgent<IN extends AxGenIn, OUT extends AxGenOut>\n  implements AxAgentic\n{\n  private ai?: AxAIService\n  private signature: AxSignature\n  private program: AxProgramWithSignature<IN, OUT>\n  private agents?: AxAgentic[]\n\n  private name: string\n  private description: string\n  private subAgentList?: string\n  private func: AxFunction\n\n  constructor(\n    {\n      ai,\n      name,\n      description,\n      signature,\n      agents,\n      functions,\n    }: Readonly<{\n      ai?: Readonly<AxAIService>\n      name: string\n      description: string\n      signature: AxSignature | string\n      agents?: AxAgentic[]\n      functions?: AxFunction[]\n    }>,\n    options?: Readonly<AxAgentOptions>\n  ) {\n    this.ai = ai\n    this.agents = agents\n\n    this.signature = new AxSignature(signature)\n    this.signature.setDescription(description)\n\n    const funcs: AxFunction[] = [\n      ...(functions ?? []),\n      ...(agents?.map((a) => a.getFunction()) ?? []),\n    ]\n\n    const opt = { ...options, functions: funcs }\n    this.program = new AxGen<IN, OUT>(this.signature, opt)\n\n    if (!name || name.length < 5) {\n      throw new Error(\n        `Agent name must be at least 10 characters (more descriptive): ${name}`\n      )\n    }\n\n    if (!description || description.length < 20) {\n      throw new Error(\n        `Agent description must be at least 20 characters (explain in detail what the agent does): ${description}`\n      )\n    }\n\n    this.name = name\n    this.description = description\n    this.subAgentList = agents?.map((a) => a.getFunction().name).join(', ')\n\n    this.func = {\n      name: toCamelCase(this.name),\n      description: this.description,\n      parameters: this.signature.toJSONSchema(),\n      func: () => this.forward,\n    }\n\n    for (const agent of agents ?? []) {\n      this.program.register(agent)\n    }\n  }\n\n  public setExamples(examples: Readonly<AxProgramExamples>) {\n    this.program.setExamples(examples)\n  }\n\n  public setId(id: string) {\n    this.program.setId(id)\n  }\n\n  public setParentId(parentId: string) {\n    this.program.setParentId(parentId)\n  }\n\n  public getTraces() {\n    return this.program.getTraces()\n  }\n\n  public setDemos(demos: readonly AxProgramDemos[]) {\n    this.program.setDemos(demos)\n  }\n\n  public getUsage() {\n    return this.program.getUsage()\n  }\n\n  public resetUsage() {\n    this.program.resetUsage()\n  }\n\n  public getFunction(): AxFunction {\n    const boundFunc = this.forward.bind(this)\n\n    // Create a wrapper function that excludes the 'ai' parameter\n    const wrappedFunc = (\n      values: IN,\n      options?: Readonly<AxProgramForwardOptions>\n    ) => {\n      const ai = this.ai ?? options?.ai\n      if (!ai) {\n        throw new Error('AI service is required to run the agent')\n      }\n      return boundFunc(ai, values, options)\n    }\n\n    return {\n      ...this.func,\n      func: wrappedFunc,\n    }\n  }\n\n  public async forward(\n    ai: Readonly<AxAIService>,\n    values: IN,\n    options?: Readonly<AxProgramForwardOptions>\n  ): Promise<OUT> {\n    const _ai = this.ai ?? ai\n\n    const funcs: AxFunction[] = [\n      ...(options?.functions ?? []),\n      ...(this.agents?.map((a) => a.getFunction()) ?? []),\n    ]\n\n    const opt = options\n\n    if (funcs.length > 0) {\n      const opt = { ...options, functions: funcs }\n      this.program = new AxGen<IN, OUT>(this.signature, opt)\n    }\n\n    if (!options?.tracer) {\n      return await this.program.forward(_ai, values, opt)\n    }\n\n    const attributes = {\n      ['agent.name']: this.name,\n      ['agent.description']: this.description,\n      ['agent.subAgents']: this.subAgentList ?? 'none',\n    }\n\n    return await options?.tracer.startActiveSpan(\n      'Agent',\n      {\n        kind: SpanKind.SERVER,\n        attributes,\n      },\n      async (span) => {\n        const res = await this.program.forward(_ai, values, opt)\n        span.end()\n        return res\n      }\n    )\n  }\n}\n\nfunction toCamelCase(inputString: string): string {\n  // Split the string by any non-alphanumeric character (including underscores, spaces, hyphens)\n  const words = inputString.split(/[^a-zA-Z0-9]/)\n\n  // Map through each word, capitalize the first letter of each word except the first word\n  const camelCaseString = words\n    .map((word, index) => {\n      // Lowercase the word to handle cases like uppercase letters in input\n      const lowerWord = word.toLowerCase()\n\n      // Capitalize the first letter of each word except the first one\n      if (index > 0 && lowerWord && lowerWord[0]) {\n        return lowerWord[0].toUpperCase() + lowerWord.slice(1)\n      }\n\n      return lowerWord\n    })\n    .join('')\n\n  return camelCaseString\n}\n","import { ReadableStream } from 'stream/web'\n\nimport { type Span, SpanKind, type Tracer } from '@opentelemetry/api'\n\nimport type {\n  AxAIService,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxFunction,\n  AxRateLimiterFunction,\n} from '../ai/types.js'\nimport { mergeFunctionCalls } from '../ai/util.js'\nimport { AxMemory } from '../mem/memory.js'\nimport type { AxAIMemory } from '../mem/types.js'\n\nimport {\n  assertAssertions,\n  assertRequiredFields,\n  assertStreamingAssertions,\n  type AxAssertion,\n  AxAssertionError,\n  type AxStreamingAssertion,\n} from './asserts.js'\nimport {\n  type extractionState,\n  extractValues,\n  streamingExtractFinalValue,\n  streamingExtractValues,\n} from './extract.js'\nimport {\n  type AxChatResponseFunctionCall,\n  type AxInputFunctionType,\n  parseFunctionCalls,\n  parseFunctions,\n  processFunctions,\n} from './functions.js'\nimport {\n  type AxGenIn,\n  type AxGenOut,\n  type AxProgramForwardOptions,\n  AxProgramWithSignature,\n} from './program.js'\nimport { AxPromptTemplate } from './prompt.js'\nimport { AxSignature } from './sig.js'\nimport { AxValidationError } from './validate.js'\n\nexport interface AxGenOptions {\n  maxCompletions?: number\n  maxRetries?: number\n  maxSteps?: number\n  mem?: AxAIMemory\n  tracer?: Tracer\n  rateLimiter?: AxRateLimiterFunction\n  stream?: boolean\n  debug?: boolean\n  description?: string\n\n  functions?: AxInputFunctionType\n  functionCall?: AxChatRequest['functionCall']\n  stopFunction?: string\n  promptTemplate?: typeof AxPromptTemplate\n  asserts?: AxAssertion[]\n  streamingAsserts?: AxStreamingAssertion[]\n}\n\nexport type AxGenerateResult<OUT extends AxGenOut> = OUT & {\n  functions?: AxChatResponseFunctionCall[]\n}\n\nexport interface AxResponseHandlerArgs<T> {\n  ai: Readonly<AxAIService>\n  model?: string\n  res: T\n  usageInfo: { ai: string; model: string }\n  mem: AxAIMemory\n  sessionId?: string\n  traceId?: string\n  functions?: Readonly<AxFunction[]>\n}\n\nexport class Test {}\n\nexport class AxGen<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenerateResult<AxGenOut> = AxGenerateResult<AxGenOut>,\n> extends AxProgramWithSignature<IN, OUT> {\n  private promptTemplate: AxPromptTemplate\n  private asserts: AxAssertion[]\n  private streamingAsserts: AxStreamingAssertion[]\n  private options?: Omit<AxGenOptions, 'functions'>\n  private functions?: AxFunction[]\n  private functionsExecuted: Set<string> = new Set<string>()\n\n  constructor(\n    signature: Readonly<AxSignature | string>,\n    options?: Readonly<AxGenOptions>\n  ) {\n    super(signature, { description: options?.description })\n\n    this.options = options\n    this.promptTemplate = new (options?.promptTemplate ?? AxPromptTemplate)(\n      this.signature,\n      options?.functions\n    )\n    this.asserts = this.options?.asserts ?? []\n    this.streamingAsserts = this.options?.streamingAsserts ?? []\n    this.usage = []\n\n    if (options?.functions) {\n      this.functions = parseFunctions(options.functions)\n    }\n  }\n\n  public addAssert = (\n    fn: AxAssertion['fn'],\n    message?: string,\n    optional?: boolean\n  ) => {\n    this.asserts.push({ fn, message, optional })\n  }\n\n  public addStreamingAssert = (\n    fieldName: string,\n    fn: AxStreamingAssertion['fn'],\n    message?: string,\n    optional?: boolean\n  ) => {\n    this.streamingAsserts.push({ fieldName, fn, message, optional })\n  }\n\n  private async forwardSendRequest({\n    ai,\n    mem,\n    options,\n  }: Readonly<{\n    ai: Readonly<AxAIService>\n    mem: AxAIMemory\n    options?: Omit<AxProgramForwardOptions, 'ai' | 'mem'>\n  }>) {\n    const {\n      sessionId,\n      traceId,\n      modelConfig,\n      model,\n      rateLimiter,\n      stream,\n      functions,\n      functionCall: _functionCall,\n    } = options ?? {}\n\n    const chatPrompt = mem?.history(sessionId) ?? []\n\n    if (chatPrompt.length === 0) {\n      throw new Error('No chat prompt found')\n    }\n\n    const functionCall = _functionCall ?? this.options?.functionCall\n\n    const res = await ai.chat(\n      {\n        chatPrompt,\n        functions,\n        functionCall,\n        modelConfig,\n        model,\n      },\n      {\n        sessionId,\n        traceId,\n        rateLimiter,\n        stream,\n      }\n    )\n\n    return res\n  }\n\n  private async forwardCore({\n    ai,\n    mem,\n    options,\n  }: Readonly<{\n    ai: Readonly<AxAIService>\n    mem: AxAIMemory\n    options?: Omit<AxProgramForwardOptions, 'ai' | 'mem'>\n  }>): Promise<OUT> {\n    const { sessionId, traceId, model, functions } = options ?? {}\n\n    const usageInfo = {\n      ai: ai.getName(),\n      model: ai.getModelInfo().name,\n    }\n\n    const res = await this.forwardSendRequest({\n      ai,\n      mem,\n      options,\n    })\n\n    if (res instanceof ReadableStream) {\n      return (await this.processSteamingResponse({\n        ai,\n        model,\n        res,\n        usageInfo,\n        mem,\n        traceId,\n        sessionId,\n        functions,\n      })) as unknown as OUT\n    }\n\n    return (await this.processResponse({\n      ai,\n      model,\n      res,\n      usageInfo,\n      mem,\n      traceId,\n      sessionId,\n      functions,\n    })) as unknown as OUT\n  }\n\n  private async processSteamingResponse({\n    ai,\n    model,\n    res,\n    usageInfo,\n    mem,\n    sessionId,\n    traceId,\n    functions,\n  }: Readonly<\n    AxResponseHandlerArgs<ReadableStream<AxChatResponse>>\n  >): Promise<OUT> {\n    const functionCalls: NonNullable<AxChatResponseResult['functionCalls']> = []\n    const values = {}\n    const xstate: extractionState = { s: -1 }\n\n    let content = ''\n\n    for await (const v of res) {\n      for (const result of v.results ?? []) {\n        if (v.modelUsage) {\n          this.usage.push({ ...usageInfo, ...v.modelUsage })\n        }\n\n        if (result.content) {\n          content += result.content\n\n          mem.updateResult({ name: result.name, content }, sessionId)\n\n          assertStreamingAssertions(\n            this.streamingAsserts,\n            values,\n            xstate,\n            content,\n            false\n          )\n          streamingExtractValues(this.signature, values, xstate, content)\n          assertAssertions(this.asserts, values)\n        }\n\n        if (result.functionCalls) {\n          mergeFunctionCalls(functionCalls, result.functionCalls)\n\n          mem.updateResult(\n            { name: result.name, content, functionCalls },\n            sessionId\n          )\n        }\n\n        if (result.finishReason === 'length') {\n          throw new Error('Max tokens reached before completion')\n        }\n      }\n    }\n\n    const funcs = parseFunctionCalls(ai, functionCalls, values, model)\n    if (funcs) {\n      if (!functions) {\n        throw new Error('Functions are not defined')\n      }\n      const fx = await processFunctions(\n        ai,\n        functions,\n        funcs,\n        mem,\n        sessionId,\n        traceId\n      )\n      this.functionsExecuted = new Set([...this.functionsExecuted, ...fx])\n    }\n\n    streamingExtractFinalValue(values, xstate, content)\n    assertStreamingAssertions(\n      this.streamingAsserts,\n      values,\n      xstate,\n      content,\n      true\n    )\n    assertAssertions(this.asserts, values)\n\n    return { ...values } as unknown as OUT\n  }\n\n  private async processResponse({\n    ai,\n    res,\n    usageInfo,\n    mem,\n    sessionId,\n    traceId,\n    functions,\n  }: Readonly<AxResponseHandlerArgs<AxChatResponse>>): Promise<OUT> {\n    const values = {}\n\n    for (const result of res.results ?? []) {\n      if (res.modelUsage) {\n        this.usage.push({ ...usageInfo, ...res.modelUsage })\n      }\n\n      mem.addResult(result, sessionId)\n\n      if (result.content) {\n        extractValues(this.signature, values, result.content)\n        assertAssertions(this.asserts, values)\n      }\n\n      if (result.functionCalls) {\n        const funcs = parseFunctionCalls(ai, result.functionCalls, values)\n\n        if (funcs) {\n          if (!functions) {\n            throw new Error('Functions are not defined')\n          }\n          const fx = await processFunctions(\n            ai,\n            functions,\n            funcs,\n            mem,\n            sessionId,\n            traceId\n          )\n          this.functionsExecuted = new Set([...this.functionsExecuted, ...fx])\n        }\n      }\n\n      if (result.finishReason === 'length') {\n        throw new Error('Max tokens reached before completion')\n      }\n    }\n\n    return { ...values } as unknown as OUT\n  }\n\n  private async _forward(\n    ai: Readonly<AxAIService>,\n    values: IN,\n    options?: Readonly<AxProgramForwardOptions>,\n    span?: Span\n  ): Promise<OUT> {\n    const stopFunction = (\n      options?.stopFunction ?? this.options?.stopFunction\n    )?.toLowerCase()\n\n    const maxRetries = options?.maxRetries ?? this.options?.maxRetries ?? 15\n    const maxSteps = options?.maxSteps ?? this.options?.maxSteps ?? 10\n    const mem = options?.mem ?? this.options?.mem ?? new AxMemory()\n\n    let err: AxValidationError | AxAssertionError | undefined\n\n    if (options?.functions && options?.functions.length > 0) {\n      const promptTemplate = this.options?.promptTemplate ?? AxPromptTemplate\n      this.promptTemplate = new promptTemplate(\n        this.signature,\n        options.functions\n      )\n    }\n\n    const prompt = this.promptTemplate.render<IN>(values, {\n      examples: this.examples,\n      demos: this.demos,\n    })\n\n    mem.add(prompt, options?.sessionId)\n\n    multiStepLoop: for (let n = 0; n < maxSteps; n++) {\n      for (let i = 0; i < maxRetries; i++) {\n        try {\n          const output = await this.forwardCore({\n            options,\n            ai,\n            mem,\n          })\n\n          const lastMemItem = mem.getLast(options?.sessionId)\n\n          const stopFunctionExecuted =\n            stopFunction && this.functionsExecuted.has(stopFunction)\n\n          if (lastMemItem?.role === 'function') {\n            if (!stopFunction || !stopFunctionExecuted) {\n              continue multiStepLoop\n            }\n          }\n\n          if (!stopFunctionExecuted) {\n            assertRequiredFields(this.signature, output)\n          }\n\n          this.trace = { ...values, ...output }\n          return output\n        } catch (e) {\n          let extraFields\n          span?.recordException(e as Error)\n\n          if (e instanceof AxValidationError) {\n            extraFields = e.getFixingInstructions()\n            err = e\n          } else if (e instanceof AxAssertionError) {\n            const e1 = e as AxAssertionError\n            extraFields = e1.getFixingInstructions(this.signature)\n            err = e\n          } else {\n            throw e\n          }\n\n          if (extraFields) {\n            const content = this.promptTemplate.renderExtraFields(extraFields)\n            mem.add({ role: 'user' as const, content }, options?.sessionId)\n\n            if (options?.debug) {\n              console.log('Error Correction:', content)\n            }\n          }\n        }\n      }\n\n      if (err instanceof AxAssertionError && err.getOptional()) {\n        return err.getValue() as OUT\n      }\n\n      throw new Error(`Unable to fix validation error: ${err?.message}`)\n    }\n\n    throw new Error(`Max steps reached: ${maxSteps}`)\n  }\n\n  public override async forward(\n    ai: Readonly<AxAIService>,\n    values: IN,\n    options?: Readonly<AxProgramForwardOptions>\n  ): Promise<OUT> {\n    const tracer = this.options?.tracer ?? options?.tracer\n\n    let functions: AxFunction[] | undefined = this.functions\n\n    if (options?.functions) {\n      functions = parseFunctions(options.functions, this.functions)\n    }\n\n    if (!tracer) {\n      return await this._forward(ai, values, {\n        ...options,\n        functions,\n      })\n    }\n\n    const funcNames = functions?.map((f) => f.name).join(',')\n\n    const attributes = {\n      ['generate.signature']: this.signature.toString(),\n      ['generate.functions']: funcNames ?? '',\n    }\n\n    return await tracer.startActiveSpan(\n      'Generate',\n      {\n        kind: SpanKind.SERVER,\n        attributes,\n      },\n      async (span) => {\n        const res = this._forward(ai, values, options, span)\n        span.end()\n        return res\n      }\n    )\n  }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport { createHash } from 'crypto'\n\nimport type { AxChatResponseResult, AxModelInfo } from './types.js'\n\nexport const findItemByNameOrAlias = (\n  list: readonly AxModelInfo[],\n  name: string\n): AxModelInfo | undefined => {\n  for (const item of list) {\n    if (item.name === name || item.aliases?.includes(name)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport const uniqBy = <T>(\n  array: readonly T[],\n  uniqueField: (value: T) => unknown\n): T[] => {\n  const uniqueValues = new Map()\n\n  array.forEach((value: T) => {\n    const field = uniqueField(value)\n\n    if (!uniqueValues.has(field)) {\n      uniqueValues.set(field, value)\n    }\n  })\n\n  return Array.from(uniqueValues.values())\n}\n\nconst functionCallRe = /(\\w+)\\((.*)\\)/s\n\nexport const parseFunction = (\n  value: string\n): { name: string; args?: string } | undefined => {\n  let v: string[] | null\n\n  // extract function calls\n  if ((v = functionCallRe.exec(value)) !== null) {\n    const name = v.at(1)?.trim()\n    const args = v.at(2)?.trim()\n    if (!name || name) {\n      throw new Error(`Invalid function format: ${value}`)\n    }\n    return { name, args }\n  }\n  return\n}\n\nexport interface mergeFunctionsState {\n  lastId?: string\n}\n\nexport function mergeFunctionCalls(\n  functionCalls: NonNullable<AxChatResponseResult['functionCalls']>,\n  functionCallDeltas: Readonly<\n    NonNullable<AxChatResponseResult['functionCalls']>\n  >\n) {\n  for (const _fc of functionCallDeltas) {\n    const fc = functionCalls.find((fc) => fc.id === _fc.id)\n\n    if (fc) {\n      if (\n        typeof _fc.function.name == 'string' &&\n        _fc.function.name.length > 0\n      ) {\n        fc.function.name += _fc.function.name\n      }\n\n      if (\n        typeof _fc.function.params == 'string' &&\n        _fc.function.params.length > 0\n      ) {\n        fc.function.params += _fc.function.params\n      }\n\n      if (typeof _fc.function.params == 'object') {\n        fc.function.params = _fc.function.params\n      }\n    } else {\n      functionCalls.push(_fc)\n    }\n  }\n}\n\nexport const hashObject = (obj: object) => {\n  const hash = createHash('sha256')\n  hash.update(JSON.stringify(obj))\n  return hash.digest('hex')\n}\n","import type { AxChatRequest, AxChatResponseResult } from '../ai/types.js'\n\nimport type { AxAIMemory } from './types.js'\n\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] }\ntype WritableChatPrompt = Writeable<AxChatRequest['chatPrompt'][0]>[]\n\nexport class AxMemory implements AxAIMemory {\n  private data: WritableChatPrompt = []\n  private sdata = new Map<string, WritableChatPrompt>()\n  private limit: number\n\n  constructor(limit = 50) {\n    if (limit <= 0) {\n      throw Error(\"argument 'limit' must be greater than 0\")\n    }\n    this.limit = limit\n  }\n\n  add(\n    value: Readonly<\n      AxChatRequest['chatPrompt'][0] | AxChatRequest['chatPrompt']\n    >,\n    sessionId?: string\n  ): void {\n    const d = this.get(sessionId)\n    let n = 0\n\n    if (Array.isArray(value)) {\n      n = d.push(...structuredClone(value))\n    } else {\n      n = d.push({\n        ...structuredClone(value),\n      } as AxChatRequest['chatPrompt'][0])\n    }\n    if (d.length > this.limit) {\n      d.splice(0, this.limit + n - this.limit)\n    }\n  }\n\n  addResult(\n    { content, name, functionCalls }: Readonly<AxChatResponseResult>,\n    sessionId?: string\n  ): void {\n    if (!content && (!functionCalls || functionCalls.length === 0)) {\n      return\n    }\n    this.add({ content, name, role: 'assistant', functionCalls }, sessionId)\n  }\n\n  updateResult(\n    { content, name, functionCalls }: Readonly<AxChatResponseResult>,\n    sessionId?: string\n  ): void {\n    const items = this.get(sessionId)\n\n    const lastItem = items.at(-1)\n\n    if (!lastItem || lastItem.role !== 'assistant') {\n      this.addResult({ content, name, functionCalls }, sessionId)\n      return\n    }\n\n    if ('content' in lastItem && content) {\n      lastItem.content = content\n    }\n    if ('name' in lastItem && name) {\n      lastItem.name = name\n    }\n    if ('functionCalls' in lastItem && functionCalls) {\n      lastItem.functionCalls = functionCalls\n    }\n  }\n\n  history(sessionId?: string): AxChatRequest['chatPrompt'] {\n    return this.get(sessionId)\n  }\n\n  getLast(sessionId?: string): AxChatRequest['chatPrompt'][0] | undefined {\n    const d = this.get(sessionId)\n    return d.at(-1)\n  }\n\n  reset(sessionId?: string) {\n    if (!sessionId) {\n      this.data = []\n    } else {\n      this.sdata.set(sessionId, [])\n    }\n  }\n\n  private get(sessionId?: string): WritableChatPrompt {\n    if (!sessionId) {\n      return this.data\n    }\n\n    if (!this.sdata.has(sessionId)) {\n      this.sdata.set(sessionId, [])\n    }\n\n    return this.sdata.get(sessionId) || []\n  }\n}\n","import type { extractionState } from './extract.js'\nimport type { AxSignature } from './sig.js'\n\nexport interface AxAssertion {\n  fn(values: Record<string, unknown>): boolean | undefined\n  message?: string\n  optional?: boolean\n}\n\nexport interface AxStreamingAssertion {\n  fieldName: string\n  fn(content: string, done?: boolean): boolean | undefined\n  message?: string\n  optional?: boolean\n}\n\nexport class AxAssertionError extends Error {\n  private values: Record<string, unknown>\n  private optional?: boolean\n\n  constructor({\n    message,\n    values,\n    optional,\n  }: Readonly<{\n    message: string\n    values: Record<string, unknown>\n    optional?: boolean\n  }>) {\n    super(message)\n    this.values = values\n    this.optional = optional\n    this.name = this.constructor.name\n    this.stack = new Error().stack\n  }\n  public getValue = () => this.values\n  public getOptional = () => this.optional\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public getFixingInstructions = (_sig: Readonly<AxSignature>) => {\n    const extraFields = []\n\n    // for (const f of sig.getOutputFields()) {\n    //   extraFields.push({\n    //     name: `past_${f.name}`,\n    //     title: `Past ${f.title}`,\n    //     description: JSON.stringify(this.values[f.name])\n    //   });\n    // }\n\n    extraFields.push({\n      name: 'instructions',\n      title: 'Instructions',\n      description: this.message,\n    })\n\n    return extraFields\n  }\n}\n\nexport const assertAssertions = (\n  asserts: readonly AxAssertion[],\n  values: Record<string, unknown>\n) => {\n  for (const assert of asserts) {\n    const { fn, message, optional } = assert\n\n    try {\n      const res = fn(values)\n      if (res === undefined) {\n        continue\n      }\n\n      if (!res && message) {\n        throw new AxAssertionError({ message, values, optional })\n      }\n    } catch (e) {\n      const message = (e as Error).message\n      throw new AxAssertionError({ message, values, optional })\n    }\n  }\n}\n\nexport const assertStreamingAssertions = (\n  asserts: readonly AxStreamingAssertion[],\n  values: Record<string, unknown>,\n  xstate: Readonly<extractionState>,\n  content: string,\n  final: boolean\n) => {\n  if (\n    !xstate.currField ||\n    xstate.s === -1 ||\n    !asserts ||\n    asserts.length === 0\n  ) {\n    return\n  }\n\n  const fieldAsserts = asserts.filter(\n    (a) => a.fieldName === xstate.currField?.name\n  )\n\n  if (fieldAsserts.length === 0) {\n    return\n  }\n\n  const currValue = content.substring(xstate.s)\n\n  for (const assert of fieldAsserts) {\n    const { message, optional, fn } = assert\n\n    try {\n      const res = fn(currValue, final)\n      if (res === undefined) {\n        continue\n      }\n\n      if (!res && message) {\n        throw new AxAssertionError({ message, values, optional })\n      }\n    } catch (e) {\n      const message = (e as Error).message\n      throw new AxAssertionError({ message, values, optional })\n    }\n  }\n}\n\nexport const assertRequiredFields = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>\n) => {\n  const fields = sig.getOutputFields()\n  const missingFields = fields.filter(\n    (f) => !f.isOptional && !(f.name in values)\n  )\n  if (missingFields.length > 0) {\n    throw new AxAssertionError({\n      message: `Output must include: ${missingFields.map((f) => `\\`${f.title}:\\``).join(', ')}`,\n      values,\n    })\n  }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nimport JSON5 from 'json5'\n\nimport { parseLLMFriendlyDate, parseLLMFriendlyDateTime } from './datetime.js'\nimport type { AxField, AxSignature } from './sig.js'\nimport { parseMarkdownList } from './util.js'\nimport { AxValidationError } from './validate.js'\n\nexport const extractValues = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  content: string\n) => {\n  const xstate = { s: -1 }\n  streamingExtractValues(sig, values, xstate, content)\n  streamingExtractFinalValue(values, xstate, content)\n}\n\nexport interface extractionState {\n  currField?: AxField\n  s: number\n}\n\nexport const streamingExtractValues = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  state: extractionState,\n  content: string\n) => {\n  const fields = sig.getOutputFields()\n\n  for (const field of fields) {\n    if (field.name in values) {\n      continue\n    }\n\n    const prefix = field.title + ':'\n    const e = content.indexOf(prefix, state.s + 1)\n\n    if (e === -1) {\n      continue\n    }\n\n    if (state.currField) {\n      const val = content\n        .substring(state.s, e)\n        .trim()\n        .replace(/---+$/, '')\n        .trim()\n\n      values[state.currField.name] = validateAndParseFieldValue(\n        state.currField,\n        val\n      )\n    }\n\n    state.s = e + prefix.length\n    state.currField = field\n  }\n}\n\nexport const streamingExtractFinalValue = (\n  values: Record<string, unknown>,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  state: extractionState,\n  content: string\n) => {\n  if (!state.currField) {\n    return\n  }\n  const val = content.substring(state.s).trim().replace(/---+$/, '').trim()\n\n  values[state.currField.name] = validateAndParseFieldValue(\n    state.currField,\n    val\n  )\n}\n\nconst convertValueToType = (field: Readonly<AxField>, val: string) => {\n  switch (field.type?.name) {\n    case 'string':\n      return val as string\n    case 'number': {\n      const v = Number(val)\n      if (Number.isNaN(v)) {\n        throw new Error('Invalid number')\n      }\n      return v\n    }\n    case 'boolean': {\n      const v = val.toLowerCase()\n      if (v === 'true') {\n        return true\n      } else if (v === 'false') {\n        return false\n      } else {\n        throw new Error('Invalid boolean')\n      }\n    }\n    case 'date':\n      return parseLLMFriendlyDate(field, val as string)\n    case 'datetime':\n      return parseLLMFriendlyDateTime(field, val as string)\n    case 'class':\n      if (field.type.classes && !field.type.classes.includes(val)) {\n        throw new Error(\n          `Invalid class '${val}', expected one of the following: ${field.type.classes.join(', ')}`\n        )\n      }\n      return val as string\n    default:\n      return val as string // Unknown type\n  }\n}\n\nconst expectedTypeError = (\n  field: Readonly<AxField>,\n  err: Readonly<Error>,\n  value: string | undefined = ''\n) => {\n  const exp = field.type?.isArray\n    ? `array of ${field.type.name}`\n    : field.type?.name\n  const message = `Error '${err.message}', expected '${exp}' got '${value}'`\n  return new AxValidationError({ message, field, value })\n}\n\nfunction validateAndParseFieldValue(\n  field: Readonly<AxField>,\n  fieldValue: string | undefined\n): unknown {\n  const fv = fieldValue?.toLocaleLowerCase()\n  if (!fieldValue || !fv || fv === '' || fv === 'null' || fv === 'undefined') {\n    if (field.isOptional) {\n      return\n    }\n    throw expectedTypeError(field, new Error('Empty value'), fieldValue)\n  }\n  let value: unknown = fieldValue\n\n  if (field.type?.name === 'json') {\n    try {\n      const text = extractBlock(fieldValue)\n      value = JSON5.parse(text)\n      return value\n    } catch (e) {\n      throw expectedTypeError(field, e as Error, fieldValue)\n    }\n  }\n\n  if (field.type?.isArray) {\n    try {\n      try {\n        value = JSON5.parse(fieldValue)\n      } catch {\n        // If JSON parsing fails, try markdown parsing\n        value = parseMarkdownList(fieldValue)\n      }\n      if (!Array.isArray(value)) {\n        throw new Error('Expected an array')\n      }\n    } catch (e) {\n      throw expectedTypeError(field, e as Error, fieldValue)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    for (const [index, item] of value.entries()) {\n      try {\n        value[index] = convertValueToType(field, item)\n      } catch (e) {\n        throw expectedTypeError(field, e as Error, item)\n      }\n    }\n  } else {\n    try {\n      value = convertValueToType(field, fieldValue)\n    } catch (e) {\n      throw expectedTypeError(field, e as Error, fieldValue)\n    }\n  }\n\n  // If validation passes, return null to indicate no error\n  return value\n}\n\nexport const extractBlock = (input: string): string => {\n  const jsonBlockPattern = /```([A-Za-z]+)?\\s*([\\s\\S]*?)\\s*```/g\n  const match = jsonBlockPattern.exec(input)\n  if (!match) {\n    return input\n  }\n  if (match.length === 3) {\n    return match[2] as string\n  }\n  if (match.length === 2) {\n    return match[1] as string\n  }\n  return input\n}\n","import moment from 'moment-timezone'\n\nimport type { AxField } from './sig.js'\nimport { AxValidationError } from './validate.js'\n\nexport function parseLLMFriendlyDate(\n  field: Readonly<AxField>,\n  dateStr: string\n) {\n  try {\n    return _parseLLMFriendlyDate(dateStr)\n  } catch (err) {\n    const message = (err as Error).message\n    throw new AxValidationError({ field, message, value: dateStr })\n  }\n}\n\nfunction _parseLLMFriendlyDate(dateStr: string) {\n  // Validate the date string format\n  if (!moment(dateStr, 'YYYY-MM-DD', true).isValid()) {\n    throw new Error(\n      'Invalid date format. Please provide the date in \"YYYY-MM-DD\" format.'\n    )\n  }\n\n  // Parse the date and create a UTC moment object at midnight\n  const date = moment.utc(dateStr, 'YYYY-MM-DD').startOf('day')\n\n  return date.toDate()\n}\n\nexport function parseLLMFriendlyDateTime(\n  field: Readonly<AxField>,\n  dateStr: string\n) {\n  try {\n    return _parseLLMFriendlyDateTime(dateStr)\n  } catch (err) {\n    const message = (err as Error).message\n    throw new AxValidationError({ field, message, value: dateStr })\n  }\n}\n\nfunction _parseLLMFriendlyDateTime(dateTimeStr: string) {\n  // Validate the date and time string format\n  const dateTimeRegex = /^(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}(?::\\d{2})?) (.+)$/\n  const match = dateTimeStr.match(dateTimeRegex)\n  if (!match) {\n    throw new Error(\n      'Invalid date and time format. Please provide the date and time in \"YYYY-MM-DD HH:mm\" or \"YYYY-MM-DD HH:mm:ss\" format, followed by the timezone.'\n    )\n  }\n\n  const [, dateTime, timeZone] = match\n\n  if (!dateTime || !timeZone) {\n    throw new Error(\n      'Invalid date and time format. Please provide the date and time in \"YYYY-MM-DD HH:mm\" or \"YYYY-MM-DD HH:mm:ss\" format, followed by the timezone.'\n    )\n  }\n\n  // Try to parse the timezone\n  const zone = moment.tz.zone(timeZone)\n\n  // If still not found, throw an error\n  if (!zone) {\n    throw new Error(\n      `Unrecognized time zone ${timeZone}. Please provide a valid time zone name, abbreviation, or offset. For example, \"America/New_York\", or \"EST\".`\n    )\n  }\n\n  // Parse the date and time in the specified time zone\n  const date = moment.tz(\n    dateTime,\n    ['YYYY-MM-DD HH:mm', 'YYYY-MM-DD HH:mm:ss'],\n    zone.name\n  )\n\n  // Check if the date and time are valid\n  if (!date.isValid()) {\n    throw new Error(\n      'Invalid date and time values. Please ensure all components are correct.'\n    )\n  }\n\n  // Convert to UTC\n  return date.utc().toDate()\n}\n\nexport const formatDateWithTimezone = (date: Readonly<Date>) => {\n  const momentDate = moment(date).utc()\n  return momentDate.format(`YYYY-MM-DD HH:mm:ss UTC`)\n}\n","import { type Tracer } from '@opentelemetry/api'\n\nimport type {\n  AxAIService,\n  AxChatRequest,\n  AxChatResponse,\n  AxFunction,\n  AxModelConfig,\n  AxRateLimiterFunction,\n} from '../ai/types.js'\nimport type { AxAIMemory } from '../mem/types.js'\n\nimport { AxInstanceRegistry } from './registry.js'\nimport { AxSignature } from './sig.js'\nimport { mergeProgramUsage, validateValue } from './util.js'\n\nexport type AxFieldValue =\n  | string\n  | string[]\n  | number\n  | boolean\n  | object\n  | null\n  | undefined\n  | { mimeType: string; data: string }\n  | { mimeType: string; data: string }[]\n  | { format?: 'wav'; data: string }\n  | { format?: 'wav'; data: string }[]\n\nexport type AxGenIn = { [key: symbol]: AxFieldValue }\n\nexport type AxGenOut = Record<string, AxFieldValue>\n\nexport type AxProgramTrace = {\n  //   examples: Record<string, Value>[];\n  trace: Record<string, AxFieldValue>\n  programId: string\n}\n\nexport type AxProgramDemos = {\n  //   examples: Record<string, Value>[];\n  traces: Record<string, AxFieldValue>[]\n  programId: string\n}\n\nexport type AxProgramExamples = AxProgramDemos | AxProgramDemos['traces']\n\nexport type AxProgramForwardOptions = {\n  maxCompletions?: number\n  maxRetries?: number\n  maxSteps?: number\n  mem?: AxAIMemory\n  ai?: AxAIService\n  modelConfig?: AxModelConfig\n  model?: string\n  sessionId?: string\n  traceId?: string | undefined\n  tracer?: Tracer\n  rateLimiter?: AxRateLimiterFunction\n  stream?: boolean\n  debug?: boolean\n  functions?: AxFunction[]\n  functionCall?: AxChatRequest['functionCall']\n  stopFunction?: string\n}\n\nexport interface AxTunable {\n  setExamples: (examples: Readonly<AxProgramExamples>) => void\n  setId: (id: string) => void\n  setParentId: (parentId: string) => void\n  getTraces: () => AxProgramTrace[]\n  setDemos: (demos: readonly AxProgramDemos[]) => void\n}\n\nexport interface AxUsable {\n  getUsage: () => AxProgramUsage[]\n  resetUsage: () => void\n}\n\nexport type AxProgramUsage = AxChatResponse['modelUsage'] & {\n  ai: string\n  model: string\n}\n\nexport interface AxProgramWithSignatureOptions {\n  description?: string\n}\n\nexport class AxProgramWithSignature<IN extends AxGenIn, OUT extends AxGenOut>\n  implements AxTunable, AxUsable\n{\n  protected signature: AxSignature\n  protected sigHash: string\n\n  protected examples?: Record<string, AxFieldValue>[]\n  protected demos?: Record<string, AxFieldValue>[]\n  protected trace?: Record<string, AxFieldValue>\n  protected usage: AxProgramUsage[] = []\n\n  private key: { id: string; custom?: boolean }\n  private children: AxInstanceRegistry<Readonly<AxTunable & AxUsable>>\n\n  constructor(\n    signature: Readonly<AxSignature | string>,\n    options?: Readonly<AxProgramWithSignatureOptions>\n  ) {\n    this.signature = new AxSignature(signature)\n    this.sigHash = this.signature?.hash()\n    this.children = new AxInstanceRegistry()\n    this.key = { id: this.constructor.name }\n\n    if (options?.description) {\n      this.signature.setDescription(options.description)\n    }\n  }\n\n  public getSignature() {\n    return this.signature\n  }\n\n  public register(prog: Readonly<AxTunable & AxUsable>) {\n    if (this.key) {\n      prog.setParentId(this.key.id)\n    }\n    this.children.register(prog)\n  }\n\n  public async forward(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _ai: Readonly<AxAIService>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _values: IN,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxProgramForwardOptions>\n  ): Promise<OUT> {\n    throw new Error('forward() not implemented')\n  }\n\n  public setId(id: string) {\n    this.key = { id, custom: true }\n    for (const child of this.children) {\n      child.setParentId(id)\n    }\n  }\n\n  public setParentId(parentId: string) {\n    if (!this.key.custom) {\n      this.key.id = [parentId, this.key.id].join('/')\n    }\n  }\n\n  public setExamples(examples: Readonly<AxProgramExamples>) {\n    this._setExamples(examples)\n\n    if (!('programId' in examples)) {\n      return\n    }\n\n    for (const child of this.children) {\n      child.setExamples(examples)\n    }\n  }\n\n  private _setExamples(examples: Readonly<AxProgramExamples>) {\n    let traces: Record<string, AxFieldValue>[] = []\n\n    if ('programId' in examples && examples.programId === this.key.id) {\n      traces = examples.traces\n    }\n\n    if (Array.isArray(examples)) {\n      traces = examples\n    }\n\n    if (traces) {\n      const sig = this.signature\n      const fields = [...sig.getInputFields(), ...sig.getOutputFields()]\n\n      this.examples = traces.map((e) => {\n        const res: Record<string, AxFieldValue> = {}\n        for (const f of fields) {\n          const value = e[f.name]\n          if (value) {\n            validateValue(f, value)\n            res[f.name] = value\n          }\n        }\n        return res\n      })\n    }\n  }\n\n  public getTraces(): AxProgramTrace[] {\n    let traces: AxProgramTrace[] = []\n\n    if (this.trace) {\n      traces.push({ trace: this.trace, programId: this.key.id })\n    }\n\n    for (const child of this.children) {\n      const _traces = child.getTraces()\n      traces = [...traces, ..._traces]\n    }\n    return traces\n  }\n\n  public getUsage(): AxProgramUsage[] {\n    let usage: AxProgramUsage[] = [...(this.usage ?? [])]\n\n    for (const child of this.children) {\n      const cu = child.getUsage()\n      usage = [...usage, ...cu]\n    }\n    return mergeProgramUsage(usage)\n  }\n\n  public resetUsage() {\n    this.usage = []\n    for (const child of this.children) {\n      child.resetUsage()\n    }\n  }\n\n  public setDemos(demos: readonly AxProgramDemos[]) {\n    this.demos = demos\n      .filter((v) => v.programId === this.key.id)\n      .map((v) => v.traces)\n      .flat()\n\n    for (const child of this.children) {\n      child.setDemos(demos)\n    }\n  }\n}\n\nexport class AxProgram<IN extends AxGenIn, OUT extends AxGenOut>\n  implements AxTunable, AxUsable\n{\n  protected trace?: Record<string, AxFieldValue>\n  protected usage: AxProgramUsage[] = []\n\n  private key: { id: string; custom?: boolean }\n  private children: AxInstanceRegistry<Readonly<AxTunable & AxUsable>>\n\n  constructor() {\n    this.children = new AxInstanceRegistry()\n    this.key = { id: this.constructor.name }\n  }\n\n  public register(prog: Readonly<AxTunable & AxUsable>) {\n    if (this.key) {\n      prog.setParentId(this.key.id)\n    }\n    this.children.register(prog)\n  }\n\n  public async forward(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _ai: Readonly<AxAIService>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _values: IN,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxProgramForwardOptions>\n  ): Promise<OUT> {\n    throw new Error('forward() not implemented')\n  }\n\n  public setId(id: string) {\n    this.key = { id, custom: true }\n    for (const child of this.children) {\n      child.setParentId(id)\n    }\n  }\n\n  public setParentId(parentId: string) {\n    if (!this.key.custom) {\n      this.key.id = [parentId, this.key.id].join('/')\n    }\n  }\n\n  public setExamples(examples: Readonly<AxProgramExamples>) {\n    if (!('programId' in examples)) {\n      return\n    }\n\n    for (const child of this.children) {\n      child.setExamples(examples)\n    }\n  }\n\n  public getTraces(): AxProgramTrace[] {\n    let traces: AxProgramTrace[] = []\n\n    if (this.trace) {\n      traces.push({ trace: this.trace, programId: this.key.id })\n    }\n\n    for (const child of this.children) {\n      const _traces = child.getTraces()\n      traces = [...traces, ..._traces]\n    }\n    return traces\n  }\n\n  public getUsage(): AxProgramUsage[] {\n    let usage: AxProgramUsage[] = [...(this.usage ?? [])]\n\n    for (const child of this.children) {\n      const cu = child.getUsage()\n      usage = [...usage, ...cu]\n    }\n    return mergeProgramUsage(usage)\n  }\n\n  public resetUsage() {\n    this.usage = []\n    for (const child of this.children) {\n      child.resetUsage()\n    }\n  }\n\n  public setDemos(demos: readonly AxProgramDemos[]) {\n    for (const child of this.children) {\n      child.setDemos(demos)\n    }\n  }\n}\n","export class AxInstanceRegistry<T> {\n  private reg: Set<T> // To track keys for iteration\n\n  constructor() {\n    this.reg = new Set()\n  }\n\n  register(instance: T): void {\n    this.reg.add(instance)\n  }\n\n  *[Symbol.iterator]() {\n    for (const key of this.reg) {\n      yield key\n    }\n  }\n}\n","import { createHash } from 'crypto'\n\nimport type { AxFunctionJSONSchema } from '../ai/types.js'\n\nimport {\n  type InputParsedField,\n  type OutputParsedField,\n  type ParsedSignature,\n  parseSignature,\n} from './parser.js'\n\nexport interface AxField {\n  name: string\n  title?: string\n  description?: string\n  type?: {\n    name:\n      | 'string'\n      | 'number'\n      | 'boolean'\n      | 'json'\n      | 'image'\n      | 'audio'\n      | 'date'\n      | 'datetime'\n      | 'class'\n    isArray: boolean\n    classes?: string[]\n  }\n  isOptional?: boolean\n}\n\nexport type AxIField = Omit<AxField, 'title'> & { title: string }\n\nexport class AxSignature {\n  private description?: string\n  private inputFields: AxIField[]\n  private outputFields: AxIField[]\n\n  private sigHash: string\n  private sigString: string\n\n  constructor(signature?: Readonly<AxSignature | string>) {\n    if (!signature) {\n      this.inputFields = []\n      this.outputFields = []\n      this.sigHash = ''\n      this.sigString = ''\n      return\n    }\n\n    if (typeof signature === 'string') {\n      let sig: ParsedSignature\n      try {\n        sig = parseSignature(signature)\n      } catch (e) {\n        throw new Error(\n          `Invalid Signature: ${(e as Error).message} (${signature})`\n        )\n      }\n      this.description = sig.desc\n      this.inputFields = sig.inputs.map((v) => this.parseParsedField(v))\n      this.outputFields = sig.outputs.map((v) => this.parseParsedField(v))\n      ;[this.sigHash, this.sigString] = this.updateHash()\n    } else if (signature instanceof AxSignature) {\n      this.description = signature.getDescription()\n      this.inputFields = structuredClone(\n        signature.getInputFields()\n      ) as AxIField[]\n      this.outputFields = structuredClone(\n        signature.getOutputFields()\n      ) as AxIField[]\n      this.sigHash = signature.hash()\n      this.sigString = signature.toString()\n    } else {\n      throw new Error('invalid signature argument: ' + signature)\n    }\n  }\n\n  private parseParsedField = (\n    field: Readonly<InputParsedField | OutputParsedField>\n  ): AxIField => {\n    if (!field.name || field.name.length === 0) {\n      throw new Error('Field name is required.')\n    }\n\n    const title = this.toTitle(field.name)\n    return {\n      name: field.name,\n      title,\n      description: 'desc' in field ? field.desc : undefined,\n      isOptional: field.isOptional,\n      type: field.type ?? { name: 'string', isArray: false },\n    }\n  }\n\n  private parseField = (field: Readonly<AxField>): AxIField => {\n    const title =\n      !field.title || field.title.length === 0\n        ? this.toTitle(field.name)\n        : field.title\n\n    if (field.type && (!field.type.name || field.type.name.length === 0)) {\n      throw new Error('Field type name is required: ' + field.name)\n    }\n\n    return { ...field, title }\n  }\n\n  public setDescription = (desc: string) => {\n    this.description = desc\n    this.updateHash()\n  }\n\n  public addInputField = (field: Readonly<AxField>) => {\n    this.inputFields.push(this.parseField(field))\n    this.updateHash()\n  }\n\n  public addOutputField = (field: Readonly<AxField>) => {\n    this.outputFields.push(this.parseField(field))\n    this.updateHash()\n  }\n\n  public setInputFields = (fields: readonly AxField[]) => {\n    this.inputFields = fields.map((v) => this.parseField(v))\n    this.updateHash()\n  }\n\n  public setOutputFields = (fields: readonly AxField[]) => {\n    this.outputFields = fields.map((v) => this.parseField(v))\n    this.updateHash()\n  }\n\n  public getInputFields = (): Readonly<AxIField[]> => this.inputFields\n  public getOutputFields = (): Readonly<AxIField[]> => this.outputFields\n  public getDescription = () => this.description\n\n  private toTitle = (name: string) => {\n    let result = name.replaceAll('_', ' ')\n    result = result.replace(/([A-Z]|[0-9]+)/g, ' $1').trim()\n    return result.charAt(0).toUpperCase() + result.slice(1)\n  }\n\n  public toJSONSchema = (): AxFunctionJSONSchema => {\n    const properties: Record<string, unknown> = {}\n    const required: Array<string> = []\n\n    for (const f of this.inputFields) {\n      const type = f.type ? f.type.name : 'string'\n      if (f.type?.isArray) {\n        properties[f.name] = {\n          description: f.description,\n          type: 'array' as const,\n          items: {\n            type: type,\n            description: f.description,\n          },\n        }\n      } else {\n        properties[f.name] = {\n          description: f.description,\n          type: type,\n        }\n      }\n\n      if (!f.isOptional) {\n        required.push(f.name)\n      }\n    }\n\n    const schema = {\n      type: 'object',\n      properties: properties,\n      required: required,\n    }\n\n    return schema as AxFunctionJSONSchema\n  }\n\n  private updateHash = (): [string, string] => {\n    this.getInputFields().forEach((field) => {\n      validateField(field)\n    })\n    this.getOutputFields().forEach((field) => {\n      validateField(field)\n      if (field.type?.name === 'image') {\n        throw new Error('Image type is not supported in output fields.')\n      }\n    })\n\n    this.sigHash = createHash('sha256')\n      .update(this.description ?? '')\n      .update(JSON.stringify(this.inputFields))\n      .update(JSON.stringify(this.outputFields))\n      .digest('hex')\n\n    this.sigString = renderSignature(\n      this.description,\n      this.inputFields,\n      this.outputFields\n    )\n\n    return [this.sigHash, this.sigString]\n  }\n\n  public hash = () => this.sigHash\n\n  public toString = () => this.sigString\n}\n\nfunction renderField(field: Readonly<AxField>): string {\n  let result = field.name\n  if (field.isOptional) {\n    result += '?'\n  }\n  if (field.type) {\n    result += ':' + field.type.name\n    if (field.type.isArray) {\n      result += '[]'\n    }\n  }\n  // Check if description exists and append it.\n  if (field.description) {\n    result += ` \"${field.description}\"`\n  }\n  return result\n}\n\nfunction renderSignature(\n  description: string | undefined,\n  inputFields: readonly AxField[],\n  outputFields: readonly AxField[]\n): string {\n  // Prepare the description part of the signature.\n  const descriptionPart = description ? `\"${description}\"` : ''\n\n  // Render each input field into a comma-separated list.\n  const inputFieldsRendered = inputFields.map(renderField).join(', ')\n\n  // Render each output field into a comma-separated list.\n  const outputFieldsRendered = outputFields.map(renderField).join(', ')\n\n  // Combine all parts into the final signature.\n  return `${descriptionPart} ${inputFieldsRendered} -> ${outputFieldsRendered}`\n}\n\nfunction isValidCase(inputString: string): boolean {\n  const camelCaseRegex = /^[a-z][a-zA-Z0-9]*$/\n  const snakeCaseRegex = /^[a-z]+(_[a-z0-9]+)*$/\n\n  return camelCaseRegex.test(inputString) || snakeCaseRegex.test(inputString)\n}\n\nfunction validateField(field: Readonly<AxField>): void {\n  if (!field.name || field.name.length === 0) {\n    throw new Error('Field name cannot be blank')\n  }\n\n  if (!isValidCase(field.name)) {\n    throw new Error(\n      `Invalid field name '${field.name}', it must be camel case or snake case: `\n    )\n  }\n\n  if (\n    [\n      'text',\n      'object',\n      'image',\n      'string',\n      'number',\n      'boolean',\n      'json',\n      'array',\n      'datetime',\n      'date',\n      'time',\n      'type',\n      'class',\n    ].includes(field.name)\n  ) {\n    throw new Error(\n      `Invalid field name '${field.name}', please make it more descriptive (eg. companyDescription)`\n    )\n  }\n}\n","export type TypeNotClass =\n  | 'string'\n  | 'number'\n  | 'boolean'\n  | 'json'\n  | 'image'\n  | 'audio'\n  | 'datetime'\n  | 'date'\nexport type Type = TypeNotClass | 'class'\nexport type ParsedIdentifier = string\nexport type ParsedString = string\n\nexport type ParsedSignature = {\n  desc?: string\n  inputs: InputParsedFieldList\n  outputs: OutputParsedFieldList\n}\n\nexport type InputParsedFieldList = InputParsedField[]\nexport type OutputParsedFieldList = OutputParsedField[]\n\nexport type ClassField = {\n  name: ParsedIdentifier\n  type: { name: 'class'; isArray: boolean; classes: string[] }\n  isOptional: boolean\n}\n\nexport type NonClassField = {\n  name: ParsedIdentifier\n  desc?: string\n  type: NonNullable<{ name: TypeNotClass; isArray: boolean } | null> | undefined\n  isOptional: boolean\n}\n\nexport type InputParsedField = ClassField | NonClassField\n\nexport type OutputParsedField = ClassField | NonClassField\n\nclass SignatureParser {\n  private input: string\n  private position: number\n\n  constructor(input: string) {\n    this.input = input\n    this.position = 0\n  }\n\n  parse(): ParsedSignature {\n    this.skipWhitespace()\n    const optionalDesc = this.parseParsedString()\n    this.skipWhitespace()\n    const inputs = this.parseInputParsedFieldList()\n    this.skipWhitespace()\n    this.expect('->')\n    this.skipWhitespace()\n    const outputs = this.parseOutputParsedFieldList()\n\n    return {\n      desc: optionalDesc?.trim(),\n      inputs,\n      outputs,\n    }\n  }\n\n  private parseInputParsedFieldList(): InputParsedField[] {\n    const fields: InputParsedField[] = []\n    fields.push(this.parseInputParsedField())\n\n    while (this.match(',')) {\n      this.skipWhitespace()\n      fields.push(this.parseInputParsedField())\n    }\n\n    return fields\n  }\n\n  private parseOutputParsedFieldList(): OutputParsedField[] {\n    const fields: OutputParsedField[] = []\n    fields.push(this.parseOutputParsedField())\n\n    while (this.match(',')) {\n      this.skipWhitespace()\n      fields.push(this.parseOutputParsedField())\n    }\n\n    return fields\n  }\n\n  private parseInputParsedField(): InputParsedField {\n    this.skipWhitespace()\n    const name = this.parseParsedIdentifier()\n    const isOptional = this.match('?')\n    let type: { name: TypeNotClass; isArray: boolean } | undefined\n\n    if (this.match(':')) {\n      this.skipWhitespace()\n      const typeName = this.parseTypeNotClass()\n      const isArray = this.match('[]')\n      type = { name: typeName, isArray }\n    }\n\n    this.skipWhitespace()\n    const desc = this.parseParsedString()\n\n    return {\n      name,\n      desc: desc?.trim(),\n      type,\n      isOptional,\n    }\n  }\n\n  private parseOutputParsedField(): OutputParsedField {\n    this.skipWhitespace()\n    const name = this.parseParsedIdentifier()\n    const isOptional = this.match('?')\n    this.skipWhitespace()\n\n    if (this.match(':')) {\n      this.skipWhitespace()\n      if (this.match('class')) {\n        const isArray = this.match('[]')\n        this.skipWhitespace()\n        const desc = this.parseParsedString()\n        if (!desc) {\n          throw new Error(\n            \"Expected description containing class names after type 'class'\"\n          )\n        }\n        const classNames = desc.split(',').map((s) => s.trim())\n        return {\n          name,\n          type: { name: 'class', isArray, classes: classNames },\n          isOptional,\n        }\n      } else {\n        const typeName = this.parseTypeNotClass()\n        const isArray = this.match('[]')\n        this.skipWhitespace()\n        const desc = this.parseParsedString()\n        return {\n          name,\n          desc: desc?.trim(),\n          type: { name: typeName, isArray },\n          isOptional,\n        }\n      }\n    } else {\n      this.skipWhitespace()\n      const desc = this.parseParsedString()\n      return {\n        name,\n        desc: desc?.trim(),\n        type: undefined,\n        isOptional,\n      }\n    }\n  }\n\n  private parseTypeNotClass(): TypeNotClass {\n    const types: TypeNotClass[] = [\n      'string',\n      'number',\n      'boolean',\n      'json',\n      'image',\n      'audio',\n      'datetime',\n      'date',\n    ]\n    for (const type of types) {\n      if (this.match(type)) {\n        return type\n      }\n    }\n    throw new Error(`Expected one of ${types.join(', ')}`)\n  }\n\n  private parseParsedIdentifier(): ParsedIdentifier {\n    const match = /^[a-zA-Z_][a-zA-Z_0-9]*/.exec(\n      this.input.slice(this.position)\n    )\n    if (match) {\n      this.position += match[0].length\n      return match[0]\n    }\n    throw new Error('Expected identifier')\n  }\n\n  private parseParsedString(): string | undefined {\n    if (this.match(\"'\")) {\n      const endQuote = this.input.indexOf(\"'\", this.position)\n      if (endQuote === -1) throw new Error('Unterminated string')\n      const content = this.input.slice(this.position, endQuote)\n      this.position = endQuote + 1\n      return content\n    } else if (this.match('\"')) {\n      const endQuote = this.input.indexOf('\"', this.position)\n      if (endQuote === -1) throw new Error('Unterminated string')\n      const content = this.input.slice(this.position, endQuote)\n      this.position = endQuote + 1\n      return content\n    }\n    return undefined\n  }\n\n  private skipWhitespace() {\n    const match = /^[ \\t\\r\\n]+/.exec(this.input.slice(this.position))\n    if (match) {\n      this.position += match[0].length\n    }\n  }\n\n  private match(str: string): boolean {\n    if (this.input.startsWith(str, this.position)) {\n      this.position += str.length\n      return true\n    }\n    return false\n  }\n\n  private expect(str: string) {\n    if (!this.match(str)) {\n      throw new Error(`Expected \"${str}\"`)\n    }\n  }\n}\n\nexport function parseSignature(input: string): ParsedSignature {\n  const parser = new SignatureParser(input)\n  return parser.parse()\n}\n","import { ColorLog } from '../util/log.js'\n\nimport type { AxFieldValue, AxProgramUsage } from './program.js'\nimport type { AxField } from './sig.js'\n\nconst colorLog = new ColorLog()\n\nexport const updateProgressBar = (\n  current: number,\n  total: number,\n  success: number,\n  elapsedTime: number, // in seconds\n  progressBarWidth: number = 20, // Default width of the progress bar\n  msg: string\n): void => {\n  const percentage = ((current / total) * 100).toFixed(1)\n  const filledBarLength = Math.round((progressBarWidth * current) / total)\n  const emptyBarLength = progressBarWidth - filledBarLength\n  const filledBar = colorLog.blueBright('█'.repeat(filledBarLength))\n  const emptyBar = ' '.repeat(emptyBarLength)\n  const itemsPerSecond =\n    elapsedTime > 0 ? (current / elapsedTime).toFixed(2) : '0.00'\n\n  process.stdout.write(\n    `\\r${msg}: ${current} / ${total} (${colorLog.yellow(percentage)}%): 100%|${filledBar}${emptyBar}| Success: ${success}/${total} [${colorLog.red(elapsedTime.toFixed(2))}, ${itemsPerSecond}it/s]`\n  )\n}\n\nexport const validateValue = (\n  field: Readonly<AxField>,\n  value: Readonly<AxFieldValue>\n): void => {\n  const ft = field.type ?? { name: 'string', isArray: false }\n\n  const validateSingleValue = (\n    expectedType: string,\n    val: Readonly<AxFieldValue>\n  ): boolean => {\n    switch (expectedType) {\n      case 'string':\n        return typeof val === 'string'\n      case 'number':\n        return typeof val === 'number'\n      case 'boolean':\n        return typeof val === 'boolean'\n      case 'date':\n        return val instanceof Date || typeof val === 'string'\n      case 'datetime':\n        return val instanceof Date || typeof val === 'string'\n      default:\n        return false // Unknown or unsupported type\n    }\n  }\n\n  const validImage = (val: Readonly<AxFieldValue>): boolean => {\n    if (\n      !val ||\n      typeof val !== 'object' ||\n      !('mimeType' in val) ||\n      !('data' in val)\n    ) {\n      return false\n    }\n    return true\n  }\n\n  if (field.type?.name === 'image') {\n    let msg\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (!validImage(item)) {\n          msg = 'object ({ mimeType: string; data: string })'\n          break\n        }\n      }\n    } else if (!validImage(value)) {\n      msg = 'object ({ mimeType: string; data: string })'\n    }\n\n    if (msg) {\n      throw new Error(\n        `Validation failed: Expected '${field.name}' to be a ${msg} instead got '${value}'`\n      )\n    }\n    return\n  }\n\n  const validAudio = (val: Readonly<AxFieldValue>): boolean => {\n    if (!val || typeof val !== 'object' || !('data' in val)) {\n      return false\n    }\n    return true\n  }\n\n  if (field.type?.name === 'audio') {\n    let msg\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (!validAudio(item)) {\n          msg = 'object ({ data: string; format?: string })'\n          break\n        }\n      }\n    } else if (!validAudio(value)) {\n      msg = 'object ({ data: string; format?: string })'\n    }\n\n    if (msg) {\n      throw new Error(\n        `Validation failed: Expected '${field.name}' to be a ${msg} instead got '${value}'`\n      )\n    }\n    return\n  }\n\n  let isValid = true\n\n  if (ft.isArray) {\n    if (!Array.isArray(value)) {\n      isValid = false\n    } else {\n      for (const item of value) {\n        if (!validateSingleValue(ft.name, item)) {\n          isValid = false\n          break\n        }\n      }\n    }\n  } else {\n    isValid = validateSingleValue(ft.name, value)\n  }\n\n  if (!isValid) {\n    throw new Error(\n      `Validation failed: Expected '${field.name}' to be a ${field.type?.isArray ? 'an array of ' : ''}${ft.name} instead got '${typeof value}' (${value})`\n    )\n  }\n}\n\nexport function mergeProgramUsage(\n  usages: readonly AxProgramUsage[]\n): AxProgramUsage[] {\n  const usageMap: { [key: string]: AxProgramUsage } = {}\n\n  usages.forEach((usage) => {\n    const key = `${usage.ai}:${usage.model}`\n\n    if (!usageMap[key]) {\n      usageMap[key] = { ...usage }\n      return\n    }\n\n    usageMap[key]!.promptTokens += usage.promptTokens\n    usageMap[key]!.completionTokens += usage.completionTokens\n    usageMap[key]!.totalTokens += usage.totalTokens\n  })\n\n  return Object.values(usageMap)\n}\n\n/**\n * Parses a markdown list from a string. This is a very forgiving parser that\n * will try to handle anything that looks vaguely like a markdown list.\n */\nexport const parseMarkdownList = (input: string): string[] => {\n  // Handle empty input\n  if (!input.trim()) {\n    return []\n  }\n\n  const listBullets = new Set(['-', '*', '+'])\n  const numberedListRegex = /^\\d+[\\s]*[.)\\]]\\s*/\n\n  const lines = input.split('\\n')\n  const list = []\n\n  for (const line of lines) {\n    const trimmedLine = line.trim()\n    // Skip empty lines\n    if (!trimmedLine) {\n      continue\n    }\n\n    // Check for bullet points\n    if (trimmedLine[0] && listBullets.has(trimmedLine[0])) {\n      list.push(trimmedLine.slice(1).trim())\n    }\n    // Check for numbered lists (e.g., \"1.\", \"2.\", etc.)\n    else if (numberedListRegex.test(trimmedLine)) {\n      list.push(trimmedLine.replace(numberedListRegex, '').trim())\n    }\n    // If it's not a list item and we haven't collected any items yet, skip it\n    else if (list.length === 0) {\n      continue\n    }\n    // If we've already started collecting list items, then this non-list line\n    //is an error\n    else {\n      throw new Error('Could not parse markdown list: mixed content detected')\n    }\n  }\n\n  // If we didn't find any list items, throw error\n  if (list.length === 0) {\n    throw new Error('Could not parse markdown list: no valid list items found')\n  }\n\n  return list\n}\n","import type { AxChatRequest } from '../ai/types.js'\n\nimport { formatDateWithTimezone } from './datetime.js'\nimport type { AxInputFunctionType } from './functions.js'\nimport { type AxFieldValue } from './program.js'\nimport type { AxField, AxIField, AxSignature } from './sig.js'\nimport { validateValue } from './util.js'\n\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] }\ntype AxChatRequestChatPrompt = Writeable<AxChatRequest['chatPrompt'][0]>\n\ntype ChatRequestUserMessage = Exclude<\n  Extract<AxChatRequestChatPrompt, { role: 'user' }>['content'],\n  string\n>\n\nconst formattingRules = `\nWhen providing responses:\n1. Only output the exact requested content - no additional text, commentary, explanations, or clarifications\n2. Each key's value must strictly adhere to the formatting rules specified in the reference documentation \n3. Follow all formatting conventions precisely as defined\n4. Do not add any extra content beyond what is explicitly requested\n5. Match the exact structure and format specifications for each field\n6. No preamble, postscript, or supplementary information\n7. Pure output only - conforming exactly to the documented requirements`\n\nexport type AxFieldTemplateFn = (\n  field: Readonly<AxField>,\n  value: Readonly<AxFieldValue>\n) => ChatRequestUserMessage\n\nexport class AxPromptTemplate {\n  private sig: Readonly<AxSignature>\n  private fieldTemplates?: Record<string, AxFieldTemplateFn>\n  private task: { type: 'text'; text: string }\n\n  constructor(\n    sig: Readonly<AxSignature>,\n    functions?: Readonly<AxInputFunctionType>,\n    fieldTemplates?: Record<string, AxFieldTemplateFn>\n  ) {\n    this.sig = sig\n    this.fieldTemplates = fieldTemplates\n\n    const inArgs = this.renderDescFields(this.sig.getInputFields())\n    const outArgs = this.renderDescFields(this.sig.getOutputFields())\n    const task = [\n      `You will be provided with the following fields: ${inArgs}. Your task is to generate two new fields: ${outArgs}.`,\n    ]\n\n    const funcs = functions?.map((f) =>\n      'toFunction' in f ? f.toFunction() : f\n    )\n\n    const funcList = funcs\n      ?.map(\n        (fn) => `- \\`${fn.name}\\`: ${capitalizeFirstLetter(fn.description)}`\n      )\n      .join('\\n')\n\n    if (funcList && funcList.length > 0) {\n      task.push(`## Available Functions\\n${funcList}`)\n\n      task.push(\n        `Complete the task, using the functions defined earlier in this prompt, as needed. The output field values may be generated by applying these functions if appropriate for the task.`\n      )\n    }\n\n    const inputFields = this.renderFields(this.sig.getInputFields())\n    task.push(`## Input Fields\\n${inputFields}`)\n\n    const outputFields = this.renderFields(this.sig.getOutputFields())\n    task.push(`## Output Fields\\n${outputFields}`)\n\n    task.push(\n      'Output must be in plain text, with each `key: value` pair on a new line. The format of each `value` should strictly adhere to the formatting instructions for its corresponding `key`, as defined earlier in this prompt.'\n    )\n\n    task.push(formattingRules)\n\n    const desc = this.sig.getDescription()\n    if (desc) {\n      task.push(\n        `## TASK DESCRIPTION\\n${capitalizeFirstLetter(desc.endsWith('.') ? desc : desc + '.')}`\n      )\n    }\n\n    this.task = {\n      type: 'text' as const,\n      text: task.join('\\n\\n'),\n    }\n  }\n\n  public render = <T extends Record<string, AxFieldValue>>(\n    values: T,\n    {\n      examples,\n      demos,\n    }: Readonly<{\n      skipSystemPrompt?: boolean\n      examples?: Record<string, AxFieldValue>[]\n      demos?: Record<string, AxFieldValue>[]\n    }>\n  ): AxChatRequest['chatPrompt'] => {\n    const renderedExamples = examples\n      ? [\n          { type: 'text' as const, text: '## Examples:\\n' },\n          ...this.renderExamples(examples),\n        ]\n      : []\n\n    const renderedDemos = demos ? this.renderDemos(demos) : []\n\n    const completion = this.renderInputFields(values)\n\n    // Check if demos and examples are all text type\n    const allTextExamples = renderedExamples.every((v) => v.type === 'text')\n    const allTextDemos = renderedDemos.every((v) => v.type === 'text')\n    const examplesInSystemPrompt = allTextExamples && allTextDemos\n\n    let systemContent = this.task.text\n\n    if (examplesInSystemPrompt) {\n      const combinedItems = [\n        { type: 'text' as const, text: systemContent + '\\n\\n' },\n        ...renderedExamples,\n        ...renderedDemos,\n      ]\n      combinedItems.reduce(combineConsecutiveStrings(''), [])\n\n      if (combinedItems && combinedItems[0]) {\n        systemContent = combinedItems[0].text\n      }\n    }\n\n    const systemPrompt = {\n      role: 'system' as const,\n      content: systemContent,\n    }\n\n    const promptList: ChatRequestUserMessage = examplesInSystemPrompt\n      ? completion\n      : [...renderedExamples, ...renderedDemos, ...completion]\n\n    const prompt = promptList.filter((v) => v !== undefined)\n\n    const userContent = prompt.every((v) => v.type === 'text')\n      ? prompt.map((v) => v.text).join('\\n')\n      : prompt.reduce(combineConsecutiveStrings('\\n'), [])\n\n    const userPrompt = {\n      role: 'user' as const,\n      content: userContent,\n    }\n\n    return [systemPrompt, userPrompt]\n  }\n\n  public renderExtraFields = (extraFields: readonly AxIField[]) => {\n    const prompt: ChatRequestUserMessage = []\n\n    if (extraFields && extraFields.length > 0) {\n      extraFields.forEach((field) => {\n        // if (!field.isOptional && !field.value) {\n        //   throw new Error(`Value for field '${field.name}' is required.`);\n        // }\n        const fn =\n          this.fieldTemplates?.[field.name] ?? this.defaultRenderInField\n        // if (!field.description || field.description.length === 0) {\n        //   throw new Error(`Description for field '${field.name}' is required`);\n        // }\n        prompt.push(...fn(field, field.description))\n      })\n    }\n    if (prompt.every((v) => v.type === 'text')) {\n      return prompt.map((v) => v.text).join('\\n\\n')\n    }\n\n    return prompt.reduce(combineConsecutiveStrings('\\n'), [])\n  }\n\n  private renderExamples = (data: Readonly<Record<string, AxFieldValue>[]>) => {\n    const list: ChatRequestUserMessage = []\n\n    for (const [index, item] of data.entries()) {\n      const renderedInputItem = this.sig\n        .getInputFields()\n        .map((field) => this.renderInField(field, item, true))\n        .filter((v) => v !== undefined)\n        .flat()\n\n      const renderedOutputItem = this.sig\n        .getOutputFields()\n        .map((field) => this.renderInField(field, item, true))\n        .filter((v) => v !== undefined)\n        .flat()\n\n      if (renderedOutputItem.length === 0) {\n        throw new Error(\n          `Output fields are required in examples: index: ${index}, data: ${JSON.stringify(item)}`\n        )\n      }\n\n      const renderedItem = [...renderedInputItem, ...renderedOutputItem]\n\n      renderedItem.forEach((v) => {\n        if ('text' in v) {\n          v.text = v.text + '\\n'\n        }\n        if ('image' in v) {\n          v.image = v.image\n        }\n        list.push(v)\n      })\n    }\n\n    return list\n  }\n\n  private renderDemos = (data: Readonly<Record<string, AxFieldValue>[]>) => {\n    const list: ChatRequestUserMessage = []\n\n    const fields = [...this.sig.getInputFields(), ...this.sig.getOutputFields()]\n\n    for (const item of data) {\n      const renderedItem = fields\n        .map((field) => this.renderInField(field, item, true))\n        .filter((v) => v !== undefined)\n        .flat()\n\n      renderedItem.slice(0, -1).forEach((v) => {\n        if ('text' in v) {\n          v.text = v.text + '\\n'\n        }\n        if ('image' in v) {\n          v.image = v.image\n        }\n        list.push(v)\n      })\n    }\n\n    return list\n  }\n\n  private renderInputFields = <T extends Record<string, AxFieldValue>>(\n    values: T\n  ) => {\n    const renderedItems = this.sig\n      .getInputFields()\n      .map((field) => this.renderInField(field, values))\n      .filter((v) => v !== undefined)\n      .flat()\n\n    renderedItems\n      .filter((v) => v.type === 'text')\n      .forEach((v) => {\n        v.text = v.text + '\\n'\n      })\n\n    return renderedItems\n  }\n\n  private renderInField = (\n    field: Readonly<AxField>,\n    values: Readonly<Record<string, AxFieldValue>>,\n    skipMissing?: boolean\n  ) => {\n    const value = values[field.name]\n\n    if (skipMissing && !value) {\n      return\n    }\n\n    if (isEmptyValue(field, value)) {\n      return\n    }\n\n    if (field.type) {\n      validateValue(field, value!)\n    }\n\n    const processedValue = processValue(field, value!)\n\n    const textFieldFn: AxFieldTemplateFn =\n      this.fieldTemplates?.[field.name] ?? this.defaultRenderInField\n\n    return textFieldFn(field, processedValue)\n  }\n\n  private defaultRenderInField = (\n    field: Readonly<AxField>,\n    value: Readonly<AxFieldValue>\n  ): ChatRequestUserMessage => {\n    if (field.type?.name === 'image') {\n      const validateImage = (\n        value: Readonly<AxFieldValue>\n      ): { mimeType: string; data: string } => {\n        if (!value) {\n          throw new Error('Image field value is required.')\n        }\n\n        if (typeof value !== 'object') {\n          throw new Error('Image field value must be an object.')\n        }\n        if (!('mimeType' in value)) {\n          throw new Error('Image field must have mimeType')\n        }\n        if (!('data' in value)) {\n          throw new Error('Image field must have data')\n        }\n        return value\n      }\n\n      let result: ChatRequestUserMessage = [\n        { type: 'text', text: `${field.title}: ` as string },\n      ]\n\n      if (field.type.isArray) {\n        if (!Array.isArray(value)) {\n          throw new Error('Image field value must be an array.')\n        }\n        result = result.concat(\n          value.map((v) => {\n            v = validateImage(v)\n            return {\n              type: 'image',\n              mimeType: v.mimeType,\n              image: v.data,\n            }\n          })\n        )\n      } else {\n        const v = validateImage(value)\n        result.push({\n          type: 'image',\n          mimeType: v.mimeType,\n          image: v.data,\n        })\n      }\n      return result\n    }\n\n    if (field.type?.name === 'audio') {\n      const validateAudio = (\n        value: Readonly<AxFieldValue>\n      ): { format?: 'wav'; data: string } => {\n        if (!value) {\n          throw new Error('Audio field value is required.')\n        }\n\n        if (typeof value !== 'object') {\n          throw new Error('Audio field value must be an object.')\n        }\n        if (!('data' in value)) {\n          throw new Error('Audio field must have data')\n        }\n        return value\n      }\n\n      let result: ChatRequestUserMessage = [\n        { type: 'text', text: `${field.title}: ` as string },\n      ]\n\n      if (field.type.isArray) {\n        if (!Array.isArray(value)) {\n          throw new Error('Image field value must be an array.')\n        }\n        result = result.concat(\n          value.map((v) => {\n            v = validateAudio(v)\n            return {\n              type: 'audio',\n              format: v.format ?? 'wav',\n              data: v.data,\n            }\n          })\n        )\n      } else {\n        const v = validateAudio(value)\n        result.push({\n          type: 'audio',\n          format: v.format ?? 'wav',\n          data: v.data,\n        })\n      }\n      return result\n    }\n\n    const text = [field.title, ': ']\n\n    if (Array.isArray(value)) {\n      text.push('\\n')\n      text.push(value.map((v) => `- ${v}`).join('\\n'))\n    } else {\n      text.push(value as string)\n    }\n    return [{ type: 'text', text: text.join('') }]\n  }\n\n  private renderDescFields = (list: readonly AxField[]) =>\n    list.map((v) => `\\`${v.title}\\``).join(', ')\n\n  private renderFields = (fields: readonly AxField[]) => {\n    // Transform each field into table row\n    const rows = fields.map((field) => {\n      const name = field.title\n      const type = field.type?.name ? toFieldType(field.type) : 'string'\n      const required = field.isOptional ? 'optional' : 'required'\n      const description = field.description\n        ? `: ${capitalizeFirstLetter(field.description)}`\n        : ''\n\n      // Eg. - `Conversation` (string, optional): The conversation context.\n      return `- \\`${name}\\` (${type}, ${required})${description}`.trim()\n    })\n\n    return rows.join('\\n')\n  }\n}\n\nconst processValue = (\n  field: Readonly<AxField>,\n  value: Readonly<AxFieldValue>\n): AxFieldValue => {\n  if (field.type?.name === 'date' && value instanceof Date) {\n    const v = value.toISOString()\n    return v.slice(0, v.indexOf('T'))\n  }\n  if (field.type?.name === 'datetime' && value instanceof Date) {\n    return formatDateWithTimezone(value)\n  }\n  if (field.type?.name === 'image' && typeof value === 'object') {\n    return value\n  }\n  if (field.type?.name === 'audio' && typeof value === 'object') {\n    return value\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    return value\n  }\n  return JSON.stringify(value)\n}\n\n// const toVar = (name: string, type?: Readonly<Field['type']>) => {\n//   const fmt = type ? type.name + (type.isArray ? '[]' : '') : undefined;\n\n//   return '${' + name + (fmt ? `:${fmt}` : '') + '}';\n// };\n\nexport const toFieldType = (type: Readonly<AxField['type']>) => {\n  const baseType = (() => {\n    switch (type?.name) {\n      case 'string':\n        return 'string'\n      case 'number':\n        return 'number'\n      case 'boolean':\n        return 'boolean'\n      case 'date':\n        return 'date (\"YYYY-MM-DD\" format)'\n      case 'datetime':\n        return 'date time (\"YYYY-MM-DD HH:mm Timezone\" format)'\n      case 'json':\n        return 'JSON object'\n      case 'class':\n        return `classification class (allowed classes: ${type.classes?.join(', ')})`\n      default:\n        return 'string'\n    }\n  })()\n\n  return type?.isArray ? `json array of ${baseType} items` : baseType\n}\n\nfunction combineConsecutiveStrings(separator: string) {\n  return (\n    acc: ChatRequestUserMessage,\n\n    current: ChatRequestUserMessage[0]\n  ) => {\n    if (current.type === 'text') {\n      const previous = acc.length > 0 ? acc[acc.length - 1] : null\n      if (previous && previous.type === 'text') {\n        // If the last item in the accumulator is a string, append the current string to it with the separator\n        previous.text += separator + current.text\n      } else {\n        // Otherwise, push the current string into the accumulator\n        acc.push(current)\n      }\n    } else {\n      // If current is not of type 'text', just add it to the accumulator\n      acc.push(current)\n    }\n    return acc\n  }\n}\n\nconst isEmptyValue = (\n  field: Readonly<AxField>,\n  value?: Readonly<AxFieldValue>\n) => {\n  // Boolean type can't be empty\n  if (typeof value === 'boolean') {\n    return false\n  }\n\n  if (\n    !value ||\n    ((Array.isArray(value) || typeof value === 'string') && value.length === 0)\n  ) {\n    if (field.isOptional) {\n      return true\n    }\n    throw new Error(`Value for input field '${field.name}' is required.`)\n  }\n  return false\n}\n\nfunction capitalizeFirstLetter(str: string) {\n  if (str.length === 0) {\n    return ''\n  }\n  return `${str.charAt(0).toUpperCase()}${str.slice(1)}`\n}\n","import { toFieldType } from './prompt.js'\nimport type { AxField } from './sig.js'\n\nexport class AxValidationError extends Error {\n  private field: AxField\n  private value: string\n\n  constructor({\n    message,\n    field,\n    value,\n  }: Readonly<{\n    message: string\n    field: AxField\n    value: string\n  }>) {\n    super(message)\n    this.field = field\n    this.value = value\n    this.name = this.constructor.name\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  public getField = () => this.field\n  public getValue = () => this.value\n\n  public getFixingInstructions = () => {\n    const f = this.field\n\n    const extraFields = [\n      {\n        name: `invalidField`,\n        title: `Invalid Field`,\n        description: `Ensure the field \\`${f.title}\\` is of type \\`${toFieldType(f.type)}\\``,\n      },\n    ]\n\n    return extraFields\n  }\n}\n","import JSON5 from 'json5'\n\nimport type {\n  AxAIService,\n  AxAIServiceActionOptions,\n  AxChatResponseResult,\n  AxFunction,\n} from '../ai/types.js'\nimport type { AxMemory } from '../mem/memory.js'\n\nimport { validateJSONSchema } from './jsonschema.js'\n\nexport type AxChatResponseFunctionCall = {\n  id?: string\n  name: string\n  args: string\n}\n\nexport type AxFunctionExec = {\n  id?: string\n  result?: string\n}\n\nexport class AxFunctionProcessor {\n  private funcList: Readonly<AxFunction[]> = []\n\n  constructor(funcList: Readonly<AxFunction[]>) {\n    this.funcList = funcList\n  }\n\n  private executeFunction = async (\n    fnSpec: Readonly<AxFunction>,\n    func: Readonly<AxChatResponseFunctionCall>,\n    options?: Readonly<AxAIServiceActionOptions>\n  ): Promise<AxFunctionExec> => {\n    let args\n\n    if (typeof func.args === 'string' && func.args.length > 0) {\n      args = JSON5.parse(func.args)\n    } else {\n      args = func.args\n    }\n\n    const opt = options\n      ? {\n          sessionId: options.sessionId,\n          traceId: options.traceId,\n          ai: options.ai,\n        }\n      : undefined\n\n    if (!fnSpec.parameters) {\n      const res =\n        fnSpec.func.length === 1 ? await fnSpec.func(opt) : await fnSpec.func()\n\n      return {\n        id: func.id,\n        result: JSON.stringify(res, null, 2),\n      }\n    }\n\n    const res =\n      fnSpec.func.length === 2\n        ? await fnSpec.func(args, opt)\n        : await fnSpec.func(args)\n\n    return {\n      id: func.id,\n      result: JSON.stringify(res, null, 2),\n    }\n  }\n\n  public execute = async (\n    func: Readonly<AxChatResponseFunctionCall>,\n    options?: Readonly<AxAIServiceActionOptions>\n  ): Promise<AxFunctionExec> => {\n    const fnSpec = this.funcList.find(\n      (v) => v.name.localeCompare(func.name) === 0\n    )\n    if (!fnSpec) {\n      throw new Error(`Function not found: ` + func.name)\n    }\n    if (!fnSpec.func) {\n      throw new Error('No handler for function: ' + func.name)\n    }\n\n    // execute value function calls\n    return await this.executeFunction(fnSpec, func, options)\n  }\n}\n\nexport type AxInputFunctionType =\n  | AxFunction[]\n  | {\n      toFunction: () => AxFunction\n    }[]\n\nexport const parseFunctions = (\n  newFuncs: Readonly<AxInputFunctionType>,\n  existingFuncs?: readonly AxFunction[]\n): AxFunction[] => {\n  if (newFuncs.length === 0) {\n    return [...(existingFuncs ?? [])]\n  }\n\n  const functions = newFuncs.map((f) => {\n    if ('toFunction' in f) {\n      return f.toFunction()\n    }\n    return f\n  })\n\n  for (const fn of functions.filter((v) => v.parameters)) {\n    validateJSONSchema(fn.parameters!)\n  }\n\n  return [...(existingFuncs ?? []), ...functions]\n}\n\nexport const processFunctions = async (\n  ai: Readonly<AxAIService>,\n  functionList: Readonly<AxFunction[]>,\n  functionCalls: readonly AxChatResponseFunctionCall[],\n  mem: Readonly<AxMemory>,\n  sessionId?: string,\n  traceId?: string\n) => {\n  const funcProc = new AxFunctionProcessor(functionList)\n  const functionsExecuted = new Set<string>()\n\n  // Map each function call to a promise that resolves to the function result or null\n  const promises = functionCalls.map((func) =>\n    funcProc?.execute(func, { sessionId, traceId, ai }).then((fres) => {\n      functionsExecuted.add(func.name.toLowerCase())\n\n      if (fres?.id) {\n        return {\n          role: 'function' as const,\n          result: fres.result ?? '',\n          functionId: fres.id,\n        }\n      }\n      return null // Returning null for function calls that don't meet the condition\n    })\n  )\n\n  // Wait for all promises to resolve\n  const results = await Promise.all(promises)\n\n  results.forEach((result) => {\n    if (result) {\n      mem.add(result, sessionId)\n    }\n  })\n\n  return functionsExecuted\n}\n\nexport function parseFunctionCalls(\n  ai: Readonly<AxAIService>,\n  functionCalls: Readonly<AxChatResponseResult['functionCalls']>,\n  values: Record<string, unknown>,\n  model?: string\n): AxChatResponseFunctionCall[] | undefined {\n  if (!functionCalls || functionCalls.length === 0) {\n    return\n  }\n  if (!ai.getFeatures(model).functions) {\n    throw new Error('Functions are not supported by the AI service')\n  }\n\n  const funcs: AxChatResponseFunctionCall[] = functionCalls.map((f) => ({\n    id: f.id,\n    name: f.function.name,\n    args: f.function.params as string,\n  }))\n\n  // for (const [i, f] of funcs.entries()) {\n  //   values['functionName' + i] = f.name;\n  //   values['functionArguments' + i] =\n  //     typeof f.args === 'object' ? JSON.stringify(f.args) : f.args;\n  // }\n  return funcs\n}\n","import type { AxFunctionJSONSchema } from '../ai/types.js'\n\nexport const validateJSONSchema = (\n  schema: Readonly<AxFunctionJSONSchema>\n): void => {\n  const errors: string[] = []\n\n  const validateSchemaObject = (\n    schema: Readonly<AxFunctionJSONSchema>,\n    path: string = ''\n  ): void => {\n    const validTypes = [\n      'array',\n      'integer',\n      'number',\n      'string',\n      'boolean',\n      'null',\n      'object',\n    ]\n\n    if (!validTypes.includes(schema.type)) {\n      errors.push(`Invalid type '${schema.type}' at ${path || 'root'}`)\n      return\n    }\n\n    if (schema.type === 'object' && schema.properties) {\n      if (\n        typeof schema.properties !== 'object' ||\n        Array.isArray(schema.properties)\n      ) {\n        errors.push(`Invalid properties object at ${path || 'root'}`)\n      } else {\n        for (const key in schema.properties) {\n          const value = schema.properties[key]\n          if (typeof value !== 'object') {\n            errors.push(`Invalid schema object at ${path}${key}`)\n            continue\n          }\n          validateSchemaObject(value, `${path}${key}.`)\n        }\n      }\n\n      if (schema.required && !Array.isArray(schema.required)) {\n        errors.push(`'required' should be an array at ${path || 'root'}`)\n      }\n    }\n\n    if (schema.type === 'array' && schema.items) {\n      if (typeof schema.items !== 'object') {\n        errors.push(`Invalid items schema at ${path || 'root'}`)\n      } else {\n        validateSchemaObject(schema.items, `${path}items.`)\n      }\n    }\n  }\n\n  validateSchemaObject(schema)\n\n  if (errors.length > 0) {\n    throw new Error(errors.join('; '))\n  }\n}\n\n// Example Usage:\n\n/*\nconst validSchema: AxFunctionJSONSchema = {\n  type: 'object',\n  properties: {\n    id: { type: 'integer' },\n    name: { type: 'string' },\n    email: { type: 'string' },\n    isActive: { type: 'boolean' },\n    tags: {\n      type: 'array',\n      items: { type: 'string' }\n    }\n  },\n  required: ['id', 'name', 'email']\n};\n\nconst invalidSchema: any = {\n  type: 'object',\n  properties: {\n    id: { type: 'integer' },\n    name: { type: 'string' },\n    email: { type: 'unknownType' }, // Invalid type\n    isActive: { type: 'boolean' },\n    tags: {\n      type: 'array',\n      items: { type: 'string' }\n    }\n  },\n  required: 'id,name,email' // Invalid 'required' field\n};\n\ntry {\n  validateSchemaStructure(validSchema);\n  console.log('Schema is valid!');\n} catch (error) {\n  console.error('Schema validation failed:', error.message);\n}\n\ntry {\n  validateSchemaStructure(invalidSchema);\n  console.log('Schema is valid!');\n} catch (error) {\n  console.error('Schema validation failed:', error.message);\n}\n*/\n","import { createReadStream } from 'node:fs'\n\nexport interface AxApacheTikaArgs {\n  url?: string | URL\n  fetch?: typeof fetch\n}\n\nexport interface AxApacheTikaConvertOptions {\n  format?: 'text' | 'html'\n}\n\nexport class AxApacheTika {\n  private tikaUrl: URL\n  private fetch?: typeof fetch\n\n  constructor(args?: Readonly<AxApacheTikaArgs>) {\n    const _args = args ?? { url: 'http://localhost:9998/' }\n    this.tikaUrl = new URL('/tika', _args.url)\n    this.fetch = _args.fetch\n  }\n\n  private async _convert(\n    file: string | Blob,\n    options?: Readonly<AxApacheTikaConvertOptions>\n  ): Promise<string> {\n    const fileData =\n      typeof file === 'string' ? createReadStream(file) : file.stream()\n\n    if (!fileData) {\n      throw new Error('Failed to read file data')\n    }\n\n    const acceptValue = options?.format === 'html' ? 'text/html' : 'text/plain'\n\n    try {\n      const res = await (this.fetch ?? fetch)(this.tikaUrl, {\n        body: fileData,\n        headers: { Accept: acceptValue },\n        duplex: 'half',\n        method: 'PUT',\n      })\n\n      if (!res.ok) {\n        throw new Error(`Failed to upload file: ${res.statusText}`)\n      }\n\n      const text = await res.text()\n      return text\n    } catch (error) {\n      throw new Error(`Error converting file: ${error}`)\n    }\n  }\n\n  public async convert(\n    files: Readonly<string[] | Blob[]>,\n    options?: Readonly<{ batchSize?: number; format?: 'html' | 'text' }>\n  ): Promise<string[]> {\n    const results: string[] = []\n    const bs = options?.batchSize ?? 10\n\n    for (let i = 0; i < files.length; i += bs) {\n      const batch = files.slice(i, i + bs)\n      const uploadPromises = batch.map((files) =>\n        this._convert(files, { format: options?.format })\n      )\n      const batchResults = await Promise.all(uploadPromises)\n      results.push(...batchResults)\n    }\n\n    return results\n  }\n}\nexport default AxApacheTika\n","import type { ReadableStream } from 'stream/web'\n\nimport type {\n  AxAIModelMap,\n  AxAIPromptConfig,\n  AxAIService,\n  AxAIServiceActionOptions,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxModelInfoWithProvider,\n} from './types.js'\n\n/**\n * Service comparator that sorts services by cost.\n */\nexport const axCostComparator = (a: AxAIService, b: AxAIService) => {\n  const aInfo = a.getModelInfo()\n  const bInfo = b.getModelInfo()\n  const aTotalCost =\n    (aInfo.promptTokenCostPer1M || Infinity) +\n    (aInfo.completionTokenCostPer1M || Infinity)\n  const bTotalCost =\n    (bInfo.promptTokenCostPer1M || Infinity) +\n    (bInfo.completionTokenCostPer1M || Infinity)\n  return aTotalCost - bTotalCost\n}\n\n/**\n * Service comparator that respects the input order of services.\n */\nexport const axInputOrderComparator = () => 0\n\n/**\n * Options for the balancer.\n */\nexport type AxBalancerOptions = {\n  comparator?: (a: AxAIService, b: AxAIService) => number\n}\n\n/**\n * Balancer that rotates through services.\n */\nexport class AxBalancer implements AxAIService {\n  private services: AxAIService[]\n  private currentServiceIndex: number = 0\n  private currentService: AxAIService\n\n  constructor(services: readonly AxAIService[], options?: AxBalancerOptions) {\n    if (services.length === 0) {\n      throw new Error('No AI services provided.')\n    }\n\n    this.services = [...services].sort(options?.comparator ?? axCostComparator)\n\n    const cs = this.services[this.currentServiceIndex]\n    if (cs === undefined) {\n      throw new Error('Error initializing the AI services.') // More specific error message\n    }\n    this.currentService = cs\n  }\n\n  getModelMap(): AxAIModelMap | undefined {\n    throw new Error('Method not implemented.')\n  }\n\n  private getNextService(): boolean {\n    const cs = this.services[++this.currentServiceIndex]\n    if (cs === undefined) {\n      return false\n    }\n    this.currentService = cs\n    return true\n  }\n\n  private reset(): void {\n    this.currentServiceIndex = 0\n    const cs = this.services[this.currentServiceIndex]\n    if (cs === undefined) {\n      throw new Error('No AI services provided.')\n    }\n    this.currentService = cs\n  }\n\n  getName(): string {\n    return this.currentService.getName()\n  }\n\n  getModelInfo(): Readonly<AxModelInfoWithProvider> {\n    return this.currentService.getModelInfo()\n  }\n\n  getEmbedModelInfo(): Readonly<AxModelInfoWithProvider> | undefined {\n    return this.currentService.getEmbedModelInfo()\n  }\n\n  getFeatures(model?: string) {\n    return this.currentService.getFeatures(model)\n  }\n\n  getMetrics(): AxAIServiceMetrics {\n    return this.currentService.getMetrics()\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest>,\n    options?: Readonly<AxAIPromptConfig & AxAIServiceActionOptions> | undefined\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    this.reset()\n\n    while (true) {\n      try {\n        return await this.currentService.chat(req, options)\n      } catch (e) {\n        if (!this.getNextService()) {\n          throw e\n        }\n      }\n    }\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest>,\n    options?: Readonly<AxAIServiceActionOptions> | undefined\n  ): Promise<AxEmbedResponse> {\n    this.reset()\n\n    while (true) {\n      try {\n        return await this.currentService.embed(req, options)\n      } catch (e) {\n        if (!this.getNextService()) {\n          throw e\n        }\n      }\n    }\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.currentService.setOptions(options)\n  }\n}\n","import type { AxAIService } from '../ai/types.js'\n\nimport type {\n  AxFieldValue,\n  AxGenIn,\n  AxGenOut,\n  AxProgram,\n  AxProgramDemos,\n  AxProgramTrace,\n} from './program.js'\nimport { updateProgressBar } from './util.js'\n\nexport type AxExample = Record<string, AxFieldValue>\n\nexport type AxMetricFn = <T extends AxGenOut = AxGenOut>(\n  arg0: Readonly<{ prediction: T; example: AxExample }>\n) => boolean\n\nexport type AxMetricFnArgs = Parameters<AxMetricFn>[0]\n\nexport type AxOptimizerArgs<IN extends AxGenIn, OUT extends AxGenOut> = {\n  ai: AxAIService\n  program: Readonly<AxProgram<IN, OUT>>\n  examples: Readonly<AxExample[]>\n  options?: { maxRounds?: number; maxExamples?: number; maxDemos?: number }\n}\n\nexport class AxBootstrapFewShot<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> {\n  private ai: AxAIService\n  private program: Readonly<AxProgram<IN, OUT>>\n  private examples: Readonly<AxExample[]>\n  private maxRounds: number\n  private maxDemos: number\n  private maxExamples: number\n  private traces: AxProgramTrace[] = []\n\n  constructor({\n    ai,\n    program,\n    examples = [],\n    options,\n  }: Readonly<AxOptimizerArgs<IN, OUT>>) {\n    if (examples.length == 0) {\n      throw new Error('No examples found')\n    }\n    this.maxRounds = options?.maxRounds ?? 3\n    this.maxDemos = options?.maxDemos ?? 4\n    this.maxExamples = options?.maxExamples ?? 16\n\n    this.ai = ai\n    this.program = program\n    this.examples = examples\n  }\n\n  private async compileRound(\n    roundIndex: number,\n    metricFn: AxMetricFn,\n    options?: Readonly<AxOptimizerArgs<IN, OUT>['options']>\n  ) {\n    const st = new Date().getTime()\n    const maxDemos = options?.maxDemos ?? this.maxDemos\n    const aiOpt = { modelConfig: { temperature: 0.7 } }\n    const examples = randomSample(this.examples, this.maxExamples)\n\n    for (let i = 0; i < examples.length; i++) {\n      if (i > 0) {\n        aiOpt.modelConfig.temperature = 0.7 + 0.001 * i\n      }\n\n      const ex = examples[i]\n      if (!ex) {\n        throw new Error('Invalid example')\n      }\n      const exList = [...examples.slice(0, i), ...examples.slice(i + 1)]\n      this.program.setExamples(exList)\n\n      const res = await this.program.forward(this.ai, ex as IN, aiOpt)\n      const success = metricFn({ prediction: res, example: ex })\n      if (success) {\n        this.traces = [...this.traces, ...this.program.getTraces()]\n      }\n\n      const current = i + examples.length * roundIndex\n      const total = examples.length * this.maxRounds\n      const et = new Date().getTime() - st\n\n      updateProgressBar(\n        current,\n        total,\n        this.traces.length,\n        et,\n        30,\n        'Tuning Prompt'\n      )\n\n      if (this.traces.length > maxDemos) {\n        return\n      }\n    }\n  }\n\n  public async compile(\n    metricFn: AxMetricFn,\n    options?: Readonly<AxOptimizerArgs<IN, OUT>['options']>\n  ) {\n    const maxRounds = options?.maxRounds ?? this.maxRounds\n    this.traces = []\n\n    for (let i = 0; i < maxRounds; i++) {\n      await this.compileRound(i, metricFn, options)\n    }\n\n    if (this.traces.length === 0) {\n      throw new Error(\n        'No demonstrations found. Either provider more examples or improve the existing ones.'\n      )\n    }\n\n    const demos: AxProgramDemos[] = groupTracesByKeys(this.traces)\n    return demos\n  }\n}\n\nfunction groupTracesByKeys(\n  programTraces: readonly AxProgramTrace[]\n): AxProgramDemos[] {\n  const groupedTraces = new Map<string, Record<string, AxFieldValue>[]>()\n\n  // Group all traces by their keys\n  for (const programTrace of programTraces) {\n    if (groupedTraces.has(programTrace.programId)) {\n      groupedTraces.get(programTrace.programId)!.push(programTrace.trace)\n    } else {\n      groupedTraces.set(programTrace.programId, [programTrace.trace])\n    }\n  }\n\n  // Convert the Map into an array of ProgramDemos\n  const programDemosArray: AxProgramDemos[] = []\n  groupedTraces.forEach((traces, programId) => {\n    programDemosArray.push({ traces, programId })\n  })\n\n  return programDemosArray\n}\n\nconst randomSample = <T>(array: readonly T[], n: number): T[] => {\n  // Clone the array to avoid modifying the original array\n  const clonedArray = [...array]\n  // Shuffle the cloned array\n  for (let i = clonedArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1))\n    const caI = clonedArray[i]\n    const caJ = clonedArray[j]\n\n    if (!caI || !caJ) {\n      throw new Error('Invalid array elements')\n    }\n\n    ;[clonedArray[i], clonedArray[j]] = [caJ, caI]\n  }\n  // Return the first `n` items of the shuffled array\n  return clonedArray.slice(0, n)\n}\n","import { type Span, SpanKind, type Tracer } from '@opentelemetry/api'\n\nimport { axSpanAttributes } from '../trace/trace.js'\n\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBService,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js'\n\nexport interface AxDBBaseArgs {\n  fetch?: typeof fetch\n  tracer?: Tracer\n}\n\nexport interface AxDBBaseOpOptions {\n  span?: Span\n}\n\nexport class AxDBBase implements AxDBService {\n  protected name: string\n  protected fetch?: typeof fetch\n  private tracer?: Tracer\n\n  _upsert?: (\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean,\n    options?: Readonly<AxDBBaseOpOptions>\n  ) => Promise<AxDBUpsertResponse>\n\n  _batchUpsert?: (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    options?: Readonly<AxDBBaseOpOptions>\n  ) => Promise<AxDBUpsertResponse>\n\n  _query?: (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBBaseOpOptions>\n  ) => Promise<AxDBQueryResponse>\n\n  constructor({\n    name,\n    fetch,\n    tracer,\n  }: Readonly<AxDBBaseArgs & { name: string }>) {\n    this.name = name\n    this.fetch = fetch\n    this.tracer = tracer\n  }\n\n  async upsert(\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    if (!this._upsert) {\n      throw new Error('upsert() not implemented')\n    }\n\n    if (!this.tracer) {\n      return await this._upsert(req, update)\n    }\n\n    return await this.tracer?.startActiveSpan(\n      'DB Upsert Request',\n      {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [axSpanAttributes.DB_SYSTEM]: this.name,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'upsert',\n          [axSpanAttributes.DB_TABLE]: req.table,\n          [axSpanAttributes.DB_NAMESPACE]: req.namespace,\n          [axSpanAttributes.DB_OPERATION_NAME]: update ? 'update' : 'insert',\n        },\n      },\n      async (span) => {\n        const res = await this._upsert!(req, update, { span })\n        span.end()\n        return res\n      }\n    )\n  }\n\n  async batchUpsert(\n    req: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    if (!this._batchUpsert) {\n      throw new Error('batchUpsert() not implemented')\n    }\n    if (req.length == 0) {\n      throw new Error('Batch request is empty')\n    }\n    if (!req[0]) {\n      throw new Error('Batch request is invalid first element is undefined')\n    }\n\n    if (!this.tracer) {\n      return await this._batchUpsert(req, update)\n    }\n\n    return await this.tracer?.startActiveSpan(\n      'DB Batch Upsert Request',\n      {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [axSpanAttributes.DB_SYSTEM]: this.name,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'upsert',\n          [axSpanAttributes.DB_TABLE]: req[0].table,\n          [axSpanAttributes.DB_NAMESPACE]: req[0].namespace,\n          [axSpanAttributes.DB_OPERATION_NAME]: update ? 'update' : 'insert',\n        },\n      },\n      async (span) => {\n        const res = await this._batchUpsert!(req, update, { span })\n        span.end()\n        return res\n      }\n    )\n  }\n\n  async query(req: Readonly<AxDBQueryRequest>): Promise<AxDBQueryResponse> {\n    if (!this._query) {\n      throw new Error('query() not implemented')\n    }\n    if (!this.tracer) {\n      return await this._query(req)\n    }\n\n    return await this.tracer?.startActiveSpan(\n      'DB Query Request',\n      {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [axSpanAttributes.DB_SYSTEM]: this.name,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'upsert',\n          [axSpanAttributes.DB_TABLE]: req.table,\n          [axSpanAttributes.DB_NAMESPACE]: req.namespace,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'query',\n        },\n      },\n      async (span) => {\n        const res = await this._query!(req, { span })\n        span.end()\n        return res\n      }\n    )\n  }\n}\n","import { apiCall } from '../util/apicall.js'\n\nimport { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js'\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js'\n\nconst baseURL = 'https://api.cloudflare.com/client/v4/accounts/'\n\nexport type AxDBCloudflareOpOptions = AxDBBaseOpOptions\n\ntype AxCloudflareUpsertResponse = {\n  success: boolean\n  errors?: { message: string }[]\n  result: { ids: string[] }\n}\n\ntype AxCloudflareQueryResponse = {\n  success: boolean\n  errors?: { message: string }[]\n  result: {\n    matches: {\n      id: string\n      score: number\n      values: number[]\n      metadata: object\n    }[]\n  }\n}\n\nexport interface AxDBCloudflareArgs extends AxDBBaseArgs {\n  name: 'cloudflare'\n  apiKey: string\n  accountId: string\n  fetch?: typeof fetch\n}\n\n/**\n * Cloudflare: DB Service\n */\nexport class AxDBCloudflare extends AxDBBase {\n  private apiKey: string\n  private accountId: string\n\n  constructor({\n    apiKey,\n    accountId,\n    fetch,\n    tracer,\n  }: Readonly<Omit<AxDBCloudflareArgs, 'name'>>) {\n    if (!apiKey || !accountId) {\n      throw new Error('Cloudflare credentials not set')\n    }\n    super({ name: 'Cloudflare', fetch, tracer })\n    this.apiKey = apiKey\n    this.accountId = accountId\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    _update?: boolean,\n    options?: Readonly<AxDBCloudflareOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    const res = (await apiCall(\n      {\n        url: new URL(\n          `${this.accountId}/vectorize/indexes/${req.table}/upsert`,\n          baseURL\n        ),\n        headers: {\n          'X-Auth-Key': this.apiKey,\n        },\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        id: req.id,\n        values: req.values,\n        namespace: req.namespace,\n        metadata: req.metadata,\n      }\n    )) as AxCloudflareUpsertResponse\n\n    if (res.errors) {\n      throw new Error(\n        `Cloudflare upsert failed: ${res.errors.map(({ message }) => message).join(', ')}`\n      )\n    }\n\n    return {\n      ids: res.result.ids,\n    }\n  }\n\n  override batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    options?: Readonly<AxDBCloudflareOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (update) {\n      throw new Error('Weaviate does not support batch update')\n    }\n    if (batchReq.length < 1) {\n      throw new Error('Batch request is empty')\n    }\n    if (!batchReq[0] || !batchReq[0].table) {\n      throw new Error('Table name is empty')\n    }\n    const table = batchReq[0].table\n\n    const res = (await apiCall(\n      {\n        url: new URL(\n          `${this.accountId}/vectorize/indexes/${table}/upsert`,\n          baseURL\n        ),\n        headers: {\n          'X-Auth-Key': this.apiKey,\n        },\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      batchReq.map((req) => ({\n        id: req.id,\n        values: req.values,\n        namespace: req.namespace,\n        metadata: req.metadata,\n      }))\n    )) as AxCloudflareUpsertResponse\n\n    if (res.errors) {\n      throw new Error(\n        `Cloudflare batch upsert failed: ${res.errors\n          .map(({ message }) => message)\n          .join(', ')}`\n      )\n    }\n\n    return {\n      ids: res.result.ids,\n    }\n  }\n\n  override query = async (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBCloudflareOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    const res = (await apiCall(\n      {\n        url: new URL(\n          `${this.accountId}/vectorize/indexes/${req.table}/query`,\n          baseURL\n        ),\n        headers: {\n          'X-Auth-Key': this.apiKey,\n        },\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        vector: req.values,\n        topK: req.limit || 10,\n        returnValues: true,\n      }\n    )) as AxCloudflareQueryResponse\n\n    if (res.errors) {\n      throw new Error(\n        `Cloudflare query failed: ${res.errors.map(({ message }) => message).join(', ')}`\n      )\n    }\n\n    const matches = res.result.matches.map(\n      ({ id, score, values, metadata }) => ({\n        id,\n        score,\n        values,\n        metadata,\n      })\n    )\n    return { matches } as AxDBQueryResponse\n  }\n}\n","import { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js'\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js'\n\nexport type AxDBMemoryOpOptions = AxDBBaseOpOptions\n\nexport interface AxDBMemoryArgs extends AxDBBaseArgs {\n  name: 'memory'\n}\n\nexport type AxDBState = Record<string, Record<string, AxDBUpsertRequest>>\n\n/**\n * MemoryDB: DB Service\n */\nexport class AxDBMemory extends AxDBBase {\n  private state: AxDBState\n\n  constructor({ tracer }: Readonly<Omit<AxDBMemoryArgs, 'name'>> = {}) {\n    super({ name: 'Memory', tracer })\n    this.state = {}\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _update?: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxDBMemoryOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (!this.state[req.table]) {\n      this.state[req.table] = {\n        [req.id]: req,\n      }\n    } else {\n      const obj = this.state[req.table]\n      if (!obj) {\n        throw new Error('Table not found: ' + req.table)\n      }\n      obj[req.id] = req\n    }\n\n    return { ids: [req.id] }\n  }\n\n  override _batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxDBMemoryOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    const ids: string[] = []\n    for (const req of batchReq) {\n      const res = await this.upsert(req, update)\n      ids.push(...res.ids)\n    }\n\n    return { ids }\n  }\n\n  override _query = async (\n    req: Readonly<AxDBQueryRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxDBMemoryOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    const table = this.state[req.table]\n    if (!table) {\n      return { matches: [] }\n    }\n\n    const matches: AxDBQueryResponse['matches'] = []\n\n    Object.entries(table).forEach(([id, data]) => {\n      if (req.values && data.values) {\n        const score = distance(req.values, data.values)\n        matches.push({ id: id, score: score, metadata: data.metadata })\n      }\n    })\n\n    matches.sort((a, b) => a.score - b.score)\n    if (req.limit) {\n      matches.length = req.limit\n    }\n\n    return { matches }\n  }\n\n  public getDB = () => {\n    return structuredClone(this.state)\n  }\n\n  public setDB = (state: AxDBState) => {\n    this.state = structuredClone(state)\n  }\n\n  public clearDB = () => {\n    this.state = {}\n  }\n}\n\nconst distance = (a: readonly number[], b: readonly number[]): number => {\n  if (a.length !== b.length) {\n    throw new Error('Vectors must be of the same length.')\n  }\n\n  let dotProduct = 0\n  let normA = 0\n  let normB = 0\n  let zeroVectorA = true\n  let zeroVectorB = true\n\n  const vectorA = new Float64Array(a)\n  const vectorB = new Float64Array(b)\n\n  for (let i = 0; i < vectorA.length; i++) {\n    dotProduct += vectorA[i]! * vectorB[i]!\n    normA += vectorA[i]! * vectorA[i]!\n    normB += vectorB[i]! * vectorB[i]!\n    if (vectorA[i] !== 0) zeroVectorA = false\n    if (vectorB[i] !== 0) zeroVectorB = false\n  }\n\n  if (zeroVectorA || zeroVectorB) {\n    return 1 // Return maximum distance if one vector is zero\n  }\n\n  const sqrtNormA = Math.sqrt(normA)\n  const sqrtNormB = Math.sqrt(normB)\n  const similarity = dotProduct / (sqrtNormA * sqrtNormB)\n  return 1 - similarity // Returning distance as 1 - cosine similarity.\n}\n","import { apiCall } from '../util/apicall.js'\n\nimport { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js'\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js'\n\nexport type AxDBPineconeOpOptions = AxDBBaseOpOptions\n\ntype AxPineconeQueryRequest = {\n  namespace?: string\n  topK: number\n  filter?: Record<string, string>\n  includeValues: boolean\n  includeMetadata: boolean\n  vector: readonly number[]\n  id?: string\n}\n\ntype AxPineconeQueryResponse = {\n  matches: {\n    id: string\n    score: number\n    values: number[]\n    metadata?: Record<string, string>\n  }[]\n}\n\nconst createPineconeQueryRequest = (\n  req: Readonly<AxDBQueryRequest>\n): AxPineconeQueryRequest => {\n  const pineconeQueryRequest: AxPineconeQueryRequest = {\n    namespace: req.namespace,\n    topK: req.limit || 10,\n    filter: {},\n    includeValues: true,\n    includeMetadata: true,\n    vector: req.values ?? [],\n    id: req.id,\n  }\n\n  return pineconeQueryRequest\n}\n\nexport interface AxDBPineconeArgs extends AxDBBaseArgs {\n  name: 'pinecone'\n  apiKey: string\n  host: string\n  fetch?: typeof fetch\n}\n\n/**\n * Pinecone: DB Service\n */\nexport class AxDBPinecone extends AxDBBase {\n  private apiKey: string\n  private apiURL: string\n\n  constructor({\n    apiKey,\n    host,\n    fetch,\n    tracer,\n  }: Readonly<Omit<AxDBPineconeArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Pinecone API key not set')\n    }\n    super({ name: 'Pinecone', fetch, tracer })\n    this.apiKey = apiKey\n    this.apiURL = host\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean,\n    options?: Readonly<AxDBPineconeOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    await this._batchUpsert([req], update, options)\n    return { ids: [req.id] }\n  }\n\n  override _batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    _update?: boolean,\n    options?: Readonly<AxDBPineconeOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (batchReq.length === 0) {\n      throw new Error('Batch request is empty')\n    }\n    await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/vectors/upsert',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      batchReq.map(({ id, values = [], metadata }) => ({\n        id,\n        values,\n        metadata,\n      }))\n    )\n\n    return { ids: batchReq.map(({ id }) => id) }\n  }\n\n  override query = async (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBPineconeOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    if (req.text) {\n      throw new Error('Pinecone does not support text')\n    }\n\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/query',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      createPineconeQueryRequest(req)\n    )) as AxPineconeQueryResponse\n\n    const matches = res.matches.map(({ id, score, values, metadata }) => ({\n      id,\n      score,\n      metadata,\n      values,\n    }))\n\n    return { matches }\n  }\n}\n","import { apiCall } from '../util/apicall.js'\n\nimport { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js'\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js'\n\nexport type AxDBWeaviateOpOptions = AxDBBaseOpOptions\n\ntype AxWeaviateUpsertResponse = {\n  id: string\n  result?: { errors?: { error: { message: string }[] } }\n}\n\ntype AxWeaviateQueryResponse = {\n  errors?: { location: string; message: string; path: string }[]\n  data: {\n    Get: {\n      [key: string]: {\n        [key: string]: unknown\n      }[]\n    }\n  }\n}\n\nexport interface AxDBWeaviateArgs extends AxDBBaseArgs {\n  name: 'weaviate'\n  apiKey: string\n  host: string\n  fetch?: typeof fetch\n}\n\n/**\n * Weaviate: DB Service\n */\nexport class AxDBWeaviate extends AxDBBase {\n  private apiKey: string\n  private apiURL: string\n\n  constructor({\n    apiKey,\n    host,\n    fetch,\n    tracer,\n  }: Readonly<Omit<AxDBWeaviateArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Weaviate API key not set')\n    }\n    super({ name: 'Weaviate', fetch, tracer })\n    this.apiKey = apiKey\n    this.apiURL = host\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean,\n    options?: Readonly<AxDBWeaviateOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: `/v1/objects/${req.table}/${req.id}`,\n        put: update ? true : false,\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        id: req.id,\n        class: req.table,\n        tenant: req.namespace,\n        vector: req.values,\n        properties: req.metadata ?? {},\n      }\n    )) as AxWeaviateUpsertResponse\n\n    if (res?.result?.errors) {\n      throw new Error(\n        `Weaviate upsert failed: ${res.result.errors.error\n          .map(({ message }) => message)\n          .join(', ')}`\n      )\n    }\n\n    return {\n      ids: [res.id],\n    }\n  }\n\n  override _batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    options?: Readonly<AxDBWeaviateOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (update) {\n      throw new Error('Weaviate does not support batch update')\n    }\n    if (batchReq.length === 0) {\n      throw new Error('Batch request is empty')\n    }\n    const objects = batchReq.map((req) => ({\n      id: req.id,\n      class: req.table,\n      tenant: req.namespace,\n      vector: req.values,\n      properties: req.metadata ?? {},\n    }))\n\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/v1/batch/objects',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      { objects }\n    )) as AxWeaviateUpsertResponse[]\n\n    if (res?.some(({ result }) => result?.errors)) {\n      throw new Error(\n        `Weaviate batch upsert failed: ${res\n          .map(({ result }) =>\n            result?.errors?.error.map(({ message }) => message).join(', ')\n          )\n          .join(', ')}`\n      )\n    }\n\n    return {\n      ids: res.map(({ id }) => id),\n    }\n  }\n\n  override _query = async (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBWeaviateOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    let filter = ''\n\n    if (req.columns && req.columns.length === 0) {\n      throw new Error('Weaviate requires at least one column')\n    }\n\n    if (req.values) {\n      filter = `nearVector: {\n            vector: [${req.values.join(',')}],\n        }`\n    } else if (req.text) {\n      filter = `nearText: {\n            concepts: ['${req.text}'],\n        }`\n    } else {\n      throw new Error('Weaviate requires either text or values')\n    }\n\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/v1/graphql',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        query: `{\n          Get {\n            ${req.table} (\n              limit: ${req.limit || 10},\n              ${filter}\n            ) {\n                ${req.columns?.join('\\n')}\n            }\n          }\n        }`,\n      }\n    )) as AxWeaviateQueryResponse\n\n    if (res.errors) {\n      throw new Error(\n        `Weaviate query failed: ${res.errors\n          .map(({ message }) => message)\n          .join(', ')}`\n      )\n    }\n\n    const resMatches = res.data.Get[req.table]\n\n    if (!resMatches) {\n      return { matches: [] }\n    }\n\n    const matches = resMatches.map((match) => {\n      return {\n        id: match['id'] as string,\n        score: 1,\n        metadata: match,\n      }\n    })\n    return { matches } as AxDBQueryResponse\n  }\n}\n","import { AxDBCloudflare, type AxDBCloudflareArgs } from './cloudflare.js'\nimport { AxDBMemory, type AxDBMemoryArgs } from './memory.js'\nimport { AxDBPinecone, type AxDBPineconeArgs } from './pinecone.js'\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBService,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js'\nimport { AxDBWeaviate, type AxDBWeaviateArgs } from './weaviate.js'\n\nexport type AxDBArgs =\n  | AxDBCloudflareArgs\n  | AxDBPineconeArgs\n  | AxDBWeaviateArgs\n  | AxDBMemoryArgs\n\nexport class AxDB implements AxDBService {\n  private db: AxDBService\n  constructor(args: Readonly<AxDBArgs>) {\n    switch (args.name) {\n      case 'weaviate':\n        this.db = new AxDBWeaviate(args)\n        break\n      case 'pinecone':\n        this.db = new AxDBPinecone(args)\n        break\n      case 'cloudflare':\n        this.db = new AxDBCloudflare(args)\n        break\n      case 'memory':\n        this.db = new AxDBMemory(args)\n        break\n      default:\n        throw new Error(`Unknown DB`)\n    }\n  }\n  async upsert(\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    return await this.db.upsert(req, update)\n  }\n\n  async batchUpsert(\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    return await this.db.batchUpsert(batchReq, update)\n  }\n\n  async query(req: Readonly<AxDBQueryRequest>): Promise<AxDBQueryResponse> {\n    return await this.db.query(req)\n  }\n}\n","import {\n  type AxAIService,\n  type AxDBQueryResponse,\n  type AxDBService,\n  type AxProgram,\n} from '../index.js'\n\nexport type AxRewriteIn = { query: string }\nexport type AxRewriteOut = { rewrittenQuery: string }\n\nexport type AxRerankerIn = { query: string; items: string[] }\nexport type AxRerankerOut = { rankedItems: string[] }\n\nexport interface AxDBLoaderOptions {\n  chunker?: (text: string) => string[]\n  rewriter?: AxProgram<AxRewriteIn, AxRewriteOut>\n  reranker?: AxProgram<AxRerankerIn, AxRerankerOut>\n}\n\nexport interface AxDBManagerArgs {\n  ai: AxAIService\n  db: AxDBService\n  config?: AxDBLoaderOptions\n}\n\nexport interface AxDBMatch {\n  score: number\n  text: string\n}\n\nconst table = '_internal'\n\nexport class AxDBManager {\n  private ai: AxAIService\n  private db: AxDBService\n  private chunker: (text: string) => string[]\n  private rewriter?: AxProgram<AxRewriteIn, AxRewriteOut>\n  private reranker?: AxProgram<AxRerankerIn, AxRerankerOut>\n\n  constructor({ ai, db, config }: Readonly<AxDBManagerArgs>) {\n    this.ai = ai\n    this.db = db\n    this.chunker = config?.chunker ?? this.defaultChunker\n    this.reranker = config?.reranker\n    this.rewriter = config?.rewriter\n  }\n\n  private defaultChunker = (text: string): string[] => {\n    // Default chunking by paragraphs\n    return text.split(/\\n\\n+/)\n  }\n\n  insert = async (\n    text: Readonly<string | string[]>,\n    options?: Readonly<{\n      batchSize?: number\n      maxWordsPerChunk?: number\n      minWordsPerChunk?: number\n    }>\n  ): Promise<void> => {\n    try {\n      const chunkerInput = Array.isArray(text)\n        ? text.join('\\n\\n')\n        : (text as string)\n\n      // Chunk the text using the specified or default chunking function\n      const initialChunks = this.chunker(chunkerInput).filter(\n        (chunk) => chunk.length > 0\n      )\n\n      const maxWordsPerChunk = options?.maxWordsPerChunk\n      const minWordsPerChunk = options?.minWordsPerChunk\n\n      const chunks = processChunks({\n        initialChunks,\n        minWordsPerChunk,\n        maxWordsPerChunk,\n      })\n\n      const bs = options?.batchSize ?? 10\n\n      // Process chunks in batches of 10\n      for (let i = 0; i < chunks.length; i += bs) {\n        const batch = chunks.slice(i, i + bs)\n\n        // Get embeddings for the whole batch from the AI service in one call\n        const ret = await this.ai.embed({ texts: batch })\n\n        // Prepare batch for bulk upsert\n        const embeddings = ret.embeddings\n          .map((embedding, index) => ({\n            id: `chunk_${Date.now() + index}`, // Unique ID for each chunk, adjusted by index\n            table,\n            values: embedding,\n            metadata: { text: batch[index] ?? '' },\n          }))\n          .filter(\n            (v) => v.metadata?.['text'] && v.metadata?.['text'].length > 0\n          )\n\n        // Batch upsert embeddings\n        await this.db.batchUpsert(embeddings)\n      }\n    } catch (error) {\n      throw new Error(`Error processing text: ${error}`)\n    }\n  }\n\n  query = async (\n    query: Readonly<string | string[] | number | number[]>,\n    { topPercent }: Readonly<{ topPercent?: number }> | undefined = {}\n  ): Promise<AxDBMatch[][]> => {\n    const texts = Array.isArray(query) ? query : [query]\n\n    if (typeof texts[0] === 'string' && this.rewriter) {\n      for (const [i, text] of texts.entries()) {\n        const { rewrittenQuery } = await this.rewriter.forward(this.ai, {\n          query: text,\n        })\n        texts[i] = rewrittenQuery\n      }\n    }\n\n    let queries: Promise<AxDBQueryResponse>[]\n\n    if (typeof texts[0] === 'string') {\n      const embedResults = await this.ai.embed({ texts })\n      queries = embedResults.embeddings.map((values) =>\n        this.db.query({ table, values })\n      )\n    } else {\n      queries = texts.map((values) => this.db.query({ table, values }))\n    }\n\n    const queryResults = await Promise.all(queries)\n    const res: AxDBMatch[][] = []\n\n    for (const { matches } of queryResults) {\n      const m = matches\n        .filter((v) => v.metadata?.['text'] && v.metadata?.['text'].length > 0)\n        .map(({ score, metadata }) => ({\n          score,\n          text: metadata?.['text'] ?? '',\n        }))\n\n      const tp = topPercent && topPercent > 1 ? topPercent / 100 : topPercent\n      const resultItems = tp ? getTopInPercent(m, tp) : m\n\n      if (this.reranker) {\n        const { rankedItems } = await this.reranker.forward(this.ai, {\n          query: texts[0] as string,\n          items: resultItems.map((item) => item.text),\n        })\n\n        const items = rankedItems\n          .map((item) => resultItems.find((r) => r.text === item))\n          .filter((v) => v !== undefined) as AxDBMatch[]\n\n        res.push(items)\n      } else {\n        res.push(resultItems)\n      }\n    }\n\n    return res\n  }\n}\n\nconst processChunks = ({\n  initialChunks,\n  maxWordsPerChunk = 350,\n  minWordsPerChunk = 250,\n}: Readonly<{\n  initialChunks: readonly string[]\n  maxWordsPerChunk?: number\n  minWordsPerChunk?: number\n}>): string[] => {\n  const chunks: string[] = []\n\n  let currentChunk = ''\n  let currentWordCount = 0\n\n  initialChunks.forEach((chunk) => {\n    const words = chunk.split(/\\s+/) // Split the chunk into words\n    const wordCount = words.length // Count words in the current chunk\n\n    if (currentWordCount + wordCount <= maxWordsPerChunk) {\n      // Add to the current chunk if within the max size limit\n      currentChunk += chunk + '\\n\\n'\n      currentWordCount += wordCount\n    } else if (\n      currentWordCount > 0 &&\n      currentWordCount + wordCount <= maxWordsPerChunk * 1.5\n    ) {\n      // If the total word count exceeds the limit but is less than 150% of the maxWordsPerChunk\n      currentChunk += chunk + '\\n\\n'\n      currentWordCount += wordCount\n    } else {\n      // If the current chunk is not empty and adding the new chunk exceeds the adjusted limit\n      if (currentWordCount > minWordsPerChunk) {\n        chunks.push(currentChunk.trim())\n        currentChunk = ''\n        currentWordCount = 0\n      }\n      // Handle the case where the chunk itself is larger than the limit\n      if (wordCount > maxWordsPerChunk) {\n        const remainingWords = words\n        while (remainingWords.length > maxWordsPerChunk * 1.5) {\n          const slice = remainingWords.splice(0, maxWordsPerChunk)\n          chunks.push(slice.join(' '))\n        }\n        // Add the last portion if it fits the condition of being within 150% of maxWordsPerChunk\n        if (remainingWords.length > 0) {\n          currentChunk += remainingWords.join(' ') + '\\n\\n'\n          currentWordCount += remainingWords.length\n        }\n      } else {\n        // If the new chunk is smaller than the maximum words per chunk\n        currentChunk = chunk + '\\n\\n'\n        currentWordCount = wordCount\n      }\n    }\n  })\n\n  // Push the last chunk if it exists and meets the minimum words condition\n  if (currentWordCount > minWordsPerChunk || chunks.length === 0) {\n    chunks.push(currentChunk.trim())\n  }\n  return chunks\n}\n\nconst getTopInPercent = (\n  entries: readonly AxDBMatch[],\n  percent: number = 0.1\n): AxDBMatch[] => {\n  // Sort entries by score in ascending order\n  const sortedEntries = [...entries].sort((a, b) => a.score - b.score)\n\n  // Calculate the number of entries to take (top 10%)\n  const topTenPercentCount = Math.ceil(sortedEntries.length * percent)\n\n  // Return the top 10% of entries\n  return sortedEntries.slice(0, topTenPercentCount)\n}\n","import type { AxFunction } from '../ai/types.js'\n\nexport interface AxDockerContainer {\n  Id: string\n  Names: string[]\n  Image: string\n  ImageID: string\n  Command: string\n  Created: number\n  State: {\n    Status: string\n    Running: boolean\n    Paused: boolean\n    Restarting: boolean\n    OOMKilled: boolean\n    Dead: boolean\n    Pid: number\n    ExitCode: number\n    Error: string\n    StartedAt: Date\n    FinishedAt: Date\n  }\n  Status: string\n  Ports: Array<{\n    IP: string\n    PrivatePort: number\n    PublicPort: number\n    Type: string\n  }>\n  Labels: { [key: string]: string }\n  SizeRw: number\n  SizeRootFs: number\n  HostConfig: {\n    NetworkMode: string\n  }\n  NetworkSettings: {\n    Networks: {\n      [key: string]: {\n        IPAddress: string\n        IPPrefixLen: number\n        Gateway: string\n        MacAddress: string\n      }\n    }\n  }\n  Mounts: Array<{\n    Type: string\n    Source: string\n    Destination: string\n    Mode: string\n    RW: boolean\n    Propagation: string\n  }>\n}\n\nexport class AxDockerSession {\n  private readonly apiUrl: string\n  private containerId: string | null = null\n\n  constructor(apiUrl: string = 'http://localhost:2375') {\n    this.apiUrl = apiUrl\n  }\n\n  async pullImage(imageName: string): Promise<void> {\n    const response = await this.fetchDockerAPI(\n      `/images/create?fromImage=${encodeURIComponent(imageName)}`,\n      {\n        method: 'POST',\n      }\n    )\n\n    if (!response.ok) {\n      throw new Error(`Failed to pull image: ${response.statusText}`)\n    }\n\n    // Wait for the pull to complete\n    await response.text()\n  }\n\n  async createContainer({\n    imageName,\n    volumes = [],\n    doNotPullImage,\n    tag,\n  }: Readonly<{\n    imageName: string\n    volumes?: Array<{ hostPath: string; containerPath: string }>\n    doNotPullImage?: boolean\n    tag?: string\n  }>) {\n    const binds = volumes.map((v) => `${v.hostPath}:${v.containerPath}`)\n\n    if (!doNotPullImage) {\n      await this.pullImage(imageName)\n    }\n\n    const containerConfig = {\n      Image: imageName,\n      Tty: true,\n      OpenStdin: false,\n      AttachStdin: false,\n      AttachStdout: false,\n      AttachStderr: false,\n      HostConfig: { Binds: binds },\n      Labels: {} as Record<string, string>,\n    }\n\n    if (tag) {\n      containerConfig.Labels['com.example.tag'] = tag\n    }\n\n    const response = await this.fetchDockerAPI(`/containers/create`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(containerConfig),\n    })\n\n    if (!response.ok) {\n      throw new Error(`Failed to create container: ${response.statusText}`)\n    }\n\n    const data = (await response.json()) as { Id: string }\n    this.containerId = data.Id\n\n    return data\n  }\n\n  async findOrCreateContainer({\n    imageName,\n    volumes = [],\n    doNotPullImage,\n    tag,\n  }: Readonly<{\n    imageName: string\n    volumes?: Array<{ hostPath: string; containerPath: string }>\n    doNotPullImage?: boolean\n    tag: string\n  }>): Promise<{ Id: string; isNew: boolean }> {\n    // First, try to find existing containers with the given tag\n    const existingContainers = await this.listContainers(true)\n    const matchingContainers = existingContainers.filter(\n      (container) =>\n        container.Labels && container.Labels['com.example.tag'] === tag\n    )\n\n    if (matchingContainers && matchingContainers.length > 0) {\n      // Randomly select a container from the matching ones\n      const randomIndex = Math.floor(Math.random() * matchingContainers.length)\n      const selectedContainer = matchingContainers[randomIndex]\n\n      if (selectedContainer) {\n        // Connect to the selected container\n        await this.connectToContainer(selectedContainer.Id)\n        return { Id: selectedContainer.Id, isNew: false }\n      }\n    }\n\n    // If no container with the tag exists, create a new one\n    const newContainer = await this.createContainer({\n      imageName,\n      volumes,\n      doNotPullImage,\n      tag,\n    })\n\n    return { Id: newContainer.Id, isNew: true }\n  }\n\n  async startContainer(): Promise<void> {\n    if (!this.containerId) {\n      throw new Error('No container created or connected')\n    }\n\n    const response = await this.fetchDockerAPI(\n      `/containers/${this.containerId}/start`,\n      {\n        method: 'POST',\n      }\n    )\n\n    if (!response.ok) {\n      throw new Error(`Failed to start container: ${response.statusText}`)\n    }\n  }\n\n  async connectToContainer(containerId: string): Promise<void> {\n    const response = await this.fetchDockerAPI(\n      `/containers/${containerId}/json`\n    )\n\n    if (!response.ok) {\n      throw new Error(`Failed to connect to container: ${response.statusText}`)\n    }\n\n    this.containerId = containerId\n  }\n\n  async stopContainers({\n    tag,\n    remove,\n    timeout = 10,\n  }: Readonly<{ tag?: string; remove?: boolean; timeout?: number }>): Promise<\n    Array<{ Id: string; Action: 'stopped' | 'removed' }>\n  > {\n    const results: Array<{ Id: string; Action: 'stopped' | 'removed' }> = []\n\n    // List all containers\n    const containers = await this.listContainers(true)\n\n    // Filter containers by tag if provided\n    const targetContainers = tag\n      ? containers.filter(\n          (container) => container.Labels['com.example.tag'] === tag\n        )\n      : containers\n\n    for (const container of targetContainers) {\n      // Stop the container if it's running\n      if (container.State.Status === 'running') {\n        const stopResponse = await this.fetchDockerAPI(\n          `/containers/${container.Id}/stop?t=${timeout}`,\n          { method: 'POST' }\n        )\n\n        if (!stopResponse.ok) {\n          console.warn(\n            `Failed to stop container ${container.Id}: ${stopResponse.statusText}`\n          )\n          continue\n        }\n\n        results.push({ Id: container.Id, Action: 'stopped' })\n      }\n\n      // Remove the container if the remove flag is set\n      if (remove) {\n        const removeResponse = await this.fetchDockerAPI(\n          `/containers/${container.Id}`,\n          { method: 'DELETE' }\n        )\n\n        if (!removeResponse.ok) {\n          console.warn(\n            `Failed to remove container ${container.Id}: ${removeResponse.statusText}`\n          )\n          continue\n        }\n\n        results.push({ Id: container.Id, Action: 'removed' })\n      }\n    }\n\n    return results\n  }\n\n  async listContainers(all: boolean = false): Promise<AxDockerContainer[]> {\n    const response = await this.fetchDockerAPI(`/containers/json?all=${all}`, {\n      method: 'GET',\n    })\n    return response.json() as Promise<AxDockerContainer[]>\n  }\n\n  async getContainerLogs(): Promise<string> {\n    if (!this.containerId) {\n      throw new Error('No container created or connected')\n    }\n    const response = await this.fetchDockerAPI(\n      `/containers/${this.containerId}/logs?stdout=true&stderr=true`,\n      { method: 'GET' }\n    )\n    return response.text()\n  }\n\n  async executeCommand(command: string) {\n    console.log('Executing command:', command)\n\n    if (!this.containerId) {\n      throw new Error('No container created or connected')\n    }\n\n    // Check container state\n    const containerInfo = await this.getContainerInfo(this.containerId)\n\n    if (containerInfo.State.Status !== 'running') {\n      await this.startContainer()\n\n      // Wait for the container to be in the \"running\" state\n      await this.waitForContainerToBeRunning(this.containerId)\n    }\n\n    // Create exec instance\n    const createResponse = await this.fetchDockerAPI(\n      `/containers/${this.containerId}/exec`,\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          Cmd: ['sh', '-c', command],\n          AttachStdout: true,\n          AttachStderr: true,\n        }),\n      }\n    )\n\n    if (!createResponse.ok) {\n      throw new Error(\n        `Failed to create exec instance: ${createResponse.statusText}`\n      )\n    }\n\n    const execData = (await createResponse.json()) as { Id: string }\n\n    // Start exec instance\n    const startResponse = await this.fetchDockerAPI(\n      `/exec/${execData.Id}/start`,\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          Detach: false,\n          Tty: false,\n        }),\n      }\n    )\n\n    if (!startResponse.ok) {\n      throw new Error(\n        `Failed to start exec instance: ${startResponse.statusText}`\n      )\n    }\n\n    // Return the output\n    return await startResponse.text()\n  }\n\n  // Add these new methods to the class:\n\n  private async getContainerInfo(\n    containerId: string\n  ): Promise<AxDockerContainer> {\n    const response = await this.fetchDockerAPI(\n      `/containers/${containerId}/json`\n    )\n    if (!response.ok) {\n      throw new Error(`Failed to get container info: ${response.statusText}`)\n    }\n    return response.json() as Promise<AxDockerContainer>\n  }\n\n  private async waitForContainerToBeRunning(\n    containerId: string,\n    timeout: number = 30000\n  ): Promise<void> {\n    const startTime = Date.now()\n    while (Date.now() - startTime < timeout) {\n      const containerInfo = await this.getContainerInfo(containerId)\n      if (containerInfo.State.Status === 'running') {\n        return\n      }\n      await new Promise((resolve) => setTimeout(resolve, 1000)) // Wait for 1 second before checking again\n    }\n    throw new Error('Timeout waiting for container to start')\n  }\n\n  private async fetchDockerAPI(\n    endpoint: string,\n    options?: Readonly<RequestInit>\n  ): Promise<Response> {\n    const url = new URL(endpoint, this.apiUrl).toString()\n    return await fetch(url, options)\n  }\n\n  public toFunction(): AxFunction {\n    return {\n      name: 'commandExecution',\n      description:\n        'Use this function to execute shell commands, scripts, and programs. This function enables interaction with the file system, running system utilities, and performing tasks that require a shell interface.',\n      parameters: {\n        type: 'object',\n        properties: {\n          command: {\n            type: 'string',\n            description:\n              'Shell command to execute. eg. `ls -l` or `echo \"Hello, World!\"`.',\n          },\n        },\n        required: ['command'],\n      },\n\n      func: async ({ command }: Readonly<{ command: string }>) =>\n        await this.executeCommand(command),\n    }\n  }\n}\n","import type { AxFieldValue } from './program.js'\n\nexport type AxDataRow = { row: Record<string, AxFieldValue> }\n\nexport class AxHFDataLoader {\n  private rows: AxDataRow[] = []\n  private baseUrl: string\n\n  private dataset: string\n  private split: string\n  private config: string\n  private options?: Readonly<{ offset?: number; length?: number }>\n\n  constructor({\n    dataset,\n    split,\n    config,\n    options,\n  }: Readonly<{\n    dataset: string\n    split: string\n    config: string\n    options?: Readonly<{ offset?: number; length?: number }>\n  }>) {\n    this.baseUrl = 'https://datasets-server.huggingface.co/rows'\n    this.dataset = dataset\n    this.split = split\n    this.config = config\n    this.options = options\n  }\n\n  private async fetchDataFromAPI(url: string): Promise<AxDataRow[]> {\n    try {\n      const response = await fetch(url)\n      if (!response.ok) {\n        throw new Error(`Error fetching data: ${response.statusText}`)\n      }\n      const data = (await response.json()) as { rows: AxDataRow[] }\n      if (!data?.rows) {\n        throw new Error('Invalid data format')\n      }\n      return data.rows\n    } catch (error) {\n      console.error('Error fetching data from API:', error)\n      throw error\n    }\n  }\n\n  // https://datasets-server.huggingface.co/rows?dataset=hotpot_qa&config=distractor&split=train&offset=0&length=100\n\n  public async loadData() {\n    const offset = this.options?.offset ?? 0\n    const length = this.options?.length ?? 100\n    const ds = encodeURIComponent(this.dataset)\n\n    const url = `${this.baseUrl}?dataset=${ds}&config=${this.config}&split=${this.split}&offset=${offset}&length=${length}`\n\n    console.log('Downloading data from API.')\n    this.rows = (await this.fetchDataFromAPI(url)) as AxDataRow[]\n    return this.rows\n  }\n\n  public setData(rows: AxDataRow[]) {\n    this.rows = rows\n  }\n\n  public getData() {\n    return this.rows\n  }\n\n  public async getRows<T>({\n    count,\n    fields,\n    renameMap,\n  }: Readonly<{\n    count: number\n    fields: readonly string[]\n    renameMap?: Record<string, string>\n  }>): Promise<T[]> {\n    if (this.rows.length === 0) {\n      throw new Error('No data loaded, call loadData or setData first.')\n    }\n    const dataRows = this.rows.slice(0, count)\n\n    return dataRows\n      .map((item) => {\n        const result: Record<string, AxFieldValue> = {}\n\n        fields.forEach((field) => {\n          const keys = field.split('.')\n          // Initial value should match the type of the rows, and be indexable by string\n          let value: AxFieldValue | unknown = item.row\n          for (const key of keys) {\n            // Use type assertion to tell TypeScript that value will always be an object that can be indexed with string keys\n            if (\n              Object.prototype.hasOwnProperty.call(\n                value as Record<string, unknown>,\n                key\n              )\n            ) {\n              value = (value as Record<string, unknown>)[key]\n            }\n          }\n          if (!value) {\n            return\n          }\n          const resultFieldName =\n            renameMap && field in renameMap ? renameMap[field] : field\n          if (!resultFieldName) {\n            throw new Error(`Invalid field name: ${field}`)\n          }\n          result[resultFieldName] = value as AxFieldValue\n        })\n\n        return result\n      })\n      .filter((v) => Object.keys(v).length !== 0) as T[]\n  }\n}\n","import * as _crypto from 'crypto'\nimport * as _http from 'http'\nimport * as _https from 'https'\nimport * as _fs from 'node:fs'\nimport * as _os from 'os'\nimport * as _process from 'process'\nimport { runInNewContext } from 'vm'\n\nimport type { AxFunction } from '../ai/types.js'\n\nexport enum AxJSInterpreterPermission {\n  FS = 'node:fs',\n  NET = 'net',\n  OS = 'os',\n  CRYPTO = 'crypto',\n  PROCESS = 'process',\n}\n\ntype Context = {\n  console: Console\n  fs: unknown\n  http: unknown\n  https: unknown\n  os: unknown\n  crypto: unknown\n  process: unknown\n}\n\nexport class AxJSInterpreter {\n  private permissions: readonly AxJSInterpreterPermission[]\n\n  constructor({\n    permissions = [],\n  }:\n    | Readonly<{ permissions?: readonly AxJSInterpreterPermission[] }>\n    | undefined = {}) {\n    this.permissions = permissions ?? []\n  }\n\n  private codeInterpreterJavascript(code: string): unknown {\n    const context: Partial<Context> = { console }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.FS)) {\n      context.fs = _fs\n    }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.NET)) {\n      context.http = _http\n      context.https = _https\n    }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.OS)) {\n      context.os = _os\n    }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.CRYPTO)) {\n      context.crypto = _crypto\n    }\n\n    if (this.permissions.includes(AxJSInterpreterPermission.PROCESS)) {\n      context.process = _process\n    }\n\n    return runInNewContext(`(function() { ${code} })()`, context)\n  }\n\n  public toFunction(): AxFunction {\n    return {\n      name: 'javascriptInterpreter',\n      description:\n        'Use this function to run Javascript code and get any expected return value',\n      parameters: {\n        type: 'object',\n        properties: {\n          code: {\n            type: 'string',\n            description: 'JS code with a return value in the end.',\n          },\n        },\n        required: ['code'],\n      },\n\n      func: ({ code }: Readonly<{ code: string }>) =>\n        this.codeInterpreterJavascript(code),\n    }\n  }\n}\n","import type { AxAIService } from '../ai/types.js'\nimport { AxDBMemory, type AxDBState } from '../db/memory.js'\nimport { ColorLog } from '../util/log.js'\n\nconst colorLog = new ColorLog()\n\nexport interface AxRouterForwardOptions {\n  cutoff?: number\n}\n\nexport class AxRoute {\n  private readonly name: string\n  private readonly context: readonly string[]\n\n  constructor(name: string, context: readonly string[]) {\n    this.name = name\n    this.context = context\n  }\n\n  public getName(): string {\n    return this.name\n  }\n\n  public getContext(): readonly string[] {\n    return this.context\n  }\n}\n\nexport class AxRouter {\n  private readonly ai: AxAIService\n\n  private db: AxDBMemory\n  private debug?: boolean\n\n  public constructor(ai: AxAIService) {\n    this.db = new AxDBMemory()\n    this.ai = ai\n  }\n\n  public getState(): AxDBState | undefined {\n    return this.db.getDB()\n  }\n\n  public setState(state: AxDBState) {\n    this.db.setDB(state)\n  }\n\n  public setRoutes = async (routes: readonly AxRoute[]): Promise<void> => {\n    for (const ro of routes) {\n      const ret = await this.ai.embed({ texts: ro.getContext() })\n      await this.db.upsert({\n        id: ro.getName(),\n        table: 'routes',\n        values: ret.embeddings[0],\n      })\n    }\n  }\n\n  public async forward(\n    text: string,\n    options?: Readonly<AxRouterForwardOptions>\n  ): Promise<string> {\n    const { embeddings } = await this.ai.embed({ texts: [text] })\n\n    const matches = await this.db.query({\n      table: 'routes',\n      values: embeddings[0],\n    })\n\n    let m = matches.matches\n    if (typeof options?.cutoff === 'number') {\n      const { cutoff } = options\n      m = m.filter((m) => m.score <= cutoff)\n    }\n\n    if (this.debug) {\n      console.log(\n        colorLog.whiteBright(`query: ${text}`) +\n          '\\n' +\n          colorLog.greenBright(\n            JSON.stringify(m.map((m) => `${m.id}, ${m.score}`))\n          )\n      )\n    }\n\n    const route = m.at(0)\n    if (!route) {\n      return ''\n    }\n\n    return route.id\n  }\n\n  public setOptions(options: Readonly<{ debug?: boolean }>): void {\n    if (typeof options.debug === 'boolean') {\n      this.debug = options.debug\n    }\n  }\n}\n","import type { AxAIService } from '../ai/types.js'\n\nimport type { AxExample, AxMetricFn } from './optimize.js'\nimport type { AxGenIn, AxGenOut, AxProgram } from './program.js'\nimport { updateProgressBar } from './util.js'\n\nexport type AxEvaluateArgs<IN extends AxGenIn, OUT extends AxGenOut> = {\n  ai: AxAIService\n  program: Readonly<AxProgram<IN, OUT>>\n  examples: Readonly<AxExample[]>\n}\n\nexport class AxTestPrompt<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> {\n  private ai: AxAIService\n  private program: Readonly<AxProgram<IN, OUT>>\n  private examples: Readonly<AxExample[]>\n\n  constructor({\n    ai,\n    program,\n    examples = [],\n  }: Readonly<AxEvaluateArgs<IN, OUT>>) {\n    if (examples.length == 0) {\n      throw new Error('No examples found')\n    }\n    this.ai = ai\n    this.program = program\n    this.examples = examples\n  }\n\n  public async run(metricFn: AxMetricFn) {\n    const st = new Date().getTime()\n    const total = this.examples.length\n    let successCount = 0\n\n    for (let i = 0; i < total; i++) {\n      const ex = this.examples[i]\n      if (!ex) {\n        throw new Error('Invalid example')\n      }\n\n      const res = await this.program.forward(this.ai, ex as IN)\n      const success = metricFn({ prediction: res, example: ex })\n      if (success) {\n        successCount++\n      }\n\n      const et = new Date().getTime() - st\n      updateProgressBar(i, total, successCount, et, 30, 'Testing Prompt')\n    }\n\n    console.log(\n      '\\nPerformance: ',\n      successCount,\n      '/',\n      total,\n      'Accuracy: ',\n      successCount / total,\n      '\\n'\n    )\n  }\n}\n","import { AxGen, type AxGenOptions } from '../dsp/generate.js'\nimport type { AxGenIn, AxGenOut } from '../dsp/program.js'\nimport { AxSignature } from '../dsp/sig.js'\n\nexport class AxChainOfThought<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> extends AxGen<IN, OUT & { reason: string }> {\n  constructor(\n    signature: Readonly<AxSignature | string>,\n    options?: Readonly<AxGenOptions>\n  ) {\n    const sig = new AxSignature(signature)\n    const description = `Let's work this out in a step by step way in order to ensure we have the right answer.`\n\n    sig.setOutputFields([\n      {\n        name: 'reason',\n        description,\n      },\n      ...sig.getOutputFields(),\n    ])\n\n    super(sig, options)\n  }\n}\n","import {\n  AxGen,\n  type AxGenOptions,\n  type AxRewriteIn,\n  type AxRewriteOut,\n} from '../index.js'\n\nexport class AxDefaultQueryRewriter extends AxGen<AxRewriteIn, AxRewriteOut> {\n  constructor(options?: Readonly<AxGenOptions>) {\n    const signature = `\"You are a query rewriter assistant tasked with rewriting a given query to improve its clarity, specificity, and relevance. Your role involves analyzing the query to identify any ambiguities, generalizations, or irrelevant information and then rephrasing it to make it more focused and precise. The rewritten query should be concise, easy to understand, and directly related to the original query. Output only the rewritten query.\"\n    query: string -> rewrittenQuery: string`\n\n    super(signature, options)\n  }\n}\n","const trimNonAlphaNum = (str: string) => {\n  return str.replace(/^\\W+|\\W+$/g, '')\n}\n\nconst splitIntoTwo = (\n  str: string,\n  separator: Readonly<RegExp | string>\n): string[] => {\n  const index = str.search(separator)\n  if (index === -1) {\n    return [str] // No separator found, return the original string as the only part\n  }\n  const matchResult = str.match(separator)\n  if (!matchResult) {\n    throw new Error('Match failed unexpectedly.')\n  }\n  const firstPart = str.substring(0, index)\n  const secondPart = str.substring(index + matchResult[0].length)\n  return [firstPart, secondPart]\n}\n\nconst dedup = (seq: readonly string[]): string[] => {\n  const seen = new Set<string>()\n  const result: string[] = []\n\n  for (const x of seq) {\n    if (!seen.has(x)) {\n      seen.add(x)\n      result.push(x)\n    }\n  }\n\n  return result\n}\n\nconst extractIdAndText = (input: string): { id: number; text: string } => {\n  const match = input.match(/^(\\d+)[.,\\s]+(.*)$/)\n  if (!match || match.length < 3) {\n    throw new Error(\n      'line must start with a number, a dot and then text. e.g. \"1. hello\"'\n    )\n  }\n\n  const id = parseInt(match[1] as string, 10)\n  const text = (match[2] as string).trim()\n  return { id, text }\n}\n\nconst extractIndexPrefixedText = (input: string): string => {\n  const match = input.match(/^(\\d+)[.,\\s]+(.*)$/)\n  // Check if match is not null and if the second capturing group is present\n  if (match && match[2] !== undefined) {\n    return match[2].trim()\n  }\n  return input\n}\n\nconst batchArray = <T>(arr: readonly T[], size: number): T[][] => {\n  const chunkedArr: T[][] = []\n  for (let i = 0; i < arr.length; i += size) {\n    chunkedArr.push(arr.slice(i, i + size))\n  }\n  return chunkedArr\n}\n\nexport const axStringUtil = {\n  trimNonAlphaNum,\n  splitIntoTwo,\n  dedup,\n  extractIdAndText,\n  extractIndexPrefixedText,\n  batchArray,\n}\n","import type { AxAIService } from '../ai/types.js'\nimport { AxGen, type AxGenOptions } from '../dsp/generate.js'\nimport type { AxProgramForwardOptions } from '../dsp/program.js'\nimport { axStringUtil } from '../dsp/strutil.js'\n\nimport type { AxRerankerIn, AxRerankerOut } from './manager.js'\n\nexport class AxDefaultResultReranker extends AxGen<\n  AxRerankerIn,\n  AxRerankerOut\n> {\n  constructor(options?: Readonly<AxGenOptions>) {\n    const signature = `\"You are a re-ranker assistant tasked with evaluating a set of content items in relation to a specific question. Your role involves critically analyzing each content item to determine its relevance to the question and re-ranking them accordingly. This process includes assigning a relevance score from 0 to 10 to each content item based on how well it answers the question, its coverage of the topic, and the reliability of its information. This re-ranked list should start with the content item that is most relevant to the question and end with the least relevant. Output only the list.\"\n    query: string, items: string[] -> rankedItems: string[] \"list of id, 5-words Rationale, relevance score\"`\n\n    super(signature, options)\n  }\n\n  public override forward = async (\n    ai: Readonly<AxAIService>,\n    input: Readonly<AxRerankerIn>,\n    options?: Readonly<AxProgramForwardOptions>\n  ): Promise<AxRerankerOut> => {\n    const { rankedItems } = await super.forward(ai, input, options)\n\n    const sortedIndexes: number[] = rankedItems.map((item) => {\n      const { id: index } = axStringUtil.extractIdAndText(item)\n      return index\n    })\n\n    // Ensure all elements are strings and filter out null or undefined\n    const sortedItems = input.items\n      .map((_, index) => {\n        const originalIndex = sortedIndexes[index]\n        return originalIndex !== undefined\n          ? input.items[originalIndex]\n          : undefined\n      })\n      .filter((item): item is string => item !== undefined)\n\n    return { rankedItems: sortedItems }\n  }\n}\n","import type {\n  AxAIService,\n  AxAIServiceActionOptions,\n  AxFunction,\n} from '../ai/types.js'\n\nexport class AxEmbeddingAdapter {\n  private aiService: AxAIService\n  private info: {\n    name: string\n    description: string\n    argumentDescription: string\n  }\n  private func: (\n    args: readonly number[],\n    extra?: Readonly<AxAIServiceActionOptions>\n  ) => Promise<unknown>\n\n  constructor({\n    ai,\n    info,\n    func,\n  }: Readonly<{\n    ai: AxAIService\n    info: Readonly<{\n      name: string\n      description: string\n      argumentDescription: string\n    }>\n    func: (\n      args: readonly number[],\n      extra?: Readonly<AxAIServiceActionOptions>\n    ) => Promise<unknown>\n  }>) {\n    this.aiService = ai\n    this.info = info\n    this.func = func\n  }\n\n  private async embedAdapter(\n    text: string,\n    extra?: Readonly<AxAIServiceActionOptions>\n  ): Promise<unknown> {\n    const embedRes = await this.aiService.embed(\n      { texts: [text] },\n      { sessionId: extra?.sessionId }\n    )\n    const embeds = embedRes.embeddings.at(0)\n\n    if (!embeds) {\n      throw new Error('Failed to embed text')\n    }\n\n    return this.func.length === 2 ? this.func(embeds, extra) : this.func(embeds)\n  }\n\n  public toFunction(): AxFunction {\n    return {\n      name: this.info.name,\n      description: this.info.description,\n      parameters: {\n        type: 'object',\n        properties: {\n          text: {\n            type: 'string',\n            description: this.info.argumentDescription,\n          },\n        },\n        required: ['text'],\n      },\n      func: ({ text }: Readonly<{ text: string }>, options) =>\n        this.embedAdapter(text, options),\n    }\n  }\n}\n","import { type AxProgramForwardOptions } from '../dsp/program.js'\nimport { axStringUtil } from '../dsp/strutil.js'\nimport {\n  type AxAIService,\n  AxGen,\n  type AxGenOptions,\n  AxSignature,\n} from '../index.js'\n\nimport { AxChainOfThought } from './cot.js'\n\nexport class AxRAG extends AxChainOfThought<\n  { context: string[]; question: string },\n  { answer: string }\n> {\n  private genQuery: AxGen<\n    { context: string[]; question: string },\n    { query: string }\n  >\n  private queryFn: (query: string) => Promise<string>\n  private maxHops: number\n\n  constructor(\n    queryFn: (query: string) => Promise<string>,\n    options: Readonly<AxGenOptions & { maxHops?: number }>\n  ) {\n    const sig =\n      '\"Answer questions with short factoid answers.\" context:string[] \"may contain relevant facts\", question -> answer'\n    super(sig, options)\n\n    this.maxHops = options?.maxHops ?? 3\n\n    const qsig = new AxSignature(\n      '\"Write a simple search query that will help answer a complex question.\" context?:string[] \"may contain relevant facts\", question -> query \"question to further our understanding\"'\n    )\n    this.genQuery = new AxGen<\n      { context: string[]; question: string },\n      { query: string }\n    >(qsig)\n    this.queryFn = queryFn\n    this.register(this.genQuery)\n  }\n\n  public override async forward(\n    ai: Readonly<AxAIService>,\n    { question }: Readonly<{ question: string }>,\n    options?: Readonly<AxProgramForwardOptions>\n  ): Promise<{ answer: string; reason: string }> {\n    let context: string[] = []\n\n    for (let i = 0; i < this.maxHops; i++) {\n      const { query } = await this.genQuery.forward(\n        ai,\n        {\n          context,\n          question,\n        },\n        options\n      )\n      const val = await this.queryFn(query)\n      context = axStringUtil.dedup([...context, val])\n    }\n\n    return super.forward(ai, { context, question }, options)\n  }\n}\n"],"mappings":"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","names":["AxLLMRequestTypeValues","AxSpanKindValues","TransformStream","TransformStream","res","items","AxAIAnthropicModel","AxAIOpenAIModel","AxAIOpenAIEmbedModel","createMessages","mapFinishReason","id","AxAICohereModel","AxAICohereEmbedModel","AxAIDeepSeekModel","AxAIGoogleGeminiModel","AxAIGoogleGeminiEmbedModel","AxAIGoogleGeminiSafetyCategory","AxAIGoogleGeminiSafetyThreshold","i","safetySettings","colorLog","AxAIGroqModel","AxAIHuggingFaceModel","fc","AxAIMistralModel","AxAIMistralEmbedModels","AxAIRekaModel","createMessages","mapFinishReason","SpanKind","SpanKind","fc","message","colorLog","value","JSON5","schema","path","JSON5","res","SpanKind","opt","SpanKind","files","SpanKind","fetch","SpanKind","fetch","table","table","fetch","fetch","AxJSInterpreterPermission","colorLog","m"]}
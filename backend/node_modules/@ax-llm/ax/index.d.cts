import { ReadableStream } from 'stream/web';
import { Tracer, Span } from '@opentelemetry/api';

/**
 * Util: API details
 */
type AxAPI = {
    name?: string;
    headers?: Record<string, string>;
    put?: boolean;
};

type AxAIModelMap = Record<string, string>;
type AxModelInfo = {
    name: string;
    currency?: string;
    characterIsToken?: boolean;
    promptTokenCostPer1M?: number;
    completionTokenCostPer1M?: number;
    aliases?: string[];
};
type AxTokenUsage = {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
};
type AxModelConfig = {
    maxTokens?: number;
    temperature?: number;
    topP?: number;
    topK?: number;
    presencePenalty?: number;
    frequencyPenalty?: number;
    stopSequences?: string[];
    endSequences?: string[];
    stream?: boolean;
    n?: number;
};
type AxFunctionHandler = (args?: any, extra?: Readonly<{
    sessionId?: string;
    traceId?: string;
}>) => unknown;
type AxFunctionJSONSchema = {
    type: string;
    properties?: Record<string, AxFunctionJSONSchema & {
        enum?: string[];
        description: string;
    }>;
    required?: string[];
    items?: AxFunctionJSONSchema;
};
type AxFunction = {
    name: string;
    description: string;
    parameters?: AxFunctionJSONSchema;
    func: AxFunctionHandler;
};
type AxChatResponseResult = {
    content?: string;
    name?: string;
    id?: string;
    functionCalls?: {
        id: string;
        type: 'function';
        function: {
            name: string;
            params?: string | object;
        };
    }[];
    finishReason?: 'stop' | 'length' | 'function_call' | 'content_filter' | 'error';
};
type AxChatResponse = {
    sessionId?: string;
    remoteId?: string;
    results: readonly AxChatResponseResult[];
    modelUsage?: AxTokenUsage;
    embedModelUsage?: AxTokenUsage;
};
type AxEmbedResponse = {
    remoteId?: string;
    sessionId?: string;
    embeddings: readonly (readonly number[])[];
    modelUsage?: AxTokenUsage;
};
type AxModelInfoWithProvider = AxModelInfo & {
    provider: string;
};
type AxChatRequest = {
    chatPrompt: Readonly<{
        role: 'system';
        content: string;
        cache?: boolean;
    } | {
        role: 'user';
        name?: string;
        content: string | ({
            type: 'text';
            text: string;
            cache?: boolean;
        } | {
            type: 'image';
            mimeType: string;
            image: string;
            details?: 'high' | 'low' | 'auto';
            cache?: boolean;
        } | {
            type: 'audio';
            data: string;
            format?: 'wav';
            cache?: boolean;
        })[];
    } | {
        role: 'assistant';
        content?: string;
        name?: string;
        functionCalls?: {
            id: string;
            type: 'function';
            function: {
                name: string;
                params?: string | object;
            };
        }[];
        cache?: boolean;
    } | {
        role: 'function';
        result: string;
        functionId: string;
        cache?: boolean;
    }>[];
    functions?: Readonly<{
        name: string;
        description: string;
        parameters?: AxFunctionJSONSchema;
    }>[];
    functionCall?: 'none' | 'auto' | 'required' | {
        type: 'function';
        function: {
            name: string;
        };
    };
    modelConfig?: Readonly<AxModelConfig>;
    model?: string;
};
interface AxAIServiceMetrics {
    latency: {
        chat: {
            mean: number;
            p95: number;
            p99: number;
            samples: number[];
        };
        embed: {
            mean: number;
            p95: number;
            p99: number;
            samples: number[];
        };
    };
    errors: {
        chat: {
            count: number;
            rate: number;
            total: number;
        };
        embed: {
            count: number;
            rate: number;
            total: number;
        };
    };
}
type AxInternalChatRequest = Omit<AxChatRequest, 'model'> & Required<Pick<AxChatRequest, 'model'>>;
type AxEmbedRequest = {
    texts?: readonly string[];
    embedModel?: string;
};
type AxInternalEmbedRequest = Omit<AxEmbedRequest, 'embedModel'> & Required<Pick<AxEmbedRequest, 'embedModel'>>;
type AxRateLimiterFunction = <T = unknown>(reqFunc: () => Promise<T | ReadableStream<T>>, info: Readonly<{
    modelUsage?: AxTokenUsage;
    embedModelUsage?: AxTokenUsage;
}>) => Promise<T | ReadableStream<T>>;
type AxAIPromptConfig = {
    stream?: boolean;
};
type AxAIServiceOptions = {
    debug?: boolean;
    rateLimiter?: AxRateLimiterFunction;
    fetch?: typeof fetch;
    tracer?: Tracer;
};
type AxAIServiceActionOptions = {
    ai?: Readonly<AxAIService>;
    sessionId?: string;
    traceId?: string;
    rateLimiter?: AxRateLimiterFunction;
};
interface AxAIService {
    getName(): string;
    getModelInfo(): Readonly<AxModelInfoWithProvider>;
    getEmbedModelInfo(): Readonly<AxModelInfoWithProvider> | undefined;
    getFeatures(model?: string): {
        functions: boolean;
        streaming: boolean;
    };
    getModelMap(): AxAIModelMap | undefined;
    getMetrics(): AxAIServiceMetrics;
    chat(req: Readonly<AxChatRequest>, options?: Readonly<AxAIPromptConfig & AxAIServiceActionOptions>): Promise<AxChatResponse | ReadableStream<AxChatResponse>>;
    embed(req: Readonly<AxEmbedRequest>, options?: Readonly<AxAIServiceActionOptions & AxAIServiceActionOptions>): Promise<AxEmbedResponse>;
    setOptions(options: Readonly<AxAIServiceOptions>): void;
}
interface AxAIServiceImpl<TChatRequest, TEmbedRequest, TChatResponse, TChatResponseDelta, TEmbedResponse> {
    createChatReq(req: Readonly<AxInternalChatRequest>, config: Readonly<AxAIPromptConfig>): [AxAPI, TChatRequest];
    createChatResp(resp: Readonly<TChatResponse>): AxChatResponse;
    createChatStreamResp?(resp: Readonly<TChatResponseDelta>, state: object): AxChatResponse;
    createEmbedReq?(req: Readonly<AxInternalEmbedRequest>): [AxAPI, TEmbedRequest];
    createEmbedResp?(resp: Readonly<TEmbedResponse>): AxEmbedResponse;
    getModelConfig(): AxModelConfig;
}

interface AxBaseAIFeatures {
    functions: boolean;
    streaming: boolean;
}
interface AxBaseAIArgs {
    name: string;
    apiURL: string;
    headers: Record<string, string>;
    modelInfo: Readonly<AxModelInfo[]>;
    models: Readonly<{
        model: string;
        embedModel?: string;
    }>;
    options?: Readonly<AxAIServiceOptions>;
    supportFor: AxBaseAIFeatures | ((model: string) => AxBaseAIFeatures);
    modelMap?: AxAIModelMap;
}
declare class AxBaseAI<TChatRequest, TEmbedRequest, TChatResponse, TChatResponseDelta, TEmbedResponse> implements AxAIService {
    private readonly aiImpl;
    private debug;
    private rt?;
    private fetch?;
    private tracer?;
    private modelMap?;
    private modelInfo;
    private modelUsage?;
    private embedModelUsage?;
    private models;
    protected apiURL: string;
    protected name: string;
    protected headers: Record<string, string>;
    protected supportFor: AxBaseAIFeatures | ((model: string) => AxBaseAIFeatures);
    private metrics;
    constructor(aiImpl: Readonly<AxAIServiceImpl<TChatRequest, TEmbedRequest, TChatResponse, TChatResponseDelta, TEmbedResponse>>, { name, apiURL, headers, modelInfo, models, options, supportFor, modelMap, }: Readonly<AxBaseAIArgs>);
    setName(name: string): void;
    setAPIURL(apiURL: string): void;
    setHeaders(headers: Record<string, string>): void;
    setOptions(options: Readonly<AxAIServiceOptions>): void;
    getModelInfo(): Readonly<AxModelInfoWithProvider>;
    getEmbedModelInfo(): AxModelInfoWithProvider | undefined;
    getModelMap(): AxAIModelMap | undefined;
    getName(): string;
    getFeatures(model?: string): AxBaseAIFeatures;
    private calculatePercentile;
    private updateLatencyMetrics;
    private updateErrorMetrics;
    getMetrics(): AxAIServiceMetrics;
    chat(req: Readonly<AxChatRequest>, options?: Readonly<AxAIPromptConfig & AxAIServiceActionOptions>): Promise<AxChatResponse | ReadableStream<AxChatResponse>>;
    private _chat1;
    private _chat2;
    embed(req: Readonly<AxEmbedRequest>, options?: Readonly<AxAIServiceActionOptions>): Promise<AxEmbedResponse>;
    private _embed1;
    private _embed2;
    private buildHeaders;
}

declare enum AxAIAnthropicModel {
    Claude35Sonnet = "claude-3-5-sonnet-latest",
    Claude35Haiku = "claude-3-5-haiku-latest",
    Claude3Opus = "claude-3-opus-latest",
    Claude3Sonnet = "claude-3-sonnet-20240229",
    Claude3Haiku = "claude-3-haiku-20240307",
    Claude21 = "claude-2.1",
    ClaudeInstant12 = "claude-instant-1.2"
}
type AxAIAnthropicConfig = AxModelConfig & {
    model: AxAIAnthropicModel;
};
type AxAIAnthropicChatRequestCacheParam = {
    cache_control?: {
        type: 'ephemeral';
    };
};
type AxAIAnthropicChatRequest = {
    model: string;
    messages: ({
        role: 'user';
        content: string | (({
            type: 'text';
            text: string;
        } & AxAIAnthropicChatRequestCacheParam) | ({
            type: 'image';
            source: {
                type: 'base64';
                media_type: string;
                data: string;
            };
        } & AxAIAnthropicChatRequestCacheParam) | {
            type: 'tool_result';
            is_error?: boolean;
            tool_use_id: string;
            content: string | (({
                type: 'text';
                text: string;
            } & AxAIAnthropicChatRequestCacheParam) | ({
                type: 'image';
                source: {
                    type: 'base64';
                    media_type: string;
                    data: string;
                };
            } & AxAIAnthropicChatRequestCacheParam))[];
        })[];
    } | {
        role: 'assistant';
        content: string | ({
            type: 'text';
            text: string;
        } | {
            type: 'tool_use';
            id: string;
            name: string;
            input: object;
        })[];
    })[];
    tools?: ({
        name: string;
        description: string;
        input_schema?: object;
    } & AxAIAnthropicChatRequestCacheParam)[];
    tool_choice?: {
        type: 'auto' | 'any';
    } | {
        type: 'tool';
        name?: string;
    };
    max_tokens?: number;
    stop_sequences?: string[];
    stream?: boolean;
    system?: string | ({
        type: 'text';
        text: string;
    } & AxAIAnthropicChatRequestCacheParam)[];
    temperature?: number;
    top_p?: number;
    top_k?: number;
    metadata?: {
        user_id: string;
    };
};
type AxAIAnthropicChatResponse = {
    id: string;
    type: 'message';
    role: 'assistant';
    content: ({
        type: 'text';
        text: string;
    } | {
        id: string;
        name: string;
        type: 'tool_use';
        input?: string;
    })[];
    model: string;
    stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use';
    stop_sequence?: string;
    usage: {
        input_tokens: number;
        output_tokens: number;
    };
};
type AxAIAnthropicChatError = {
    type: 'error';
    error: {
        type: 'authentication_error';
        message: string;
    };
};
interface AxAIAnthropicMessageStartEvent {
    type: 'message_start';
    message: {
        id: string;
        type: 'message';
        role: 'assistant';
        content: [];
        model: string;
        stop_reason: null | string;
        stop_sequence: null | string;
        usage: {
            input_tokens: number;
            output_tokens: number;
        };
    };
}
interface AxAIAnthropicContentBlockStartEvent {
    index: number;
    type: 'content_block_start';
    content_block: {
        type: 'text';
        text: string;
    } | {
        type: 'tool_use';
        id: string;
        name: string;
        input: object;
    };
}
interface AxAIAnthropicContentBlockDeltaEvent {
    index: number;
    type: 'content_block_delta';
    delta: {
        type: 'text_delta';
        text: string;
    } | {
        type: 'input_json_delta';
        partial_json: string;
    };
}
interface AxAIAnthropicContentBlockStopEvent {
    type: 'content_block_stop';
    index: number;
}
interface AxAIAnthropicMessageDeltaEvent {
    type: 'message_delta';
    delta: {
        stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | null;
        stop_sequence: string | null;
    };
    usage: {
        output_tokens: number;
    };
}
interface AxAIAnthropicMessageStopEvent {
    type: 'message_stop';
}
interface AxAIAnthropicPingEvent {
    type: 'ping';
}
interface AxAIAnthropicErrorEvent {
    type: 'error';
    error: {
        type: 'overloaded_error';
        message: string;
    };
}
type AxAIAnthropicChatResponseDelta = AxAIAnthropicMessageStartEvent | AxAIAnthropicContentBlockStartEvent | AxAIAnthropicContentBlockDeltaEvent | AxAIAnthropicContentBlockStopEvent | AxAIAnthropicMessageDeltaEvent | AxAIAnthropicMessageStopEvent | AxAIAnthropicPingEvent | AxAIAnthropicErrorEvent;

interface AxAIAnthropicArgs {
    name: 'anthropic';
    apiKey: string;
    config?: Readonly<Partial<AxAIAnthropicConfig>>;
    options?: Readonly<AxAIServiceOptions>;
    modelMap?: Record<string, AxAIAnthropicModel | string>;
}
declare class AxAIAnthropic extends AxBaseAI<AxAIAnthropicChatRequest, unknown, AxAIAnthropicChatResponse, AxAIAnthropicChatResponseDelta, unknown> {
    constructor({ apiKey, config, options, modelMap, }: Readonly<Omit<AxAIAnthropicArgs, 'name'>>);
}

declare enum AxAIOpenAIModel {
    O1Preview = "o1-preview",
    O1Mini = "o1-mini",
    GPT4 = "gpt-4",
    GPT4O = "gpt-4o",
    GPT4OMini = "gpt-4o-mini",
    GPT4ChatGPT4O = "chatgpt-4o-latest",
    GPT4Turbo = "gpt-4-turbo",
    GPT35Turbo = "gpt-3.5-turbo",
    GPT35TurboInstruct = "gpt-3.5-turbo-instruct",
    GPT35TextDavinci002 = "text-davinci-002",
    GPT3TextBabbage002 = "text-babbage-002",
    GPT3TextAda001 = "text-ada-001"
}
declare enum AxAIOpenAIEmbedModel {
    TextEmbeddingAda002 = "text-embedding-ada-002",
    TextEmbedding3Small = "text-embedding-3-small",
    TextEmbedding3Large = "text-embedding-3-large"
}
type AxAIOpenAIConfig = Omit<AxModelConfig, 'topK'> & {
    model: AxAIOpenAIModel | string;
    embedModel?: AxAIOpenAIEmbedModel | string;
    user?: string;
    responseFormat?: 'json_object';
    bestOf?: number;
    logitBias?: Map<string, number>;
    suffix?: string | null;
    stop?: string[];
    logprobs?: number;
    echo?: boolean;
    dimensions?: number;
};
type AxAIOpenAILogprob = {
    tokens: string[];
    token_logprobs: number[];
    top_logprobs: Map<string, number>;
    text_offset: number[];
};
type AxAIOpenAIUsage = {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
};
interface AxAIOpenAIResponseDelta<T> {
    id: string;
    object: string;
    created: number;
    model: string;
    choices: {
        index: number;
        delta: T;
        finish_reason: 'stop' | 'length' | 'content_filter' | 'tool_calls';
    }[];
    usage?: AxAIOpenAIUsage;
    system_fingerprint: string;
}
type AxAIOpenAIChatRequest = {
    model: string;
    messages: ({
        role: 'system';
        content: string;
    } | {
        role: 'user';
        content: string | ({
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            image_url: {
                url: string;
                details?: 'high' | 'low' | 'auto';
            };
        } | {
            type: 'input_audio';
            input_audio: {
                data: string;
                format?: 'wav';
            };
        })[];
        name?: string;
    } | {
        role: 'assistant';
        content: string;
        name?: string;
        tool_calls?: {
            type: 'function';
            function: {
                name: string;
                arguments?: string;
            };
        }[];
    } | {
        role: 'tool';
        content: string;
        tool_call_id: string;
    })[];
    tools?: {
        type: 'function';
        function: {
            name: string;
            description: string;
            parameters?: object;
        };
    }[];
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'function';
        function: {
            name: string;
        };
    };
    response_format?: {
        type: string;
    };
    max_tokens: number;
    temperature?: number;
    top_p?: number;
    n?: number;
    stream?: boolean;
    stop?: readonly string[];
    presence_penalty?: number;
    frequency_penalty?: number;
    logit_bias?: Map<string, number>;
    user?: string;
    organization?: string;
};
type AxAIOpenAIChatResponse = {
    id: string;
    object: 'chat.completion';
    created: number;
    model: string;
    choices: {
        index: number;
        message: {
            role: string;
            content: string;
            tool_calls?: {
                id: string;
                type: 'function';
                function: {
                    name: string;
                    arguments: string;
                };
            }[];
        };
        finish_reason: 'stop' | 'length' | 'content_filter' | 'tool_calls';
    }[];
    usage?: AxAIOpenAIUsage;
    error?: {
        message: string;
        type: string;
        param: string;
        code: number;
    };
    system_fingerprint: string;
};
type AxAIOpenAIChatResponseDelta = AxAIOpenAIResponseDelta<{
    content: string;
    role?: string;
    tool_calls?: (NonNullable<AxAIOpenAIChatResponse['choices'][0]['message']['tool_calls']>[0] & {
        index: number;
    })[];
}>;
type AxAIOpenAIEmbedRequest = {
    input: readonly string[];
    model: string;
    dimensions?: number;
    user?: string;
};
type AxAIOpenAIEmbedResponse = {
    model: string;
    data: {
        embedding: readonly number[];
        index: number;
    }[];
    usage: AxAIOpenAIUsage;
};

interface AxAIOpenAIArgs {
    name: 'openai';
    apiKey: string;
    apiURL?: string;
    config?: Readonly<Partial<AxAIOpenAIConfig>>;
    options?: Readonly<AxAIServiceOptions & {
        streamingUsage?: boolean;
    }>;
    modelInfo?: Readonly<AxModelInfo[]>;
    modelMap?: Record<string, AxAIOpenAIModel | AxAIOpenAIEmbedModel | string>;
}
declare class AxAIOpenAI extends AxBaseAI<AxAIOpenAIChatRequest, AxAIOpenAIEmbedRequest, AxAIOpenAIChatResponse, AxAIOpenAIChatResponseDelta, AxAIOpenAIEmbedResponse> {
    constructor({ apiKey, config, options, apiURL, modelInfo, modelMap, }: Readonly<Omit<AxAIOpenAIArgs, 'name'>>);
}

interface AxAIAzureOpenAIArgs {
    name: 'azure-openai';
    apiKey: string;
    resourceName: string;
    deploymentName: string;
    version?: string;
    config?: Readonly<Partial<AxAIOpenAIConfig>>;
    options?: Readonly<AxAIServiceOptions>;
    modelMap?: Record<string, AxAIOpenAIModel | AxAIOpenAIEmbedModel>;
}
declare class AxAIAzureOpenAI extends AxAIOpenAI {
    constructor({ apiKey, resourceName, deploymentName, version, config, options, modelMap, }: Readonly<Omit<AxAIAzureOpenAIArgs, 'name'>>);
}

/**
 * Cohere: Models for text generation
 */
declare enum AxAICohereModel {
    CommandRPlus = "command-r-plus",
    CommandR = "command-r",
    Command = "command",
    CommandLight = "command-light"
}
/**
 * Cohere: Models for use in embeddings
 */
declare enum AxAICohereEmbedModel {
    EmbedEnglishV30 = "embed-english-v3.0",
    EmbedEnglishLightV30 = "embed-english-light-v3.0",
    EmbedMultiLingualV30 = "embed-multilingual-v3.0",
    EmbedMultiLingualLightV30 = "embed-multilingual-light-v3.0"
}
/**
 * Cohere: Model options for text generation
 */
type AxAICohereConfig = AxModelConfig & {
    model: AxAICohereModel;
    embedModel?: AxAICohereEmbedModel;
};
type AxAICohereChatResponseToolCalls = {
    name: string;
    parameters?: object;
}[];
type AxAICohereChatRequestToolResults = {
    call: AxAICohereChatResponseToolCalls[0];
    outputs: object[];
}[];
type AxAICohereChatRequest = {
    message?: string;
    preamble?: string;
    chat_history: ({
        role: 'CHATBOT';
        message: string;
        tool_calls?: AxAICohereChatResponseToolCalls;
    } | {
        role: 'SYSTEM';
        message: string;
    } | {
        role: 'USER';
        message: string;
    } | {
        role: 'TOOL';
        message?: string;
        tool_results: AxAICohereChatRequestToolResults;
    })[];
    model: AxAICohereModel | string;
    max_tokens?: number;
    temperature?: number;
    k?: number;
    p?: number;
    frequency_penalty?: number;
    presence_penalty?: number;
    end_sequences?: readonly string[];
    stop_sequences?: string[];
    tools?: {
        name: string;
        description: string;
        parameter_definitions: Record<string, {
            description: string;
            type: string;
            required: boolean;
        }>;
    }[];
    tool_results?: AxAICohereChatRequestToolResults;
};
type AxAICohereChatResponse = {
    response_id: string;
    meta: {
        billed_units: {
            input_tokens: number;
            output_tokens: number;
        };
    };
    generation_id: string;
    text: string;
    finish_reason: 'COMPLETE' | 'ERROR' | 'ERROR_TOXIC' | 'ERROR_LIMIT' | 'USER_CANCEL' | 'MAX_TOKENS';
    tool_calls: AxAICohereChatResponseToolCalls;
};
type AxAICohereChatResponseDelta = AxAICohereChatResponse & {
    event_type: 'stream-start' | 'text-generation' | 'tool-calls-generation' | 'stream-end';
};
type AxAICohereEmbedRequest = {
    texts: readonly string[];
    model: AxAICohereModel | string;
    truncate: string;
};
type AxAICohereEmbedResponse = {
    id: string;
    texts: string[];
    model: string;
    embeddings: number[][];
};

interface AxAICohereArgs {
    name: 'cohere';
    apiKey: string;
    config?: Readonly<Partial<AxAICohereConfig>>;
    options?: Readonly<AxAIServiceOptions>;
    modelMap?: Record<string, AxAICohereModel | AxAICohereEmbedModel | string>;
}
declare class AxAICohere extends AxBaseAI<AxAICohereChatRequest, AxAICohereEmbedRequest, AxAICohereChatResponse, AxAICohereChatResponseDelta, AxAICohereEmbedResponse> {
    constructor({ apiKey, config, options, modelMap, }: Readonly<Omit<AxAICohereArgs, 'name'>>);
}

/**
 * DeepSeek: Models for text generation
 */
declare enum AxAIDeepSeekModel {
    DeepSeekChat = "deepseek-chat",
    DeepSeekCoder = "deepseek-coder"
}

type DeepSeekConfig = AxAIOpenAIConfig;
interface AxAIDeepSeekArgs {
    name: 'deepseek';
    apiKey: string;
    config?: Readonly<Partial<DeepSeekConfig>>;
    options?: Readonly<AxAIServiceOptions>;
    modelMap?: Record<string, AxAIDeepSeekModel | string>;
}
declare class AxAIDeepSeek extends AxAIOpenAI {
    constructor({ apiKey, config, options, modelMap, }: Readonly<Omit<AxAIDeepSeekArgs, 'name'>>);
}

declare enum AxAIGoogleGeminiModel {
    Gemini1Pro = "gemini-1.0-pro",
    Gemini15Flash = "gemini-1.5-flash",
    Gemini15Flash8B = "gemini-1.5-flash-8b",
    Gemini15Pro = "gemini-1.5-pro",
    Gemma2 = "gemma-2-27b-it",
    AQA = "aqa"
}
declare enum AxAIGoogleGeminiEmbedModel {
    TextEmbedding004 = "text-embedding-004"
}
declare enum AxAIGoogleGeminiSafetyCategory {
    HarmCategoryHarassment = "HARM_CATEGORY_HARASSMENT",
    HarmCategoryHateSpeech = "HARM_CATEGORY_HATE_SPEECH",
    HarmCategorySexuallyExplicit = "HARM_CATEGORY_SEXUALLY_EXPLICIT",
    HarmCategoryDangerousContent = "HARM_CATEGORY_DANGEROUS_CONTENT"
}
declare enum AxAIGoogleGeminiSafetyThreshold {
    BlockNone = "BLOCK_NONE",
    BlockOnlyHigh = "BLOCK_ONLY_HIGH",
    BlockMediumAndAbove = "BLOCK_MEDIUM_AND_ABOVE",
    BlockLowAndAbove = "BLOCK_LOW_AND_ABOVE",
    BlockDefault = "HARM_BLOCK_THRESHOLD_UNSPECIFIED"
}
type AxAIGoogleGeminiContent = {
    role: 'user';
    parts: ({
        text: string;
    } | {
        inlineData: {
            mimeType: string;
            data: string;
        };
    } | {
        fileData: {
            mimeType: string;
            fileUri: string;
        };
    })[];
} | {
    role: 'model';
    parts: {
        text: string;
    }[] | {
        functionCall: {
            name: string;
            args: object;
        };
    }[];
} | {
    role: 'function';
    parts: {
        functionResponse: {
            name: string;
            response: object;
        };
    }[];
};
type AxAIGoogleGeminiToolFunctionDeclaration = {
    name: string;
    description?: string;
    parameters?: object;
};
type AxAIGoogleGeminiToolGoogleSearchRetrieval = {
    dynamic_retrieval_config: {
        mode?: 'MODE_DYNAMIC';
        dynamic_threshold?: number;
    };
};
type AxAIGoogleGeminiTool = {
    function_declarations?: AxAIGoogleGeminiToolFunctionDeclaration[];
    code_execution?: object;
    google_search_retrieval?: AxAIGoogleGeminiToolGoogleSearchRetrieval;
};
type AxAIGoogleGeminiToolConfig = {
    function_calling_config: {
        mode: 'ANY' | 'NONE' | 'AUTO';
        allowed_function_names?: string[];
    };
};
type AxAIGoogleGeminiGenerationConfig = {
    temperature?: number;
    topP?: number;
    topK?: number;
    candidateCount?: number;
    maxOutputTokens?: number;
    stopSequences?: readonly string[];
};
type AxAIGoogleGeminiSafetySettings = {
    category: AxAIGoogleGeminiSafetyCategory;
    threshold: AxAIGoogleGeminiSafetyThreshold;
}[];
type AxAIGoogleGeminiChatRequest = {
    contents: AxAIGoogleGeminiContent[];
    tools?: AxAIGoogleGeminiTool[];
    toolConfig?: AxAIGoogleGeminiToolConfig;
    systemInstruction?: AxAIGoogleGeminiContent;
    generationConfig: AxAIGoogleGeminiGenerationConfig;
    safetySettings?: AxAIGoogleGeminiSafetySettings;
};
type AxAIGoogleGeminiChatResponse = {
    candidates: {
        content: AxAIGoogleGeminiContent;
        finishReason: 'STOP' | 'MAX_TOKENS' | 'SAFETY' | 'RECITATION' | 'OTHER' | 'MALFORMED_FUNCTION_CALL';
        citationMetadata: {
            citations: {
                startIndex: number;
                endIndex: number;
                uri: string;
                title: string;
                license: string;
                publicationDate: {
                    year: number;
                    month: number;
                    day: number;
                };
            }[];
        };
    }[];
    usageMetadata: {
        promptTokenCount: number;
        candidatesTokenCount: number;
        totalTokenCount: number;
    };
};
type AxAIGoogleGeminiChatResponseDelta = AxAIGoogleGeminiChatResponse;
/**
 * AxAIGoogleGeminiConfig: Configuration options for Google Gemini API
 */
type AxAIGoogleGeminiConfig = AxModelConfig & {
    model: AxAIGoogleGeminiModel | string;
    embedModel?: AxAIGoogleGeminiEmbedModel;
    safetySettings?: AxAIGoogleGeminiSafetySettings;
};
/**
 * AxAIGoogleGeminiEmbedRequest: Structure for making an embedding request to the Google Gemini API.
 */
type AxAIGoogleGeminiBatchEmbedRequest = {
    requests: {
        model: string;
        content: {
            parts: {
                text: string;
            }[];
        };
    }[];
};
/**
 * AxAIGoogleGeminiEmbedResponse: Structure for handling responses from the Google Gemini API embedding requests.
 */
type AxAIGoogleGeminiBatchEmbedResponse = {
    embeddings: {
        values: number[];
    }[];
};

interface AxAIGoogleGeminiOptionsTools {
    codeExecution?: boolean;
    googleSearchRetrieval?: {
        mode?: 'MODE_DYNAMIC';
        dynamicThreshold?: number;
    };
}
interface AxAIGoogleGeminiArgs {
    name: 'google-gemini';
    apiKey: string;
    projectId?: string;
    region?: string;
    config?: Readonly<Partial<AxAIGoogleGeminiConfig>>;
    options?: Readonly<AxAIServiceOptions & AxAIGoogleGeminiOptionsTools>;
    modelMap?: Record<string, AxAIGoogleGeminiModel | AxAIGoogleGeminiEmbedModel | string>;
}
/**
 * AxAIGoogleGemini: AI Service
 */
declare class AxAIGoogleGemini extends AxBaseAI<AxAIGoogleGeminiChatRequest, AxAIGoogleGeminiBatchEmbedRequest, AxAIGoogleGeminiChatResponse, AxAIGoogleGeminiChatResponseDelta, AxAIGoogleGeminiBatchEmbedResponse> {
    constructor({ apiKey, projectId, region, config, options, modelMap, }: Readonly<Omit<AxAIGoogleGeminiArgs, 'name'>>);
}

declare enum AxAIGroqModel {
    Llama3_8B = "llama3-8b-8192",
    Llama3_70B = "llama3-70b-8192",
    Mixtral_8x7B = "mixtral-8x7b-32768",
    Gemma_7B = "gemma-7b-it"
}

type AxAIGroqAIConfig = AxAIOpenAIConfig;
interface AxAIGroqArgs {
    name: 'groq';
    apiKey: string;
    config?: Readonly<Partial<AxAIGroqAIConfig>>;
    options?: Readonly<AxAIServiceOptions> & {
        tokensPerMinute?: number;
    };
    modelMap?: Record<string, AxAIGroqModel>;
}
declare class AxAIGroq extends AxAIOpenAI {
    constructor({ apiKey, config, options, modelMap, }: Readonly<Omit<AxAIGroqArgs, 'groq'>>);
    setOptions: (options: Readonly<AxAIServiceOptions>) => void;
    private newRateLimiter;
}

declare enum AxAIHuggingFaceModel {
    MetaLlama270BChatHF = "meta-llama/Llama-2-70b-chat-hf"
}
type AxAIHuggingFaceConfig = AxModelConfig & {
    model: AxAIHuggingFaceModel;
    returnFullText?: boolean;
    doSample?: boolean;
    maxTime?: number;
    useCache?: boolean;
    waitForModel?: boolean;
};
type AxAIHuggingFaceRequest = {
    model: AxAIHuggingFaceModel | string;
    inputs: string;
    parameters: {
        max_new_tokens?: number;
        repetition_penalty?: number;
        temperature?: number;
        top_p?: number;
        top_k?: number;
        return_full_text?: boolean;
        num_return_sequences?: number;
        do_sample?: boolean;
        max_time?: number;
    };
    options?: {
        use_cache?: boolean;
        wait_for_model?: boolean;
    };
};
type AxAIHuggingFaceResponse = {
    generated_text: string;
};

interface AxAIHuggingFaceArgs {
    name: 'huggingface';
    apiKey: string;
    config?: Readonly<Partial<AxAIHuggingFaceConfig>>;
    options?: Readonly<AxAIServiceOptions>;
    modelMap?: Record<string, AxAIHuggingFaceModel>;
}
declare class AxAIHuggingFace extends AxBaseAI<AxAIHuggingFaceRequest, unknown, AxAIHuggingFaceResponse, unknown, unknown> {
    constructor({ apiKey, config, options, modelMap, }: Readonly<Omit<AxAIHuggingFaceArgs, 'name'>>);
}

declare enum AxAIMistralModel {
    Mistral7B = "open-mistral-7b",
    Mistral8x7B = "open-mixtral-8x7b",
    MistralSmall = "mistral-small-latest",
    MistralNemo = "mistral-nemo-latest",
    MistralLarge = "mistral-large-latest",
    Codestral = "codestral-latest",
    OpenCodestralMamba = "open-codestral-mamba",
    OpenMistralNemo = "open-mistral-nemo-latest"
}
declare enum AxAIMistralEmbedModels {
    MistralEmbed = "mistral-embed"
}

type MistralConfig = AxAIOpenAIConfig;
interface AxAIMistralArgs {
    name: 'mistral';
    apiKey: string;
    config?: Readonly<Partial<MistralConfig>>;
    options?: Readonly<AxAIServiceOptions>;
    modelMap?: Record<string, AxAIMistralModel | AxAIMistralEmbedModels | string>;
}
declare class AxAIMistral extends AxAIOpenAI {
    constructor({ apiKey, config, options, modelMap, }: Readonly<Omit<AxAIMistralArgs, 'name'>>);
}

type AxAIOllamaAIConfig = AxAIOpenAIConfig;
type AxAIOllamaArgs = {
    name: 'ollama';
    model?: string;
    embedModel?: string;
    url?: string;
    apiKey?: string;
    config?: Readonly<Partial<AxAIOllamaAIConfig>>;
    options?: Readonly<AxAIServiceOptions>;
    modelMap?: Record<string, string>;
};
/**
 * OllamaAI: AI Service
 */
declare class AxAIOllama extends AxAIOpenAI {
    constructor({ apiKey, url, config, options, modelMap, }: Readonly<Omit<AxAIOllamaArgs, 'name'>>);
}

declare enum AxAIRekaModel {
    RekaCore = "reka-core",
    RekaFlash = "reka-flash",
    RekaEdge = "reka-edge"
}
type AxAIRekaConfig = Omit<AxModelConfig, 'topK'> & {
    model: AxAIRekaModel | string;
    stop?: readonly string[];
    useSearchEngine?: boolean;
};
type AxAIRekaUsage = {
    input_tokens: number;
    output_tokens: number;
};
type AxAIRekaChatRequest = {
    model: string;
    messages: ({
        role: 'user';
        content: string | {
            type: 'text';
            text: string;
        }[];
    } | {
        role: 'assistant';
        content: string | {
            type: 'text';
            text: string;
        }[];
    })[];
    usage?: AxAIRekaUsage;
    response_format?: {
        type: string;
    };
    max_tokens: number;
    temperature?: number;
    top_p?: number;
    top_k?: number;
    stream?: boolean;
    stop?: readonly string[];
    presence_penalty?: number;
    frequency_penalty?: number;
    use_search_engine?: boolean;
};
type AxAIRekaChatResponse = {
    id: string;
    model: string;
    responses: {
        message: {
            content: string | {
                type: 'text';
                text: string;
            };
        };
        finish_reason: 'stop' | 'length' | 'context';
    }[];
    usage?: AxAIRekaUsage;
};
type AxAIRekaChatResponseDelta = {
    id: string;
    model: string;
    responses: {
        chunk: AxAIRekaChatResponse['responses'][0]['message'];
        finish_reason: AxAIRekaChatResponse['responses'][0]['finish_reason'];
    }[];
    usage?: AxAIRekaUsage;
};

interface AxAIRekaArgs {
    name: 'reka';
    apiKey: string;
    apiURL?: string;
    config?: Readonly<Partial<AxAIRekaConfig>>;
    options?: Readonly<AxAIServiceOptions & {
        streamingUsage?: boolean;
    }>;
    modelInfo?: Readonly<AxModelInfo[]>;
    modelMap?: Record<string, AxAIRekaModel | string>;
}
declare class AxAIReka extends AxBaseAI<AxAIRekaChatRequest, unknown, AxAIRekaChatResponse, AxAIRekaChatResponseDelta, unknown> {
    constructor({ apiKey, config, options, apiURL, modelInfo, modelMap, }: Readonly<Omit<AxAIRekaArgs, 'name'>>);
}

type TogetherAIConfig = AxAIOpenAIConfig;
interface AxAITogetherArgs {
    name: 'together';
    apiKey: string;
    config?: Readonly<Partial<TogetherAIConfig>>;
    options?: Readonly<AxAIServiceOptions>;
    modelMap?: Record<string, string>;
}
declare class AxAITogether extends AxAIOpenAI {
    constructor({ apiKey, config, options, modelMap, }: Readonly<Omit<AxAITogetherArgs, 'name'>>);
}

type AxAIArgs = AxAIOpenAIArgs | AxAIAzureOpenAIArgs | AxAITogetherArgs | AxAIAnthropicArgs | AxAIGroqArgs | AxAIGoogleGeminiArgs | AxAICohereArgs | AxAIHuggingFaceArgs | AxAIMistralArgs | AxAIDeepSeekArgs | AxAIOllamaArgs | AxAIRekaArgs;
type AxAIModels = AxAIOpenAIModel | AxAIAnthropicModel | AxAIGroqModel | AxAIGoogleGeminiModel | AxAICohereModel | AxAIHuggingFaceModel | AxAIMistralModel | AxAIDeepSeekModel | string;
type AxAIEmbedModels = AxAIOpenAIEmbedModel | AxAIGoogleGeminiEmbedModel | AxAICohereEmbedModel | string;
declare class AxAI implements AxAIService {
    private ai;
    constructor(options: Readonly<AxAIArgs>);
    getName(): string;
    getModelInfo(): Readonly<AxModelInfoWithProvider>;
    getEmbedModelInfo(): Readonly<AxModelInfoWithProvider> | undefined;
    getFeatures(model?: string): {
        functions: boolean;
        streaming: boolean;
    };
    getModelMap(): AxAIModelMap | undefined;
    getMetrics(): AxAIServiceMetrics;
    chat(req: Readonly<AxChatRequest>, options?: Readonly<AxAIPromptConfig & AxAIServiceActionOptions>): Promise<AxChatResponse | ReadableStream<AxChatResponse>>;
    embed(req: Readonly<AxEmbedRequest>, options?: Readonly<AxAIServiceActionOptions & AxAIServiceActionOptions>): Promise<AxEmbedResponse>;
    setOptions(options: Readonly<AxAIServiceOptions>): void;
}

interface AxAIMemory {
    add(result: Readonly<AxChatRequest['chatPrompt'] | AxChatRequest['chatPrompt'][0]>, sessionId?: string): void;
    addResult(result: Readonly<AxChatResponseResult>, sessionId?: string): void;
    updateResult(result: Readonly<AxChatResponseResult>, sessionId?: string): void;
    history(sessionId?: string): AxChatRequest['chatPrompt'];
    reset(sessionId?: string): void;
    getLast(sessionId?: string): AxChatRequest['chatPrompt'][0] | undefined;
}

interface AxField {
    name: string;
    title?: string;
    description?: string;
    type?: {
        name: 'string' | 'number' | 'boolean' | 'json' | 'image' | 'audio' | 'date' | 'datetime' | 'class';
        isArray: boolean;
        classes?: string[];
    };
    isOptional?: boolean;
}
type AxIField = Omit<AxField, 'title'> & {
    title: string;
};
declare class AxSignature {
    private description?;
    private inputFields;
    private outputFields;
    private sigHash;
    private sigString;
    constructor(signature?: Readonly<AxSignature | string>);
    private parseParsedField;
    private parseField;
    setDescription: (desc: string) => void;
    addInputField: (field: Readonly<AxField>) => void;
    addOutputField: (field: Readonly<AxField>) => void;
    setInputFields: (fields: readonly AxField[]) => void;
    setOutputFields: (fields: readonly AxField[]) => void;
    getInputFields: () => Readonly<AxIField[]>;
    getOutputFields: () => Readonly<AxIField[]>;
    getDescription: () => string | undefined;
    private toTitle;
    toJSONSchema: () => AxFunctionJSONSchema;
    private updateHash;
    hash: () => string;
    toString: () => string;
}

type AxFieldValue = string | string[] | number | boolean | object | null | undefined | {
    mimeType: string;
    data: string;
} | {
    mimeType: string;
    data: string;
}[] | {
    format?: 'wav';
    data: string;
} | {
    format?: 'wav';
    data: string;
}[];
type AxGenIn = {
    [key: symbol]: AxFieldValue;
};
type AxGenOut = Record<string, AxFieldValue>;
type AxProgramTrace = {
    trace: Record<string, AxFieldValue>;
    programId: string;
};
type AxProgramDemos = {
    traces: Record<string, AxFieldValue>[];
    programId: string;
};
type AxProgramExamples = AxProgramDemos | AxProgramDemos['traces'];
type AxProgramForwardOptions = {
    maxCompletions?: number;
    maxRetries?: number;
    maxSteps?: number;
    mem?: AxAIMemory;
    ai?: AxAIService;
    modelConfig?: AxModelConfig;
    model?: string;
    sessionId?: string;
    traceId?: string | undefined;
    tracer?: Tracer;
    rateLimiter?: AxRateLimiterFunction;
    stream?: boolean;
    debug?: boolean;
    functions?: AxFunction[];
    functionCall?: AxChatRequest['functionCall'];
    stopFunction?: string;
};
interface AxTunable {
    setExamples: (examples: Readonly<AxProgramExamples>) => void;
    setId: (id: string) => void;
    setParentId: (parentId: string) => void;
    getTraces: () => AxProgramTrace[];
    setDemos: (demos: readonly AxProgramDemos[]) => void;
}
interface AxUsable {
    getUsage: () => AxProgramUsage[];
    resetUsage: () => void;
}
type AxProgramUsage = AxChatResponse['modelUsage'] & {
    ai: string;
    model: string;
};
interface AxProgramWithSignatureOptions {
    description?: string;
}
declare class AxProgramWithSignature<IN extends AxGenIn, OUT extends AxGenOut> implements AxTunable, AxUsable {
    protected signature: AxSignature;
    protected sigHash: string;
    protected examples?: Record<string, AxFieldValue>[];
    protected demos?: Record<string, AxFieldValue>[];
    protected trace?: Record<string, AxFieldValue>;
    protected usage: AxProgramUsage[];
    private key;
    private children;
    constructor(signature: Readonly<AxSignature | string>, options?: Readonly<AxProgramWithSignatureOptions>);
    getSignature(): AxSignature;
    register(prog: Readonly<AxTunable & AxUsable>): void;
    forward(_ai: Readonly<AxAIService>, _values: IN, _options?: Readonly<AxProgramForwardOptions>): Promise<OUT>;
    setId(id: string): void;
    setParentId(parentId: string): void;
    setExamples(examples: Readonly<AxProgramExamples>): void;
    private _setExamples;
    getTraces(): AxProgramTrace[];
    getUsage(): AxProgramUsage[];
    resetUsage(): void;
    setDemos(demos: readonly AxProgramDemos[]): void;
}
declare class AxProgram<IN extends AxGenIn, OUT extends AxGenOut> implements AxTunable, AxUsable {
    protected trace?: Record<string, AxFieldValue>;
    protected usage: AxProgramUsage[];
    private key;
    private children;
    constructor();
    register(prog: Readonly<AxTunable & AxUsable>): void;
    forward(_ai: Readonly<AxAIService>, _values: IN, _options?: Readonly<AxProgramForwardOptions>): Promise<OUT>;
    setId(id: string): void;
    setParentId(parentId: string): void;
    setExamples(examples: Readonly<AxProgramExamples>): void;
    getTraces(): AxProgramTrace[];
    getUsage(): AxProgramUsage[];
    resetUsage(): void;
    setDemos(demos: readonly AxProgramDemos[]): void;
}

interface AxAssertion {
    fn(values: Record<string, unknown>): boolean | undefined;
    message?: string;
    optional?: boolean;
}
interface AxStreamingAssertion {
    fieldName: string;
    fn(content: string, done?: boolean): boolean | undefined;
    message?: string;
    optional?: boolean;
}
declare class AxAssertionError extends Error {
    private values;
    private optional?;
    constructor({ message, values, optional, }: Readonly<{
        message: string;
        values: Record<string, unknown>;
        optional?: boolean;
    }>);
    getValue: () => Record<string, unknown>;
    getOptional: () => boolean | undefined;
    getFixingInstructions: (_sig: Readonly<AxSignature>) => {
        name: string;
        title: string;
        description: string;
    }[];
}

declare class AxMemory implements AxAIMemory {
    private data;
    private sdata;
    private limit;
    constructor(limit?: number);
    add(value: Readonly<AxChatRequest['chatPrompt'][0] | AxChatRequest['chatPrompt']>, sessionId?: string): void;
    addResult({ content, name, functionCalls }: Readonly<AxChatResponseResult>, sessionId?: string): void;
    updateResult({ content, name, functionCalls }: Readonly<AxChatResponseResult>, sessionId?: string): void;
    history(sessionId?: string): AxChatRequest['chatPrompt'];
    getLast(sessionId?: string): AxChatRequest['chatPrompt'][0] | undefined;
    reset(sessionId?: string): void;
    private get;
}

type AxChatResponseFunctionCall = {
    id?: string;
    name: string;
    args: string;
};
type AxFunctionExec = {
    id?: string;
    result?: string;
};
declare class AxFunctionProcessor {
    private funcList;
    constructor(funcList: Readonly<AxFunction[]>);
    private executeFunction;
    execute: (func: Readonly<AxChatResponseFunctionCall>, options?: Readonly<AxAIServiceActionOptions>) => Promise<AxFunctionExec>;
}
type AxInputFunctionType = AxFunction[] | {
    toFunction: () => AxFunction;
}[];

type Writeable<T> = {
    -readonly [P in keyof T]: T[P];
};
type AxChatRequestChatPrompt = Writeable<AxChatRequest['chatPrompt'][0]>;
type ChatRequestUserMessage = Exclude<Extract<AxChatRequestChatPrompt, {
    role: 'user';
}>['content'], string>;
type AxFieldTemplateFn = (field: Readonly<AxField>, value: Readonly<AxFieldValue>) => ChatRequestUserMessage;
declare class AxPromptTemplate {
    private sig;
    private fieldTemplates?;
    private task;
    constructor(sig: Readonly<AxSignature>, functions?: Readonly<AxInputFunctionType>, fieldTemplates?: Record<string, AxFieldTemplateFn>);
    render: <T extends Record<string, AxFieldValue>>(values: T, { examples, demos, }: Readonly<{
        skipSystemPrompt?: boolean;
        examples?: Record<string, AxFieldValue>[];
        demos?: Record<string, AxFieldValue>[];
    }>) => AxChatRequest["chatPrompt"];
    renderExtraFields: (extraFields: readonly AxIField[]) => string | ({
        type: "text";
        text: string;
        cache?: boolean;
    } | {
        type: "image";
        mimeType: string;
        image: string;
        details?: "high" | "low" | "auto";
        cache?: boolean;
    } | {
        type: "audio";
        data: string;
        format?: "wav";
        cache?: boolean;
    })[];
    private renderExamples;
    private renderDemos;
    private renderInputFields;
    private renderInField;
    private defaultRenderInField;
    private renderDescFields;
    private renderFields;
}

interface AxGenOptions {
    maxCompletions?: number;
    maxRetries?: number;
    maxSteps?: number;
    mem?: AxAIMemory;
    tracer?: Tracer;
    rateLimiter?: AxRateLimiterFunction;
    stream?: boolean;
    debug?: boolean;
    description?: string;
    functions?: AxInputFunctionType;
    functionCall?: AxChatRequest['functionCall'];
    stopFunction?: string;
    promptTemplate?: typeof AxPromptTemplate;
    asserts?: AxAssertion[];
    streamingAsserts?: AxStreamingAssertion[];
}
type AxGenerateResult<OUT extends AxGenOut> = OUT & {
    functions?: AxChatResponseFunctionCall[];
};
interface AxResponseHandlerArgs<T> {
    ai: Readonly<AxAIService>;
    model?: string;
    res: T;
    usageInfo: {
        ai: string;
        model: string;
    };
    mem: AxAIMemory;
    sessionId?: string;
    traceId?: string;
    functions?: Readonly<AxFunction[]>;
}
declare class AxGen<IN extends AxGenIn = AxGenIn, OUT extends AxGenerateResult<AxGenOut> = AxGenerateResult<AxGenOut>> extends AxProgramWithSignature<IN, OUT> {
    private promptTemplate;
    private asserts;
    private streamingAsserts;
    private options?;
    private functions?;
    private functionsExecuted;
    constructor(signature: Readonly<AxSignature | string>, options?: Readonly<AxGenOptions>);
    addAssert: (fn: AxAssertion["fn"], message?: string, optional?: boolean) => void;
    addStreamingAssert: (fieldName: string, fn: AxStreamingAssertion["fn"], message?: string, optional?: boolean) => void;
    private forwardSendRequest;
    private forwardCore;
    private processSteamingResponse;
    private processResponse;
    private _forward;
    forward(ai: Readonly<AxAIService>, values: IN, options?: Readonly<AxProgramForwardOptions>): Promise<OUT>;
}

interface AxAgentic extends AxTunable, AxUsable {
    getFunction(): AxFunction;
}
type AxAgentOptions = Omit<AxGenOptions, 'functions'>;
declare class AxAgent<IN extends AxGenIn, OUT extends AxGenOut> implements AxAgentic {
    private ai?;
    private signature;
    private program;
    private agents?;
    private name;
    private description;
    private subAgentList?;
    private func;
    constructor({ ai, name, description, signature, agents, functions, }: Readonly<{
        ai?: Readonly<AxAIService>;
        name: string;
        description: string;
        signature: AxSignature | string;
        agents?: AxAgentic[];
        functions?: AxFunction[];
    }>, options?: Readonly<AxAgentOptions>);
    setExamples(examples: Readonly<AxProgramExamples>): void;
    setId(id: string): void;
    setParentId(parentId: string): void;
    getTraces(): AxProgramTrace[];
    setDemos(demos: readonly AxProgramDemos[]): void;
    getUsage(): (AxTokenUsage & {
        ai: string;
        model: string;
    })[];
    resetUsage(): void;
    getFunction(): AxFunction;
    forward(ai: Readonly<AxAIService>, values: IN, options?: Readonly<AxProgramForwardOptions>): Promise<OUT>;
}

interface AxApacheTikaArgs {
    url?: string | URL;
    fetch?: typeof fetch;
}
interface AxApacheTikaConvertOptions {
    format?: 'text' | 'html';
}
declare class AxApacheTika {
    private tikaUrl;
    private fetch?;
    constructor(args?: Readonly<AxApacheTikaArgs>);
    private _convert;
    convert(files: Readonly<string[] | Blob[]>, options?: Readonly<{
        batchSize?: number;
        format?: 'html' | 'text';
    }>): Promise<string[]>;
}

/**
 * Options for the balancer.
 */
type AxBalancerOptions = {
    comparator?: (a: AxAIService, b: AxAIService) => number;
};
/**
 * Balancer that rotates through services.
 */
declare class AxBalancer implements AxAIService {
    private services;
    private currentServiceIndex;
    private currentService;
    constructor(services: readonly AxAIService[], options?: AxBalancerOptions);
    getModelMap(): AxAIModelMap | undefined;
    private getNextService;
    private reset;
    getName(): string;
    getModelInfo(): Readonly<AxModelInfoWithProvider>;
    getEmbedModelInfo(): Readonly<AxModelInfoWithProvider> | undefined;
    getFeatures(model?: string): {
        functions: boolean;
        streaming: boolean;
    };
    getMetrics(): AxAIServiceMetrics;
    chat(req: Readonly<AxChatRequest>, options?: Readonly<AxAIPromptConfig & AxAIServiceActionOptions> | undefined): Promise<AxChatResponse | ReadableStream<AxChatResponse>>;
    embed(req: Readonly<AxEmbedRequest>, options?: Readonly<AxAIServiceActionOptions> | undefined): Promise<AxEmbedResponse>;
    setOptions(options: Readonly<AxAIServiceOptions>): void;
}

type AxExample = Record<string, AxFieldValue>;
type AxMetricFn = <T extends AxGenOut = AxGenOut>(arg0: Readonly<{
    prediction: T;
    example: AxExample;
}>) => boolean;
type AxMetricFnArgs = Parameters<AxMetricFn>[0];
type AxOptimizerArgs<IN extends AxGenIn, OUT extends AxGenOut> = {
    ai: AxAIService;
    program: Readonly<AxProgram<IN, OUT>>;
    examples: Readonly<AxExample[]>;
    options?: {
        maxRounds?: number;
        maxExamples?: number;
        maxDemos?: number;
    };
};
declare class AxBootstrapFewShot<IN extends AxGenIn = AxGenIn, OUT extends AxGenOut = AxGenOut> {
    private ai;
    private program;
    private examples;
    private maxRounds;
    private maxDemos;
    private maxExamples;
    private traces;
    constructor({ ai, program, examples, options, }: Readonly<AxOptimizerArgs<IN, OUT>>);
    private compileRound;
    compile(metricFn: AxMetricFn, options?: Readonly<AxOptimizerArgs<IN, OUT>['options']>): Promise<AxProgramDemos[]>;
}

type AxDBUpsertRequest = {
    id: string;
    text?: string;
    values?: readonly number[];
    metadata?: Record<string, string>;
    table: string;
    namespace?: string;
};
type AxDBUpsertResponse = {
    ids: string[];
};
type AxDBQueryRequest = {
    id?: string;
    text?: string;
    values?: readonly number[];
    table: string;
    columns?: string[];
    limit?: number;
    namespace?: string;
};
type AxDBQueryResponse = {
    matches: {
        id: string;
        score: number;
        metadata?: Record<string, string>;
        table?: string;
    }[];
};
interface AxDBService extends AxDBQueryService {
    upsert(req: Readonly<AxDBUpsertRequest>, update?: boolean): Promise<AxDBUpsertResponse>;
    batchUpsert(batchReq: Readonly<AxDBUpsertRequest[]>, update?: boolean): Promise<AxDBUpsertResponse>;
}
interface AxDBQueryService {
    query(req: Readonly<AxDBQueryRequest>): Promise<AxDBQueryResponse>;
}

interface AxDBBaseArgs {
    fetch?: typeof fetch;
    tracer?: Tracer;
}
interface AxDBBaseOpOptions {
    span?: Span;
}
declare class AxDBBase implements AxDBService {
    protected name: string;
    protected fetch?: typeof fetch;
    private tracer?;
    _upsert?: (req: Readonly<AxDBUpsertRequest>, update?: boolean, options?: Readonly<AxDBBaseOpOptions>) => Promise<AxDBUpsertResponse>;
    _batchUpsert?: (batchReq: Readonly<AxDBUpsertRequest[]>, update?: boolean, options?: Readonly<AxDBBaseOpOptions>) => Promise<AxDBUpsertResponse>;
    _query?: (req: Readonly<AxDBQueryRequest>, options?: Readonly<AxDBBaseOpOptions>) => Promise<AxDBQueryResponse>;
    constructor({ name, fetch, tracer, }: Readonly<AxDBBaseArgs & {
        name: string;
    }>);
    upsert(req: Readonly<AxDBUpsertRequest>, update?: boolean): Promise<AxDBUpsertResponse>;
    batchUpsert(req: Readonly<AxDBUpsertRequest[]>, update?: boolean): Promise<AxDBUpsertResponse>;
    query(req: Readonly<AxDBQueryRequest>): Promise<AxDBQueryResponse>;
}

type AxDBCloudflareOpOptions = AxDBBaseOpOptions;
interface AxDBCloudflareArgs extends AxDBBaseArgs {
    name: 'cloudflare';
    apiKey: string;
    accountId: string;
    fetch?: typeof fetch;
}
/**
 * Cloudflare: DB Service
 */
declare class AxDBCloudflare extends AxDBBase {
    private apiKey;
    private accountId;
    constructor({ apiKey, accountId, fetch, tracer, }: Readonly<Omit<AxDBCloudflareArgs, 'name'>>);
    _upsert: (req: Readonly<AxDBUpsertRequest>, _update?: boolean, options?: Readonly<AxDBCloudflareOpOptions>) => Promise<AxDBUpsertResponse>;
    batchUpsert: (batchReq: Readonly<AxDBUpsertRequest[]>, update?: boolean, options?: Readonly<AxDBCloudflareOpOptions>) => Promise<AxDBUpsertResponse>;
    query: (req: Readonly<AxDBQueryRequest>, options?: Readonly<AxDBCloudflareOpOptions>) => Promise<AxDBQueryResponse>;
}

type AxDBMemoryOpOptions = AxDBBaseOpOptions;
interface AxDBMemoryArgs extends AxDBBaseArgs {
    name: 'memory';
}
type AxDBState = Record<string, Record<string, AxDBUpsertRequest>>;
/**
 * MemoryDB: DB Service
 */
declare class AxDBMemory extends AxDBBase {
    private state;
    constructor({ tracer }?: Readonly<Omit<AxDBMemoryArgs, 'name'>>);
    _upsert: (req: Readonly<AxDBUpsertRequest>, _update?: boolean, _options?: Readonly<AxDBMemoryOpOptions>) => Promise<AxDBUpsertResponse>;
    _batchUpsert: (batchReq: Readonly<AxDBUpsertRequest[]>, update?: boolean, _options?: Readonly<AxDBMemoryOpOptions>) => Promise<AxDBUpsertResponse>;
    _query: (req: Readonly<AxDBQueryRequest>, _options?: Readonly<AxDBMemoryOpOptions>) => Promise<AxDBQueryResponse>;
    getDB: () => AxDBState;
    setDB: (state: AxDBState) => void;
    clearDB: () => void;
}

type AxDBPineconeOpOptions = AxDBBaseOpOptions;
interface AxDBPineconeArgs extends AxDBBaseArgs {
    name: 'pinecone';
    apiKey: string;
    host: string;
    fetch?: typeof fetch;
}
/**
 * Pinecone: DB Service
 */
declare class AxDBPinecone extends AxDBBase {
    private apiKey;
    private apiURL;
    constructor({ apiKey, host, fetch, tracer, }: Readonly<Omit<AxDBPineconeArgs, 'name'>>);
    _upsert: (req: Readonly<AxDBUpsertRequest>, update?: boolean, options?: Readonly<AxDBPineconeOpOptions>) => Promise<AxDBUpsertResponse>;
    _batchUpsert: (batchReq: Readonly<AxDBUpsertRequest[]>, _update?: boolean, options?: Readonly<AxDBPineconeOpOptions>) => Promise<AxDBUpsertResponse>;
    query: (req: Readonly<AxDBQueryRequest>, options?: Readonly<AxDBPineconeOpOptions>) => Promise<AxDBQueryResponse>;
}

type AxDBWeaviateOpOptions = AxDBBaseOpOptions;
interface AxDBWeaviateArgs extends AxDBBaseArgs {
    name: 'weaviate';
    apiKey: string;
    host: string;
    fetch?: typeof fetch;
}
/**
 * Weaviate: DB Service
 */
declare class AxDBWeaviate extends AxDBBase {
    private apiKey;
    private apiURL;
    constructor({ apiKey, host, fetch, tracer, }: Readonly<Omit<AxDBWeaviateArgs, 'name'>>);
    _upsert: (req: Readonly<AxDBUpsertRequest>, update?: boolean, options?: Readonly<AxDBWeaviateOpOptions>) => Promise<AxDBUpsertResponse>;
    _batchUpsert: (batchReq: Readonly<AxDBUpsertRequest[]>, update?: boolean, options?: Readonly<AxDBWeaviateOpOptions>) => Promise<AxDBUpsertResponse>;
    _query: (req: Readonly<AxDBQueryRequest>, options?: Readonly<AxDBWeaviateOpOptions>) => Promise<AxDBQueryResponse>;
}

type AxDBArgs = AxDBCloudflareArgs | AxDBPineconeArgs | AxDBWeaviateArgs | AxDBMemoryArgs;
declare class AxDB implements AxDBService {
    private db;
    constructor(args: Readonly<AxDBArgs>);
    upsert(req: Readonly<AxDBUpsertRequest>, update?: boolean): Promise<AxDBUpsertResponse>;
    batchUpsert(batchReq: Readonly<AxDBUpsertRequest[]>, update?: boolean): Promise<AxDBUpsertResponse>;
    query(req: Readonly<AxDBQueryRequest>): Promise<AxDBQueryResponse>;
}

type AxRewriteIn = {
    query: string;
};
type AxRewriteOut = {
    rewrittenQuery: string;
};
type AxRerankerIn = {
    query: string;
    items: string[];
};
type AxRerankerOut = {
    rankedItems: string[];
};
interface AxDBLoaderOptions {
    chunker?: (text: string) => string[];
    rewriter?: AxProgram<AxRewriteIn, AxRewriteOut>;
    reranker?: AxProgram<AxRerankerIn, AxRerankerOut>;
}
interface AxDBManagerArgs {
    ai: AxAIService;
    db: AxDBService;
    config?: AxDBLoaderOptions;
}
interface AxDBMatch {
    score: number;
    text: string;
}
declare class AxDBManager {
    private ai;
    private db;
    private chunker;
    private rewriter?;
    private reranker?;
    constructor({ ai, db, config }: Readonly<AxDBManagerArgs>);
    private defaultChunker;
    insert: (text: Readonly<string | string[]>, options?: Readonly<{
        batchSize?: number;
        maxWordsPerChunk?: number;
        minWordsPerChunk?: number;
    }>) => Promise<void>;
    query: (query: Readonly<string | string[] | number | number[]>, { topPercent }?: Readonly<{
        topPercent?: number;
    }> | undefined) => Promise<AxDBMatch[][]>;
}

interface AxDockerContainer {
    Id: string;
    Names: string[];
    Image: string;
    ImageID: string;
    Command: string;
    Created: number;
    State: {
        Status: string;
        Running: boolean;
        Paused: boolean;
        Restarting: boolean;
        OOMKilled: boolean;
        Dead: boolean;
        Pid: number;
        ExitCode: number;
        Error: string;
        StartedAt: Date;
        FinishedAt: Date;
    };
    Status: string;
    Ports: Array<{
        IP: string;
        PrivatePort: number;
        PublicPort: number;
        Type: string;
    }>;
    Labels: {
        [key: string]: string;
    };
    SizeRw: number;
    SizeRootFs: number;
    HostConfig: {
        NetworkMode: string;
    };
    NetworkSettings: {
        Networks: {
            [key: string]: {
                IPAddress: string;
                IPPrefixLen: number;
                Gateway: string;
                MacAddress: string;
            };
        };
    };
    Mounts: Array<{
        Type: string;
        Source: string;
        Destination: string;
        Mode: string;
        RW: boolean;
        Propagation: string;
    }>;
}
declare class AxDockerSession {
    private readonly apiUrl;
    private containerId;
    constructor(apiUrl?: string);
    pullImage(imageName: string): Promise<void>;
    createContainer({ imageName, volumes, doNotPullImage, tag, }: Readonly<{
        imageName: string;
        volumes?: Array<{
            hostPath: string;
            containerPath: string;
        }>;
        doNotPullImage?: boolean;
        tag?: string;
    }>): Promise<{
        Id: string;
    }>;
    findOrCreateContainer({ imageName, volumes, doNotPullImage, tag, }: Readonly<{
        imageName: string;
        volumes?: Array<{
            hostPath: string;
            containerPath: string;
        }>;
        doNotPullImage?: boolean;
        tag: string;
    }>): Promise<{
        Id: string;
        isNew: boolean;
    }>;
    startContainer(): Promise<void>;
    connectToContainer(containerId: string): Promise<void>;
    stopContainers({ tag, remove, timeout, }: Readonly<{
        tag?: string;
        remove?: boolean;
        timeout?: number;
    }>): Promise<Array<{
        Id: string;
        Action: 'stopped' | 'removed';
    }>>;
    listContainers(all?: boolean): Promise<AxDockerContainer[]>;
    getContainerLogs(): Promise<string>;
    executeCommand(command: string): Promise<string>;
    private getContainerInfo;
    private waitForContainerToBeRunning;
    private fetchDockerAPI;
    toFunction(): AxFunction;
}

type AxDataRow = {
    row: Record<string, AxFieldValue>;
};
declare class AxHFDataLoader {
    private rows;
    private baseUrl;
    private dataset;
    private split;
    private config;
    private options?;
    constructor({ dataset, split, config, options, }: Readonly<{
        dataset: string;
        split: string;
        config: string;
        options?: Readonly<{
            offset?: number;
            length?: number;
        }>;
    }>);
    private fetchDataFromAPI;
    loadData(): Promise<AxDataRow[]>;
    setData(rows: AxDataRow[]): void;
    getData(): AxDataRow[];
    getRows<T>({ count, fields, renameMap, }: Readonly<{
        count: number;
        fields: readonly string[];
        renameMap?: Record<string, string>;
    }>): Promise<T[]>;
}

declare enum AxJSInterpreterPermission {
    FS = "node:fs",
    NET = "net",
    OS = "os",
    CRYPTO = "crypto",
    PROCESS = "process"
}
declare class AxJSInterpreter {
    private permissions;
    constructor({ permissions, }?: Readonly<{
        permissions?: readonly AxJSInterpreterPermission[];
    }> | undefined);
    private codeInterpreterJavascript;
    toFunction(): AxFunction;
}

declare enum AxLLMRequestTypeValues {
    COMPLETION = "completion",
    CHAT = "chat",
    RERANK = "rerank",
    UNKNOWN = "unknown"
}
declare enum AxSpanKindValues {
    WORKFLOW = "workflow",
    TASK = "task",
    AGENT = "agent",
    TOOL = "tool",
    UNKNOWN = "unknown"
}

interface AxRateLimiterTokenUsageOptions {
    debug?: boolean;
}
declare class AxRateLimiterTokenUsage {
    private options?;
    private maxTokens;
    private refillRate;
    private currentTokens;
    private lastRefillTime;
    constructor(maxTokens: number, refillRate: number, options?: Readonly<AxRateLimiterTokenUsageOptions>);
    private refillTokens;
    private waitUntilTokensAvailable;
    acquire(tokens: number): Promise<void>;
}

interface AxRouterForwardOptions {
    cutoff?: number;
}
declare class AxRoute {
    private readonly name;
    private readonly context;
    constructor(name: string, context: readonly string[]);
    getName(): string;
    getContext(): readonly string[];
}
declare class AxRouter {
    private readonly ai;
    private db;
    private debug?;
    constructor(ai: AxAIService);
    getState(): AxDBState | undefined;
    setState(state: AxDBState): void;
    setRoutes: (routes: readonly AxRoute[]) => Promise<void>;
    forward(text: string, options?: Readonly<AxRouterForwardOptions>): Promise<string>;
    setOptions(options: Readonly<{
        debug?: boolean;
    }>): void;
}

type AxEvaluateArgs<IN extends AxGenIn, OUT extends AxGenOut> = {
    ai: AxAIService;
    program: Readonly<AxProgram<IN, OUT>>;
    examples: Readonly<AxExample[]>;
};
declare class AxTestPrompt<IN extends AxGenIn = AxGenIn, OUT extends AxGenOut = AxGenOut> {
    private ai;
    private program;
    private examples;
    constructor({ ai, program, examples, }: Readonly<AxEvaluateArgs<IN, OUT>>);
    run(metricFn: AxMetricFn): Promise<void>;
}

declare class AxChainOfThought<IN extends AxGenIn = AxGenIn, OUT extends AxGenOut = AxGenOut> extends AxGen<IN, OUT & {
    reason: string;
}> {
    constructor(signature: Readonly<AxSignature | string>, options?: Readonly<AxGenOptions>);
}

declare class AxDefaultQueryRewriter extends AxGen<AxRewriteIn, AxRewriteOut> {
    constructor(options?: Readonly<AxGenOptions>);
}

declare class AxDefaultResultReranker extends AxGen<AxRerankerIn, AxRerankerOut> {
    constructor(options?: Readonly<AxGenOptions>);
    forward: (ai: Readonly<AxAIService>, input: Readonly<AxRerankerIn>, options?: Readonly<AxProgramForwardOptions>) => Promise<AxRerankerOut>;
}

declare class AxEmbeddingAdapter {
    private aiService;
    private info;
    private func;
    constructor({ ai, info, func, }: Readonly<{
        ai: AxAIService;
        info: Readonly<{
            name: string;
            description: string;
            argumentDescription: string;
        }>;
        func: (args: readonly number[], extra?: Readonly<AxAIServiceActionOptions>) => Promise<unknown>;
    }>);
    private embedAdapter;
    toFunction(): AxFunction;
}

declare class AxInstanceRegistry<T> {
    private reg;
    constructor();
    register(instance: T): void;
    [Symbol.iterator](): Generator<T, void, unknown>;
}

declare class AxRAG extends AxChainOfThought<{
    context: string[];
    question: string;
}, {
    answer: string;
}> {
    private genQuery;
    private queryFn;
    private maxHops;
    constructor(queryFn: (query: string) => Promise<string>, options: Readonly<AxGenOptions & {
        maxHops?: number;
    }>);
    forward(ai: Readonly<AxAIService>, { question }: Readonly<{
        question: string;
    }>, options?: Readonly<AxProgramForwardOptions>): Promise<{
        answer: string;
        reason: string;
    }>;
}

declare class AxValidationError extends Error {
    private field;
    private value;
    constructor({ message, field, value, }: Readonly<{
        message: string;
        field: AxField;
        value: string;
    }>);
    getField: () => AxField;
    getValue: () => string;
    getFixingInstructions: () => {
        name: string;
        title: string;
        description: string;
    }[];
}

export { AxAI, AxAIAnthropic, type AxAIAnthropicArgs, type AxAIAnthropicChatError, type AxAIAnthropicChatRequest, type AxAIAnthropicChatRequestCacheParam, type AxAIAnthropicChatResponse, type AxAIAnthropicChatResponseDelta, type AxAIAnthropicConfig, type AxAIAnthropicContentBlockDeltaEvent, type AxAIAnthropicContentBlockStartEvent, type AxAIAnthropicContentBlockStopEvent, type AxAIAnthropicErrorEvent, type AxAIAnthropicMessageDeltaEvent, type AxAIAnthropicMessageStartEvent, type AxAIAnthropicMessageStopEvent, AxAIAnthropicModel, type AxAIAnthropicPingEvent, type AxAIArgs, AxAIAzureOpenAI, type AxAIAzureOpenAIArgs, AxAICohere, type AxAICohereArgs, type AxAICohereChatRequest, type AxAICohereChatRequestToolResults, type AxAICohereChatResponse, type AxAICohereChatResponseDelta, type AxAICohereChatResponseToolCalls, type AxAICohereConfig, AxAICohereEmbedModel, type AxAICohereEmbedRequest, type AxAICohereEmbedResponse, AxAICohereModel, AxAIDeepSeek, type AxAIDeepSeekArgs, AxAIDeepSeekModel, type AxAIEmbedModels, AxAIGoogleGemini, type AxAIGoogleGeminiArgs, type AxAIGoogleGeminiBatchEmbedRequest, type AxAIGoogleGeminiBatchEmbedResponse, type AxAIGoogleGeminiChatRequest, type AxAIGoogleGeminiChatResponse, type AxAIGoogleGeminiChatResponseDelta, type AxAIGoogleGeminiConfig, type AxAIGoogleGeminiContent, AxAIGoogleGeminiEmbedModel, type AxAIGoogleGeminiGenerationConfig, AxAIGoogleGeminiModel, type AxAIGoogleGeminiOptionsTools, AxAIGoogleGeminiSafetyCategory, type AxAIGoogleGeminiSafetySettings, AxAIGoogleGeminiSafetyThreshold, type AxAIGoogleGeminiTool, type AxAIGoogleGeminiToolConfig, type AxAIGoogleGeminiToolFunctionDeclaration, type AxAIGoogleGeminiToolGoogleSearchRetrieval, AxAIGroq, type AxAIGroqArgs, AxAIGroqModel, AxAIHuggingFace, type AxAIHuggingFaceArgs, type AxAIHuggingFaceConfig, AxAIHuggingFaceModel, type AxAIHuggingFaceRequest, type AxAIHuggingFaceResponse, type AxAIMemory, AxAIMistral, type AxAIMistralArgs, AxAIMistralEmbedModels, AxAIMistralModel, type AxAIModelMap, type AxAIModels, AxAIOllama, type AxAIOllamaAIConfig, type AxAIOllamaArgs, AxAIOpenAI, type AxAIOpenAIArgs, type AxAIOpenAIChatRequest, type AxAIOpenAIChatResponse, type AxAIOpenAIChatResponseDelta, type AxAIOpenAIConfig, AxAIOpenAIEmbedModel, type AxAIOpenAIEmbedRequest, type AxAIOpenAIEmbedResponse, type AxAIOpenAILogprob, AxAIOpenAIModel, type AxAIOpenAIResponseDelta, type AxAIOpenAIUsage, type AxAIPromptConfig, AxAIReka, type AxAIRekaArgs, type AxAIRekaChatRequest, type AxAIRekaChatResponse, type AxAIRekaChatResponseDelta, type AxAIRekaConfig, AxAIRekaModel, type AxAIRekaUsage, type AxAIService, type AxAIServiceActionOptions, type AxAIServiceImpl, type AxAIServiceMetrics, type AxAIServiceOptions, AxAITogether, type AxAITogetherArgs, type AxAPI, AxAgent, type AxAgentOptions, type AxAgentic, AxApacheTika, type AxApacheTikaArgs, type AxApacheTikaConvertOptions, type AxAssertion, AxAssertionError, AxBalancer, type AxBalancerOptions, AxBaseAI, type AxBaseAIArgs, type AxBaseAIFeatures, AxBootstrapFewShot, AxChainOfThought, type AxChatRequest, type AxChatResponse, type AxChatResponseFunctionCall, type AxChatResponseResult, AxDB, type AxDBArgs, AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions, AxDBCloudflare, type AxDBCloudflareArgs, type AxDBCloudflareOpOptions, type AxDBLoaderOptions, AxDBManager, type AxDBManagerArgs, type AxDBMatch, AxDBMemory, type AxDBMemoryArgs, type AxDBMemoryOpOptions, AxDBPinecone, type AxDBPineconeArgs, type AxDBPineconeOpOptions, type AxDBQueryRequest, type AxDBQueryResponse, type AxDBQueryService, type AxDBService, type AxDBState, type AxDBUpsertRequest, type AxDBUpsertResponse, AxDBWeaviate, type AxDBWeaviateArgs, type AxDBWeaviateOpOptions, type AxDataRow, AxDefaultQueryRewriter, AxDefaultResultReranker, type AxDockerContainer, AxDockerSession, type AxEmbedRequest, type AxEmbedResponse, AxEmbeddingAdapter, type AxEvaluateArgs, type AxExample, type AxField, type AxFieldTemplateFn, type AxFieldValue, type AxFunction, type AxFunctionExec, type AxFunctionHandler, type AxFunctionJSONSchema, AxFunctionProcessor, AxGen, type AxGenIn, type AxGenOptions, type AxGenOut, type AxGenerateResult, AxHFDataLoader, type AxIField, type AxInputFunctionType, AxInstanceRegistry, type AxInternalChatRequest, type AxInternalEmbedRequest, AxJSInterpreter, AxJSInterpreterPermission, AxLLMRequestTypeValues, AxMemory, type AxMetricFn, type AxMetricFnArgs, type AxModelConfig, type AxModelInfo, type AxModelInfoWithProvider, type AxOptimizerArgs, AxProgram, type AxProgramDemos, type AxProgramExamples, type AxProgramForwardOptions, type AxProgramTrace, type AxProgramUsage, AxProgramWithSignature, type AxProgramWithSignatureOptions, AxPromptTemplate, AxRAG, type AxRateLimiterFunction, AxRateLimiterTokenUsage, type AxRateLimiterTokenUsageOptions, type AxRerankerIn, type AxRerankerOut, type AxResponseHandlerArgs, type AxRewriteIn, type AxRewriteOut, AxRoute, AxRouter, type AxRouterForwardOptions, AxSignature, AxSpanKindValues, type AxStreamingAssertion, AxTestPrompt, type AxTokenUsage, type AxTunable, type AxUsable, AxValidationError };
